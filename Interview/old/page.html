<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>温故而知新 | Luck Blog</title>
    <meta name="description" content="关注web前端开发为主的博客网站和前端网址大全">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/rookie-fly-blog/assets/style.BAwI673z.css" as="style">
    <link rel="preload stylesheet" href="/rookie-fly-blog/vp-icons.css" as="style">
    
    <script type="module" src="/rookie-fly-blog/assets/app.CMP79n9z.js"></script>
    <link rel="preload" href="/rookie-fly-blog/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/rookie-fly-blog/assets/chunks/theme.pHxtYc5h.js">
    <link rel="modulepreload" href="/rookie-fly-blog/assets/chunks/framework.BBy0ZaTh.js">
    <link rel="modulepreload" href="/rookie-fly-blog/assets/Interview_old_page.md.DRwqL1py.lean.js">
    <link rel="icon" href="/rookie-fly-blog/favicon.ico">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/rookie-fly-blog/" data-v-1168a8e4><!--[--><!--]--><!--[--><img class="VPImage logo" src="/rookie-fly-blog/logo.png" alt data-v-8426fc1a><!--]--><!----><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/rookie-fly-blog/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>首页</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/rookie-fly-blog/guide/start.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>前端导航</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/rookie-fly-blog/openSource/open-source.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>我的开源</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-dc692963 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-cf11d7a2><span class="text" data-v-cf11d7a2><!----><span data-v-cf11d7a2>故知新</span><span class="vpi-chevron-down text-icon" data-v-cf11d7a2></span></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><div class="items" data-v-b98bc113><!--[--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/rookie-fly-blog/learning/browserNetwork/page.html" data-v-35975db6><!--[--><span data-v-35975db6>浏览器与网络</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/rookie-fly-blog/learning/optimization/page.html" data-v-35975db6><!--[--><span data-v-35975db6>前端性能优化</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/rookie-fly-blog/learning/core/page.html" data-v-35975db6><!--[--><span data-v-35975db6>JavaScript 核心</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/rookie-fly-blog/learning/vue/page.html" data-v-35975db6><!--[--><span data-v-35975db6>Vue 框架</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/rookie-fly-blog/learning/layoutStyle/page.html" data-v-35975db6><!--[--><span data-v-35975db6>样式与布局</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/rookie-fly-blog/learning/engineering/page.html" data-v-35975db6><!--[--><span data-v-35975db6>构建工具及工程化</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/rookie-fly-blog/learning/other/page.html" data-v-35975db6><!--[--><span data-v-35975db6>其它</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-dc692963 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-cf11d7a2><span class="text" data-v-cf11d7a2><!----><span data-v-cf11d7a2>小说</span><span class="vpi-chevron-down text-icon" data-v-cf11d7a2></span></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><div class="items" data-v-b98bc113><!--[--><!--[--><div class="VPMenuLink" data-v-b98bc113 data-v-35975db6><a class="VPLink link" href="/rookie-fly-blog/novel/overachiever/page.html" data-v-35975db6><!--[--><span data-v-35975db6>卷王仙尊</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/shufei021/rookie-fly-blog" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/shufei021/rookie-fly-blog" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-8a42e2b4><button data-v-8a42e2b4>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>温故</h2><!----></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/rookie-fly-blog/Interview/old/pages/page1.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>浏览器输入URL到渲染过程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/rookie-fly-blog/Interview/old/pages/page2.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>前端性能优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/rookie-fly-blog/Interview/old/pages/page3.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>前端首屏优化</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/rookie-fly-blog/Interview/old/pages/page4.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>前端内存泄漏</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/rookie-fly-blog/Interview/old/pages/page5.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>前端缓存</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/rookie-fly-blog/Interview/old/pages/page6.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>前端事件轮询</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/rookie-fly-blog/Interview/old/pages/page7.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>ES6新特性</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>目录</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _rookie-fly-blog_Interview_old_page" data-v-39a288b8><div><h1 id="温故而知新" tabindex="-1">温故而知新 <a class="header-anchor" href="#温故而知新" aria-label="Permalink to &quot;温故而知新&quot;">​</a></h1><h2 id="javsscript-相关" tabindex="-1">JavsScript 相关 <a class="header-anchor" href="#javsscript-相关" aria-label="Permalink to &quot;JavsScript 相关&quot;">​</a></h2><h3 id="箭头函数和普通函数的区别" tabindex="-1">箭头函数和普通函数的区别 <a class="header-anchor" href="#箭头函数和普通函数的区别" aria-label="Permalink to &quot;箭头函数和普通函数的区别&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>箭头函数</th><th>普通函数</th></tr></thead><tbody><tr><td><code>this</code> 指向</td><td>外层作用域</td><td>调用者</td></tr><tr><td><code>arguments</code></td><td>不支持</td><td>支持</td></tr><tr><td><code>new</code> 调用</td><td>不可作为构造函数</td><td>可以</td></tr><tr><td><code>prototype</code> 属性</td><td>无</td><td>有</td></tr><tr><td><code>super</code></td><td>不支持</td><td>支持</td></tr></tbody></table><ol><li><p><strong><code>this</code> 绑定</strong></p><ul><li>普通函数：有自己的 <code>this</code>，其值由调用方式决定（如直接调用时指向 <code>window</code>，对象方法调用时指向对象）。</li><li>箭头函数：<strong>没有自己的 <code>this</code></strong>，继承外层作用域的 <code>this</code>（词法作用域），且无法通过 <code>call</code>/<code>apply</code>/<code>bind</code> 修改。</li></ul></li><li><p><strong><code>arguments</code> 对象</strong></p><ul><li>普通函数：可通过 <code>arguments</code> 访问所有传入参数。</li><li>箭头函数：<strong>没有 <code>arguments</code></strong>，需使用剩余参数（<code>...args</code>）替代。</li></ul></li><li><p><strong>构造函数与 <code>prototype</code></strong></p><ul><li>普通函数：可作为构造函数（<code>new</code> 调用），拥有 <code>prototype</code> 属性。</li><li>箭头函数：<strong>不能作为构造函数</strong>（<code>new</code> 调用会报错），且<strong>无 <code>prototype</code> 属性</strong>。</li></ul></li><li><p><strong><code>super</code> 关键字</strong></p><ul><li>普通函数：可在类方法中通过 <code>super</code> 访问父类属性/方法。</li><li>箭头函数：<strong>不能使用 <code>super</code></strong>（因不属于类方法）。</li></ul></li><li><p><strong>其他差异</strong></p><ul><li><strong>语法简洁性</strong>：箭头函数可省略 <code>return</code> 和 <code>{}</code>（单表达式时）。</li><li><strong>不适用场景</strong>： <ul><li>需要动态 <code>this</code> 的方法（如事件处理器、对象方法）。</li><li>需要 <code>arguments</code> 或函数提升（箭头函数必须先定义后使用）。</li></ul></li></ul></li></ol><hr><h4 id="关键点说明" tabindex="-1">关键点说明 <a class="header-anchor" href="#关键点说明" aria-label="Permalink to &quot;关键点说明&quot;">​</a></h4><ul><li><strong>为什么箭头函数无 <code>this</code>？</strong><br> 设计初衷是为了解决回调中 <code>this</code> 丢失的问题（如 <code>setTimeout</code> 内普通函数的 <code>this</code> 指向 <code>window</code>）。</li><li><strong>为何不能 <code>new</code>？</strong><br> 箭头函数没有 <code>[[Construct]]</code> 内部方法，且无 <code>prototype</code> 供实例继承。</li></ul><h4 id="示例对比" tabindex="-1">示例对比 <a class="header-anchor" href="#示例对比" aria-label="Permalink to &quot;示例对比&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 普通函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this 由 new 决定</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sayHi</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 箭头函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 报错：Foo is not a constructor</span></span></code></pre></div><h3 id="原型和原型链" tabindex="-1">原型和原型链 <a class="header-anchor" href="#原型和原型链" aria-label="Permalink to &quot;原型和原型链&quot;">​</a></h3><p>每个对象（除了null）都有一个原型链（Prototype Chain），它是一条用来查找对象属性的链条。</p><ul><li>原型：每个函数都有一个 prototype 属性，指向一个对象。</li><li>原型链：当访问一个对象的属性时，如果该对象本身没有这个属性，就会去它的原型对象中找，以此类推，直到找到或到终点 null。</li></ul><p>所有构造函数都是Function的实例，所有原型对象都是Object的实例除了Object.prototype</p><p>总结：原型是实现继承的基础，原型链是属性查找的机制。</p><h2 id="前端工程化" tabindex="-1">前端工程化 <a class="header-anchor" href="#前端工程化" aria-label="Permalink to &quot;前端工程化&quot;">​</a></h2><h3 id="webpack-的构建流程" tabindex="-1">Webpack 的构建流程 <a class="header-anchor" href="#webpack-的构建流程" aria-label="Permalink to &quot;Webpack 的构建流程&quot;">​</a></h3><ul><li><ol><li>初始化参数：读取配置文件，合并默认参数；</li></ol></li><li><ol start="2"><li>入口分析：根据 <code>entry</code> 找到入口模块；</li></ol></li><li><ol start="3"><li>编译模块：使用 loader 转换不同类型的资源；</li></ol></li><li><ol start="4"><li>依赖收集：递归解析模块依赖，构建依赖图；</li></ol></li><li><ol start="5"><li>优化打包：Tree Shaking、代码分割（Code Splitting）、合并 chunk；</li></ol></li><li><ol start="6"><li>输出资源：将最终资源写入 <code>dist</code> 目录。</li></ol></li></ul><h4 id="常用的loader-plugin" tabindex="-1">常用的Loader/plugin <a class="header-anchor" href="#常用的loader-plugin" aria-label="Permalink to &quot;常用的Loader/plugin&quot;">​</a></h4><p>Webpack 是一个强大的模块打包工具，它通过各种插件和 loader 来增强其功能。下面列出一些常用的 Webpack 插件和 loader：</p><h5 id="常用-loader" tabindex="-1">常用 Loader <a class="header-anchor" href="#常用-loader" aria-label="Permalink to &quot;常用 Loader&quot;">​</a></h5><ul><li><ol><li><strong>Babel-loader</strong>: 将 ES6+ 代码转换为向后兼容的 JavaScript 版本。</li></ol></li><li><ol start="2"><li><strong>Css-loader &amp; Style-loader</strong>: <code>css-loader</code> 解析 CSS 文件中的 <code>@import</code> 和 <code>url()</code>，而 <code>style-loader</code> 将 CSS 注入到 DOM 中。</li></ol></li><li><ol start="3"><li><strong>File-loader</strong>: 用于处理文件导入（如图片、字体等），将它们复制到输出目录，并返回正确的 URL。</li></ol></li><li><ol start="4"><li><strong>Url-loader</strong>: 功能类似于 file-loader，但可以将文件转换成 base64 URI。</li></ol></li><li><ol start="5"><li><strong>Sass/Less-loader</strong>: 如果项目使用 Sass 或 Less 等预处理器，则需要对应的 loader 来解析这些文件。</li></ol></li><li><ol start="6"><li><strong>Postcss-loader</strong>: 结合 PostCSS 插件自动添加浏览器前缀或进行其他 CSS 处理。</li></ol></li><li><ol start="7"><li><strong>Ts-loader</strong>: 如果你的项目是 TypeScript 项目，那么你可能需要 ts-loader 来编译 TypeScript。</li></ol></li></ul><h5 id="常用插件" tabindex="-1">常用插件 <a class="header-anchor" href="#常用插件" aria-label="Permalink to &quot;常用插件&quot;">​</a></h5><ul><li><ol><li><strong>Html-webpack-plugin</strong>: 自动生成 HTML 文件，并在其中自动引入所有生成的 bundle。</li></ol></li><li><ol start="2"><li><strong>Clean-webpack-plugin</strong>: 在每次构建之前清理输出目录。</li></ol></li><li><ol start="3"><li><strong>Mini-css-extract-plugin</strong>: 提取 CSS 到单独的文件中，而不是像 style-loader 那样直接注入到 HTML 中。</li></ol></li><li><ol start="4"><li><strong>Copy-webpack-plugin</strong>: 可以方便地将单个文件或整个目录复制到构建目录。</li></ol></li><li><ol start="5"><li><strong>Define-plugin</strong>: 允许创建可在编译时配置的全局常量。</li></ol></li><li><ol start="6"><li><strong>Hot-module-replacement (HMR)</strong>: 不刷新页面的情况下更新模块，提高开发效率。</li></ol></li><li><ol start="7"><li><strong>Terser-webpack-plugin</strong>: 压缩你的 JavaScript。</li></ol></li><li><ol start="8"><li><strong>Optimize-css-assets-webpack-plugin</strong>: 压缩和优化 CSS 文件。</li></ol></li><li><ol start="9"><li><strong>Bundle-analyzer-plugin</strong>: 可视化展示你的包内容，帮助分析和优化包大小。</li></ol></li></ul><p>每个项目的需求不同，因此选择哪些 loader 和插件取决于项目的具体需求。随着 Webpack 的版本迭代，一些插件和 loader 可能会有更好的替代品或者新的功能加入，请根据实际情况进行选择和配置。</p><h3 id="vite-的构建流程" tabindex="-1">vite 的构建流程 <a class="header-anchor" href="#vite-的构建流程" aria-label="Permalink to &quot;vite 的构建流程&quot;">​</a></h3><p>Vite 是一个基于原生 ES 模块（ESM）的前端构建工具，旨在提供更快、更高效的开发体验。它与传统的打包工具（如 Webpack、Rollup）不同，主要利用浏览器对原生 ES Modules 的支持，在开发模式下实现<strong>无需打包编译的即时加载</strong>。</p><h4 id="常用的plugin" tabindex="-1">常用的plugin <a class="header-anchor" href="#常用的plugin" aria-label="Permalink to &quot;常用的plugin&quot;">​</a></h4><p>Vite 是一个现代的前端构建工具，它提供了快速的开发服务器和优化的构建流程。与 Webpack 不同，Vite 利用了浏览器对 ES 模块的支持来提供更快的开发体验，并且它的插件系统基于 Rollup 的插件系统。下面是一些常用的 Vite 插件以及它们的作用：</p><p><strong>常用插件</strong></p><ul><li><code>@vitejs/plugin-react</code>: 支持 React 项目，包括 JSX 和 React Fast Refresh（在开发过程中无需刷新页面即可更新组件）。</li><li><code>@vitejs/plugin-vue</code>: 支持 Vue 3 项目，包含对单文件组件(SFC)、JSX 和其他 Vue 特性的支持。</li><li><code>@vitejs/plugin-legacy</code>: 生成针对旧版浏览器的包，确保兼容性。</li><li><code>vite-plugin-eslint</code>: 在开发过程中实时检查代码风格错误。</li><li><code>vite-plugin-style-import</code>: 对于使用 Ant Design 等组件库时，可以按需导入样式，减少打包体积。 +<code> vite-plugin-mock</code>: 提供模拟 API 的功能，方便前端独立开发和调试。</li><li><code>vite-plugin-pwa</code>: 添加 PWA 支持，使你的应用可以离线运行。</li><li><code>vite-plugin-compression</code>: 为生产环境生成压缩版本的资源文件（如 Gzip 或 Brotli）。</li><li><code>vite-plugin-imagemin</code>: 压缩图片资源，减小图片大小。</li></ul><p><strong>注意事项</strong></p><p>虽然 Vite 主要依赖于插件而非 loader 来扩展其功能，但需要注意的是，由于 Vite 直接利用了原生 ES 模块进行开发，许多在 Webpack 中需要通过 loader 处理的任务（例如处理 CSS、图片等静态资源）在 Vite 中通常不需要额外配置或只需要简单的配置即可完成。</p><p>下面是 <strong>Vite 的构建流程详解</strong>，分为 <strong>开发模式（Dev Server）</strong> 和 <strong>生产构建（Build）</strong> 两个阶段：</p><h4 id="🚀-一、开发模式-dev-server" tabindex="-1">🚀 一、开发模式（Dev Server） <a class="header-anchor" href="#🚀-一、开发模式-dev-server" aria-label="Permalink to &quot;🚀 一、开发模式（Dev Server）&quot;">​</a></h4><p>在开发模式下，Vite 并不会将整个项目打包成 bundle 文件，而是通过浏览器原生支持的 <code>import</code> / <code>export</code> 来按需加载模块。</p><h5 id="🔁-核心流程如下" tabindex="-1">🔁 核心流程如下： <a class="header-anchor" href="#🔁-核心流程如下" aria-label="Permalink to &quot;🔁 核心流程如下：&quot;">​</a></h5><ol><li><p><strong>启动开发服务器</strong></p><ul><li>启动一个本地 HTTP 服务器，默认监听 <code>localhost:5173</code>。</li><li>支持热更新（HMR）、TypeScript、JSX、CSS 预处理器等。</li></ul></li><li><p><strong>浏览器请求入口文件（如：index.html）</strong></p><ul><li>浏览器加载 HTML 文件后，会解析其中的 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签。</li><li>请求对应的 JavaScript 入口文件（如：<code>main.js</code>）。</li></ul></li><li><p><strong>中间件处理请求</strong></p><ul><li>Vite 使用插件系统来拦截和处理各种类型的文件请求： <ul><li><code>.js</code>, <code>.ts</code>, <code>.vue</code>, <code>.jsx</code>, <code>.css</code>, <code>.json</code> 等。</li></ul></li><li>插件可以进行： <ul><li>类型转换（如 TypeScript 编译为 JS）</li><li>CSS 预处理器编译（Sass、Less、PostCSS）</li><li>路径别名解析</li><li>HMR 更新通知</li></ul></li></ul></li><li><p><strong>按需编译和返回模块</strong></p><ul><li>只有当浏览器实际请求某个模块时，Vite 才会对其进行编译。</li><li>例如：<code>import { createApp } from &#39;vue&#39;</code> 会被 Vite 解析并重写为 <code>/@modules/vue.js</code>，然后从缓存或 node_modules 中读取并返回给浏览器。</li></ul></li><li><p><strong>热更新（HMR）</strong></p><ul><li>当源文件发生更改时，Vite 会自动检测变化，并只更新变更的部分，而不需要刷新整个页面。</li></ul></li><li><p><strong>缓存优化</strong></p><ul><li>第一次请求的模块会被缓存，后续请求直接从内存中获取，提升速度。</li></ul></li></ol><h5 id="✅-开发模式优点" tabindex="-1">✅ 开发模式优点： <a class="header-anchor" href="#✅-开发模式优点" aria-label="Permalink to &quot;✅ 开发模式优点：&quot;">​</a></h5><ul><li>极快的冷启动时间（几乎瞬间）</li><li>即时热更新（毫秒级响应）</li><li>无需等待整个项目打包</li></ul><hr><h4 id="🛠️-二、生产构建-production-build" tabindex="-1">🛠️ 二、生产构建（Production Build） <a class="header-anchor" href="#🛠️-二、生产构建-production-build" aria-label="Permalink to &quot;🛠️ 二、生产构建（Production Build）&quot;">​</a></h4><p>在生产环境中，为了兼容旧浏览器和提高性能，Vite 会使用 <a href="https://rollupjs.org/" target="_blank" rel="noreferrer">Rollup</a> 进行真正的打包操作。</p><h5 id="🔧-构建流程如下" tabindex="-1">🔧 构建流程如下： <a class="header-anchor" href="#🔧-构建流程如下" aria-label="Permalink to &quot;🔧 构建流程如下：&quot;">​</a></h5><ol><li><p><strong>执行 <code>vite build</code> 命令</strong></p><ul><li>Vite 内部调用 Rollup 配置生成打包计划。</li></ul></li><li><p><strong>依赖分析</strong></p><ul><li>Rollup 分析所有依赖项，并确定需要打包的模块。</li></ul></li><li><p><strong>代码压缩与优化</strong></p><ul><li>使用 <code>terser</code>（JS）和 <code>csso</code>（CSS）进行代码压缩。</li><li>Tree-shaking 移除未使用的代码。</li></ul></li><li><p><strong>输出静态资源</strong></p><ul><li>将最终的 JS、CSS、图片等资源输出到 <code>dist/</code> 目录（默认）。</li><li>输出结构包括： <ul><li>JS chunk</li><li>CSS chunk</li><li>静态资源（图片、字体等）</li><li>HTML 入口文件</li></ul></li></ul></li><li><p><strong>配置支持</strong></p><ul><li>支持自定义 Rollup 配置，用于控制输出格式、拆包策略等。</li></ul></li></ol><h5 id="📦-生产环境特点" tabindex="-1">📦 生产环境特点： <a class="header-anchor" href="#📦-生产环境特点" aria-label="Permalink to &quot;📦 生产环境特点：&quot;">​</a></h5><ul><li>支持代码分割（Code Splitting）</li><li>支持异步加载（Dynamic Import）</li><li>支持多种输出格式（如 IIFE、ESM、UMD）</li><li>自动 Polyfill（如果目标浏览器不支持 ESM）</li></ul><hr><h4 id="🧩-插件机制-plugin-system" tabindex="-1">🧩 插件机制（Plugin System） <a class="header-anchor" href="#🧩-插件机制-plugin-system" aria-label="Permalink to &quot;🧩 插件机制（Plugin System）&quot;">​</a></h4><p>Vite 的强大之处在于其插件系统，开发者可以通过插件扩展功能，比如：</p><ul><li>支持 Vue、React、Preact</li><li>TypeScript 支持（<code>@vitejs/plugin-vue</code>, <code>@vitejs/plugin-react</code>, <code>@vitejs/plugin-typescript</code>）</li><li>CSS 预处理器（Sass、Less）</li><li>PostCSS、Tailwind CSS 集成</li><li>自定义插件编写</li></ul><hr><h4 id="📌-总结对比表" tabindex="-1">📌 总结对比表 <a class="header-anchor" href="#📌-总结对比表" aria-label="Permalink to &quot;📌 总结对比表&quot;">​</a></h4><table tabindex="0"><thead><tr><th>阶段</th><th>特点</th><th>技术基础</th><th>优点</th></tr></thead><tbody><tr><td>开发模式</td><td>按需加载、热更新</td><td>原生 ESM</td><td>极快冷启动、快速 HMR</td></tr><tr><td>生产构建</td><td>打包、压缩、Tree-shaking</td><td>Rollup</td><td>体积小、性能优、兼容性强</td></tr></tbody></table><hr><h4 id="🧪-示例命令" tabindex="-1">🧪 示例命令 <a class="header-anchor" href="#🧪-示例命令" aria-label="Permalink to &quot;🧪 示例命令&quot;">​</a></h4><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 启动开发服务器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 构建生产版本</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 预览构建结果</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> preview</span></span></code></pre></div><h2 id="vue-js-相关" tabindex="-1">Vue.js 相关 <a class="header-anchor" href="#vue-js-相关" aria-label="Permalink to &quot;Vue.js 相关&quot;">​</a></h2><!----><!----><h3 id="vue的生命周期" tabindex="-1">vue的生命周期 <a class="header-anchor" href="#vue的生命周期" aria-label="Permalink to &quot;vue的生命周期&quot;">​</a></h3><ul><li><code>beforeCreate</code>:<strong>这个钩子在实例初始化之后、数据观测 (data observer) 和 event/watcher 事件配置之前被调用</strong>,不过，在 Composition API 中，通常使用 setup() 函数来处理这一阶段的逻辑，因此这个钩子不常用。</li><li><code>created</code>：<strong>在实例创建完成后立即调用</strong>。在这个阶段，实例已经完成了数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。但是，挂载阶段还没开始，$el 属性目前不可见</li><li><code>beforeMount</code>：<strong>在挂载开始之前被调用</strong>：相关的 render 函数首次被调用。此时，虚拟 DOM 尚未渲染到真实 DOM 上</li><li><code>mounted</code>：<strong>在 el 被新创建的 vm.$el 替换，并挂载到实例上后调用</strong>。这时，组件已经被渲染到 DOM 中，可以访问 DOM 元素了。</li><li><code>beforeUpdate</code>：<em>在数据更新时，在虚拟 DOM 打补丁之前调用</em>*。此时，可以获取更新前的状态，适合用来进行一些清理工作。</li><li><code>updated</code>：<strong>在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用</strong>。此时，组件 DOM 已经更新，可以执行依赖于 DOM 的操作。然而，避免在此期间改变状态，因为这可能会导致无限的更新循环</li><li><code>beforeUnmount（在 Vue 2 中为 beforeDestroy）</code>：<strong>发生在实例销毁之前，在当前阶段实例完全可以被使用</strong>。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。</li><li><code>unmounted（在 Vue 2 中为 destroyed）</code>:<strong>卸载组件实例后调用</strong>。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。</li></ul><p><strong>activated 和 deactivated 是 Vue 中专门用于 &lt; keep-alive&gt; 缓存组件时的生命周期钩子</strong></p><ul><li><code>activated</code>：<strong>当组件被 &lt; keep-alive&gt; 缓存后，每次该组件被激活（显示）时调用</strong>。可以在这里执行组件重新展示时需要的逻辑，比如重新获取数据、恢复动画、计时器等</li><li><code>deactivated</code>：<strong>当组件被缓存后，离开当前视图（被切换出去）时调用</strong>。可以在这里进行一些资源释放操作，比如清除定时器、取消事件监听、停止动画等，防止内存泄漏。</li></ul><h3 id="vue-的双向数据绑定原理" tabindex="-1">Vue 的双向数据绑定原理 <a class="header-anchor" href="#vue-的双向数据绑定原理" aria-label="Permalink to &quot;Vue 的双向数据绑定原理&quot;">​</a></h3><p><code>Vue</code> 使用 <code>Object.defineProperty</code> 或 <code>Proxy</code> 劫持数据，结合 <code>Watcher</code> 实现依赖收集。当数据变化时，通知视图更新；当视图中表单等发生变化时，也会同步更新数据，从而实现双向绑定。”</p><details class="details custom-block" open=""><summary>Details</summary><p>Vue 的双向绑定本质是<code>数据劫持 + 发布订阅模式</code>。在 Vue 2 中通过 Object.defineProperty 递归转换 data 的每个属性为 getter/setter，在 getter 中收集依赖（Watcher），在 setter 中通知更新。视图层通过 v-model 指令实现双向绑定，它本质是 value 属性绑定和 input 事件监听的语法糖。</p><p>Vue 3 改用 Proxy 实现，优势在于能直接监听整个对象且自动处理新增属性。整个系统还包含异步批量更新和虚拟 DOM diff 等优化机制，既保持了开发便捷性又保证了性能。</p></details><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue2 实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineReactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, key, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVal) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVal;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;数据更新了&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineReactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Vue3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 控制台输出 &quot;数据更新了&quot;</span></span></code></pre></div><hr><h3 id="vue2-和-vue3-的区别" tabindex="-1">Vue2 和 Vue3 的区别 <a class="header-anchor" href="#vue2-和-vue3-的区别" aria-label="Permalink to &quot;Vue2 和 Vue3 的区别&quot;">​</a></h3><p>Vue3 相对于 Vue2 做了较大的改进，主要体现在以下几个方面：</p><hr><h4 id="✅-1-组合式-api-vs-选项式-api" tabindex="-1">✅ 1. <strong>组合式 API vs 选项式 API</strong> <a class="header-anchor" href="#✅-1-组合式-api-vs-选项式-api" aria-label="Permalink to &quot;✅ 1. **组合式 API vs 选项式 API**&quot;">​</a></h4><ul><li><strong>Vue2</strong> 使用 Options API（如 <code>data</code>、<code>methods</code>、<code>computed</code> 等）组织代码，逻辑分散，不易复用。</li><li><strong>Vue3</strong> 引入了 Composition API（如 <code>setup()</code>、<code>ref</code>、<code>reactive</code>、<code>watch</code> 等），更灵活，更适合逻辑复用和大型项目的维护。</li></ul><hr><h4 id="✅-2-性能优化" tabindex="-1">✅ 2. <strong>性能优化</strong> <a class="header-anchor" href="#✅-2-性能优化" aria-label="Permalink to &quot;✅ 2. **性能优化**&quot;">​</a></h4><ul><li><strong>更快的虚拟 DOM</strong>：Vue3 重写了虚拟 DOM，实现更快的 diff 算法。</li><li><strong>编译优化</strong>：静态提升、事件缓存等机制使渲染更高效。</li><li><strong>Tree-shaking 支持</strong>：Vue3 使用 ES Module 编写，可以按需引入，减小打包体积。</li></ul><hr><h4 id="✅-3-响应式系统升级" tabindex="-1">✅ 3. <strong>响应式系统升级</strong> <a class="header-anchor" href="#✅-3-响应式系统升级" aria-label="Permalink to &quot;✅ 3. **响应式系统升级**&quot;">​</a></h4><ul><li><strong>Vue2</strong> 使用 <code>Object.defineProperty</code>，不支持对数组、新增属性的完全监测。</li><li><strong>Vue3</strong> 改用 <code>Proxy</code> 实现响应式，更彻底、性能更好，支持更复杂的数据结构。</li></ul><hr><h4 id="✅-4-fragment-teleport-suspense-支持" tabindex="-1">✅ 4. <strong>Fragment / Teleport / Suspense 支持</strong> <a class="header-anchor" href="#✅-4-fragment-teleport-suspense-支持" aria-label="Permalink to &quot;✅ 4. **Fragment / Teleport / Suspense 支持**&quot;">​</a></h4><ul><li><strong>Fragment</strong>：Vue3 组件可以返回多个根节点，Vue2 不支持。</li><li><strong>Teleport</strong>：可以将组件渲染到 DOM 的任意位置，适合弹窗等场景。</li><li><strong>Suspense</strong>：用于异步组件的加载状态处理，配合 <code>&lt;script setup&gt;</code> 更加简洁。</li></ul><hr><h4 id="✅-5-typescript-支持更好" tabindex="-1">✅ 5. <strong>TypeScript 支持更好</strong> <a class="header-anchor" href="#✅-5-typescript-支持更好" aria-label="Permalink to &quot;✅ 5. **TypeScript 支持更好**&quot;">​</a></h4><ul><li>Vue3 是用 TypeScript 重写的，原生支持类型推导和开发体验，Vue2 对 TypeScript 支持较弱。</li></ul><hr><h4 id="✅-6-生命周期钩子不同" tabindex="-1">✅ 6. <strong>生命周期钩子不同</strong> <a class="header-anchor" href="#✅-6-生命周期钩子不同" aria-label="Permalink to &quot;✅ 6. **生命周期钩子不同**&quot;">​</a></h4><ul><li>Composition API 下生命周期名称为 <code>onMounted</code>、<code>onUnmounted</code> 等，更接近函数语义。</li><li>而 Vue2 是 <code>mounted</code>、<code>destroyed</code> 等选项式 API。</li><li>vue3中 beforeDestroy-&gt;onBeforeUnmounted, destroyed-&gt;onUnmounted</li><li>beforeCreate、created 被语法糖 setup 替代</li></ul><hr><h3 id="vue-的生命周期有哪些及每个生命周期做了什么" tabindex="-1">Vue 的生命周期有哪些及每个生命周期做了什么 <a class="header-anchor" href="#vue-的生命周期有哪些及每个生命周期做了什么" aria-label="Permalink to &quot;Vue 的生命周期有哪些及每个生命周期做了什么&quot;">​</a></h3><table tabindex="0"><thead><tr><th>生命周期钩子</th><th>描述</th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td>实例初始化之后，数据观测和事件配置之前</td></tr><tr><td><code>created</code></td><td>实例创建完成，数据观测、属性和方法的运算、watch/event 事件回调建立</td></tr><tr><td><code>beforeMount</code></td><td>模板编译挂载之前</td></tr><tr><td><code>mounted</code></td><td>模板编译挂载完成</td></tr><tr><td><code>beforeUpdate</code></td><td>数据更新时，虚拟 DOM 重新渲染之前</td></tr><tr><td><code>updated</code></td><td>虚拟 DOM 重新渲染之后</td></tr><tr><td><code>beforeUnmount</code></td><td>实例销毁之前</td></tr><tr><td><code>unmounted</code></td><td>实例销毁之后</td></tr></tbody></table><hr><details class="details custom-block" open=""><summary>Details</summary><p>Vue 的生命周期分为创建、挂载、更新和卸载四个阶段。</p><p>创建阶段：beforeCreate 时数据还未初始化，created 时可以访问数据但 DOM 未挂载。</p><p>挂载阶段：beforeMount 生成虚拟 DOM，mounted 时真实 DOM 已渲染完成。</p><p>更新阶段：数据变化时触发 beforeUpdate 和 updated，分别对应 DOM 更新前和更新后。</p><p>卸载阶段：beforeUnmount 可清理资源，unmounted 时实例已销毁。 此外，&lt; keep-alive&gt; 缓存的组件会触发 activated 和 deactivated。 实际开发中，我常在 created 请求数据，在 mounted 操作 DOM，在 beforeUnmount 移除事件监听。</p></details><h3 id="vue-的自定义指令用过吗-有哪些" tabindex="-1">Vue 的自定义指令用过吗，有哪些 <a class="header-anchor" href="#vue-的自定义指令用过吗-有哪些" aria-label="Permalink to &quot;Vue 的自定义指令用过吗，有哪些&quot;">​</a></h3><ul><li><code>v-focus</code>：自动聚焦输入框；</li><li><code>v-permission</code>：权限控制；</li><li><code>v-lazy</code>：图片懒加载；</li><li><code>v-throttle</code>：防抖节流；</li><li><code>v-draggable</code>：拖拽行为。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注册自定义指令 v-focus</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;focus&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h3 id="vue-如何优化-seo" tabindex="-1">Vue 如何优化 SEO <a class="header-anchor" href="#vue-如何优化-seo" aria-label="Permalink to &quot;Vue 如何优化 SEO&quot;">​</a></h3><ul><li><strong>SSR（服务端渲染）</strong>：使用 Nuxt.js 实现首屏直出；</li><li><strong>预渲染（Prerendering）</strong>：静态站点可用 <code>prerender-spa-plugin</code>；</li><li><strong>Meta 标签动态注入</strong>：使用 <code>vue-meta</code> 管理 meta 信息；</li><li><strong>结构语义化标签</strong>：合理使用 <code>h1~h6</code>、<code>nav</code>、<code>main</code> 等；</li><li><strong>服务端渲染 + 客户端激活（Hydration）</strong>：兼顾性能与 SEO。</li></ul><hr><h4 id="✅-7-其他变化" tabindex="-1">✅ 7. <strong>其他变化</strong> <a class="header-anchor" href="#✅-7-其他变化" aria-label="Permalink to &quot;✅ 7. **其他变化**&quot;">​</a></h4><ul><li>更简洁的模板编译器。</li><li>新的 <code>&lt;script setup&gt;</code> 语法糖让代码更清晰。</li><li>更强大的插件系统和更现代的架构设计。</li></ul><table tabindex="0"><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>响应式系统</td><td><code>Object.defineProperty</code></td><td><code>Proxy</code></td></tr><tr><td>Composition API</td><td>无</td><td>有</td></tr><tr><td>Tree Shaking</td><td>有限</td><td>支持</td></tr><tr><td>性能</td><td>较低</td><td>更高</td></tr><tr><td>模块化</td><td>无</td><td>支持</td></tr><tr><td>类型支持</td><td>无</td><td>支持 TypeScript</td></tr></tbody></table><hr><h3 id="vue-的组件通信方式有哪些及原理" tabindex="-1">Vue 的组件通信方式有哪些及原理 <a class="header-anchor" href="#vue-的组件通信方式有哪些及原理" aria-label="Permalink to &quot;Vue 的组件通信方式有哪些及原理&quot;">​</a></h3><ol><li><strong>props / $emit</strong>：父传子、子传父；</li><li><strong>$root / $parent / $children</strong>：跨级通信；</li><li><strong>EventBus</strong>：非父子组件通信；</li><li><strong>Vuex / Pinia</strong>：全局状态管理；</li><li><strong>provide / inject</strong>：跨层级通信；</li><li><strong>$attrs / $listeners</strong>：传递非 props 属性和事件。</li></ol><hr><h3 id="vue-的路由实现-hash-路由和-history-路由实现原理" tabindex="-1">Vue 的路由实现，hash 路由和 history 路由实现原理 <a class="header-anchor" href="#vue-的路由实现-hash-路由和-history-路由实现原理" aria-label="Permalink to &quot;Vue 的路由实现，hash 路由和 history 路由实现原理&quot;">​</a></h3><ul><li><strong>Hash 路由</strong>：通过 URL 的 <code>#</code> 后面的字符变化实现路由，不触发页面刷新。</li><li><strong>History 路由</strong>：使用 HTML5 的 <code>pushState</code> 和 <code>replaceState</code> 方法，URL 更美观，但需要服务器配置支持。</li></ul><h3 id="keep-alive的实现原理和常用属性" tabindex="-1">keep-alive的实现原理和常用属性 <a class="header-anchor" href="#keep-alive的实现原理和常用属性" aria-label="Permalink to &quot;keep-alive的实现原理和常用属性&quot;">​</a></h3><p><code>&lt;keep-alive&gt;</code> 是 Vue.js 中的一个抽象组件，它用于缓存动态组件实例，从而避免重复渲染和销毁过程，提高用户体验和性能。下面是 <code>&lt;keep-alive&gt;</code> 的一些常用属性及其简要说明：</p><h4 id="常用属性" tabindex="-1">常用属性 <a class="header-anchor" href="#常用属性" aria-label="Permalink to &quot;常用属性&quot;">​</a></h4><ol><li><strong>include</strong>：字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li><strong>exclude</strong>：字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li><strong>max</strong>：数字。定义缓存组中可以保存的最大组件实例数量。</li></ol><p>示例：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exclude</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;c&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;component :is=&quot;currentView&quot;&gt;&lt;/component&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>在这个例子中，仅当 <code>currentView</code> 是组件 <code>a</code> 或 <code>b</code> 时，它们才会被缓存，并且缓存的组件总数不会超过 10 个。</p><h4 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h4><p><code>&lt;keep-alive&gt;</code> 组件的工作原理主要依赖于 Vue 的生命周期钩子以及内部的状态管理机制。以下是其大致工作流程：</p><ol><li><p>当一个组件被包裹在 <code>&lt;keep-alive&gt;</code> 标签内并且开始渲染时，Vue 会检查该组件是否符合 <code>include</code> 和 <code>exclude</code> 规则（如果设置了的话）。符合条件的组件将进入缓存逻辑处理。</p></li><li><p>如果组件已经被缓存过，则 <code>&lt;keep-alive&gt;</code> 不会重新创建一个新的实例，而是直接从缓存中取出并激活这个组件实例。这通过调用组件的 <code>deactivated</code> 生命周期钩子来暂停组件，而再次进入可视状态时调用 <code>activated</code> 钩子来恢复组件。</p></li><li><p>对于新的组件或者不在缓存中的组件，Vue 将正常地挂载这些组件。一旦这些组件离开可视区域，它们的状态（包括 DOM 结构、组件实例等）会被存储在一个 LRU (Least Recently Used) 缓存中。</p></li><li><p>如果设置了 <code>max</code> 属性，当达到最大缓存限制时，最近最少使用的组件实例将会被移除以腾出空间给新的组件实例。</p></li></ol><p>通过这种方式，<code>&lt;keep-alive&gt;</code> 能够有效地管理组件的状态和生命周期，提升应用性能，特别是在需要频繁切换显示不同视图的情况下非常有用。</p><h3 id="vue-的-computed-的实现原理" tabindex="-1">Vue 的 computed 的实现原理 <a class="header-anchor" href="#vue-的-computed-的实现原理" aria-label="Permalink to &quot;Vue 的 computed 的实现原理&quot;">​</a></h3><p>Vue 的 <code>computed</code> 属性实现的核心在于依赖追踪和响应式系统。简要来说，其实现原理包括以下几个关键点：</p><ul><li><ol><li><strong>依赖收集</strong>：当一个计算属性（computed property）被访问时，Vue 会自动追踪在这个过程中哪些响应式数据（reactive data）被访问了。这是通过 Vue 的响应式系统来完成的，该系统会在读取响应式数据时进行依赖收集。</li></ol></li><li><ol start="2"><li><strong>缓存机制</strong>：计算属性的结果会被缓存起来，并且只有在其依赖的数据发生变化时才会重新计算。这意味着如果相关依赖未发生改变，多次访问同一个计算属性将会立即返回缓存的结果，而不会重复执行计算逻辑。</li></ol></li><li><ol start="3"><li><strong>响应更新</strong>：一旦某个计算属性所依赖的数据发生了变化，Vue 就会知道需要重新计算这个计算属性的值，并更新相应的视图。这种更新是自动的，开发者不需要手动干预。</li></ol></li><li><ol start="4"><li><strong>惰性求值</strong>：计算属性采用惰性求值策略，即仅在访问计算属性时才执行计算逻辑，而不是在定义时就立即执行。这样可以避免不必要的计算，提高性能。</li></ol></li></ul><p>综上所述，Vue 的 <code>computed</code> 利用了依赖追踪、缓存机制以及响应式更新等特性，使得它能够高效地管理复杂状态逻辑，同时简化了代码的编写和维护工作。</p><h3 id="vue3性能提升的地方" tabindex="-1">vue3性能提升的地方 <a class="header-anchor" href="#vue3性能提升的地方" aria-label="Permalink to &quot;vue3性能提升的地方&quot;">​</a></h3><p>Vue 3 在多个方面实现了显著的性能提升，这些改进不仅提高了框架本身的效率，也为开发者提供了更多的优化手段。以下是</p><p><strong>Vue 3 性能提升的主要点：</strong></p><ul><li><ol><li><strong>响应式系统升级</strong>： Vue 3 使用了 ES6 的 <code>Proxy</code> 对象来实现响应式数据绑定，取代了 Vue 2 中使用的 <code>Object.defineProperty</code> 方法。<code>Proxy</code> 能够拦截对对象的所有基本操作（如属性访问、赋值等），并且能够监听到新增和删除的属性以及数组的变化 。这使得 Vue 3 的响应式系统更加灵活和高效。</li></ol></li><li><ol start="2"><li><strong>编译时优化</strong>： Vue 3 的编译器能够在编译阶段将模板中的静态节点与动态节点分离，并通过 Patch Flag 标识哪些部分是动态的，从而在渲染时只更新有变动的部分 。这种优化减少了不必要的 DOM 操作，提升了渲染速度。</li></ol></li><li><ol start="3"><li><strong>Tree Shaking 支持</strong>： Vue 3 采用了模块化架构，各个功能都是按需引入的，支持现代构建工具（如 Vite、Rollup、Webpack）进行 Tree Shaking，即未使用的代码不会被打包进最终产物中，从而减小了打包体积并加快了加载速度 。</li></ol></li><li><ol start="4"><li><strong>虚拟 DOM 重写</strong>： Vue 3 对其虚拟 DOM 算法进行了重写，使其更加轻量和高效。新的算法包括 block tree 结构，它有助于减少需要创建的虚拟节点数量，降低虚拟 DOM diff 的压力 。</li></ol></li><li><ol start="5"><li><strong>更好的 TypeScript 支持</strong>： Vue 3 是用 TypeScript 重写的，这不仅提升了开发体验，也间接地增强了项目的可维护性和运行时的安全性 。</li></ol></li><li><ol start="6"><li><strong>组件初始化性能</strong>： Vue 3 在组件实例初始化时做了优化，使用扁平化的结构减少了依赖追踪对象的创建开销。此外，<code>setup()</code> 函数替代了传统的 <code>data</code>、<code>methods</code>、<code>computed</code> 等选项，在组件创建过程中可以更快地构建状态 。</li></ol></li><li><ol start="7"><li><strong>新特性带来的性能优势</strong>： 新增的 <code>Fragment</code>、<code>Teleport</code> 和 <code>Suspense</code> 特性为 Vue 应用提供了更高的灵活性和性能。例如，<code>Suspense</code> 可以让异步组件加载得更友好，避免阻塞主界面 。</li></ol></li><li><ol start="8"><li><strong>服务端渲染 (SSR) 改进</strong>： SSR 在 Vue 3 中得到了重构，变得更轻量且具备更好的并发能力，同时首屏渲染速度更快 。</li></ol></li><li><ol start="9"><li><strong>懒加载和按需加载</strong>： Vue 3 提供了组件懒加载的功能，可以通过 <code>defineAsyncComponent</code> 实现按需加载，减少初始加载资源消耗，提高首屏渲染速度 。</li></ol></li><li><ol start="10"><li><strong>缓存计算属性和方法</strong>： 对于开销较大的计算属性或方法，可以使用缓存来避免重复计算，进一步提升性能 。</li></ol></li></ul><h3 id="vue-3-组件通信方式及其基本原理" tabindex="-1">Vue 3 组件通信方式及其基本原理 <a class="header-anchor" href="#vue-3-组件通信方式及其基本原理" aria-label="Permalink to &quot;Vue 3 组件通信方式及其基本原理&quot;">​</a></h3><h4 id="父子组件通信" tabindex="-1">父子组件通信 <a class="header-anchor" href="#父子组件通信" aria-label="Permalink to &quot;父子组件通信&quot;">​</a></h4><ul><li>Props 和 Events <ul><li><code>Props</code>：父组件可以通过属性绑定的方式将数据传递给子组件。子组件使用 <code>defineProps</code> 来接收父组件传来的数据</li><li><code>Events</code>：子组件可以通过触发自定义事件来通知父组件状态发生了变化，并且可以携带参数给父组件</li></ul></li><li><code>v-model</code> 双向绑定 <ul><li><code>v-model</code> 是一种简化的语法糖，用于实现父组件和子组件之间的双向数据绑定。它实际上是 <code>:modelValue</code> 和 <code>@update:modelValue</code> 的缩写形式</li></ul></li></ul><h4 id="跨层级组件通信" tabindex="-1">跨层级组件通信 <a class="header-anchor" href="#跨层级组件通信" aria-label="Permalink to &quot;跨层级组件通信&quot;">​</a></h4><ul><li>Provide / Inject <ul><li>Event Bus（mitt库） <ul><li>在 Vue 3 中，由于 $root 和 $event 已被移除，通常会使用第三方库如 <code>mitt</code> 创建一个轻量级的事件总线来实现兄弟组件间的通信</li></ul></li><li>共享父组件状态 <ul><li>当两个或更多的兄弟组件需要共享状态时，可以通过共同的父组件作为中介进行状态管理</li></ul></li></ul></li></ul><h4 id="高阶方案" tabindex="-1">高阶方案 <a class="header-anchor" href="#高阶方案" aria-label="Permalink to &quot;高阶方案&quot;">​</a></h4><ul><li>插槽（Slots） <ul><li>插槽提供了一种内容分发的API，允许父组件向子组件传递模板片段</li></ul></li><li>attrs和attrs和listeners（在Vue 3中已合并为 $attrs） <ul><li><code>$attrs</code>包含了所有未被声明为 props 的属性，可以用来透传到子组件</li></ul></li><li>Ref + DefineExpose <ul><li>父组件可以通过 ref 直接访问子组件实例或DOM元素，并调用子组件的方法</li></ul></li><li>Vuex 或 Pinia <ul><li>对于更复杂的状态管理需求，推荐使用 Vuex 或者 Pinia 这样的状态管理库来集中管理和维护应用的状态</li></ul></li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>每种通信方式都有其适用场景，选择哪种方式取决于具体的业务需求和组件结构。例如，在父子组件之间，通常首选 Props 和 Events；对于跨层级通信，Provide / Inject 更加合适；而对于非父子关系的组件间通信，则可能需要用到 Event Bus 或者 Vuex / Pinia。</p><h1 id="vue-组件通信方式" tabindex="-1">Vue 组件通信方式 <a class="header-anchor" href="#vue-组件通信方式" aria-label="Permalink to &quot;Vue 组件通信方式&quot;">​</a></h1><h3 id="_1-父子组件通信" tabindex="-1">1. 父子组件通信 <a class="header-anchor" href="#_1-父子组件通信" aria-label="Permalink to &quot;1. 父子组件通信&quot;">​</a></h3><ul><li><p><strong>Props + Events</strong></p><ul><li>父 → 子：通过 <code>props</code> 传递数据</li><li>子 → 父：通过 <code>$emit</code> 触发事件</li><li>原则：遵循单向数据流</li></ul></li><li><p><strong>v-model</strong></p><ul><li>语法糖：<code>modelValue</code> prop + <code>update:modelValue</code> 事件</li><li>Vue 3 支持多个 v-model</li></ul></li><li><p><strong>Ref</strong></p><ul><li>父组件通过 <code>ref</code> 访问子组件实例方法/数据</li></ul></li></ul><h3 id="_2-跨层级通信" tabindex="-1">2. 跨层级通信 <a class="header-anchor" href="#_2-跨层级通信" aria-label="Permalink to &quot;2. 跨层级通信&quot;">​</a></h3><ul><li><p><strong>Provide/Inject</strong></p><ul><li>祖先 → 后代：<code>provide</code> 提供数据，<code>inject</code> 注入</li><li>Vue 3 需手动保持响应式（提供 <code>ref</code>/<code>reactive</code>）</li></ul></li><li><p><strong>事件总线</strong></p><ul><li>Vue 2: 新建 Vue 实例作为 EventBus</li><li>Vue 3: 推荐使用 <a href="https://github.com/developit/mitt" target="_blank" rel="noreferrer">mitt</a> 库</li></ul></li></ul><h3 id="_3-全局状态管理" tabindex="-1">3. 全局状态管理 <a class="header-anchor" href="#_3-全局状态管理" aria-label="Permalink to &quot;3. 全局状态管理&quot;">​</a></h3><ul><li><p><strong>Pinia</strong> (推荐)</p><ul><li>Vue 3 官方推荐的状态管理库</li><li>支持 TypeScript 和 Composition API</li></ul></li><li><p><strong>Vuex</strong></p><ul><li>Vue 2 的标准方案</li><li>Vue 3 仍兼容但不再推荐</li></ul></li></ul><h3 id="_4-特殊场景方案" tabindex="-1">4. 特殊场景方案 <a class="header-anchor" href="#_4-特殊场景方案" aria-label="Permalink to &quot;4. 特殊场景方案&quot;">​</a></h3><ul><li><p><strong>共享父组件状态</strong></p><ul><li>通过 <code>$parent</code> 访问（不推荐，破坏封装性）</li><li>更好的方案：提升状态到父组件 + props 传递</li></ul></li><li><p><strong>本地存储通信</strong></p><ul><li>通过 <code>localStorage</code> + <code>storage</code> 事件实现跨标签页通信</li></ul></li></ul></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><!----><div class="last-updated" data-v-e257564d><p class="VPLastUpdated" data-v-e257564d data-v-e98dd255>最后更新: <time datetime="2025-07-13T10:44:31.000Z" data-v-e98dd255></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><!----></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/rookie-fly-blog/Interview/old/pages/page1.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>下一篇</span><span class="title" data-v-e257564d>浏览器输入URL到渲染过程</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-5d98c3a5 data-v-e315a0ad><div class="container" data-v-e315a0ad><!----><p class="copyright" data-v-e315a0ad>Copyright © 2025-rookie</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"about_page.md\":\"CMjBbmSr\",\"examples_button.md\":\"Bn2_i_nT\",\"frontend_library.md\":\"Cd_O1wgZ\",\"frontend_plugin.md\":\"ByupaqyS\",\"guide_start.md\":\"CWvJNtuP\",\"index.md\":\"XdVshTWc\",\"interview_css_page.md\":\"B-dn1gJa\",\"interview_css_pages_page1.md\":\"c-gN07Z8\",\"interview_h5_page.md\":\"D68Nz7p-\",\"interview_html_page.md\":\"CwtksPjT\",\"interview_index.md\":\"DKT10QDu\",\"interview_js_page.md\":\"CQdVKZk-\",\"interview_js_pages_page1.md\":\"dVhpqgCc\",\"interview_js_pages_page10.md\":\"B2Xl1tbV\",\"interview_js_pages_page11.md\":\"CIQDjNkG\",\"interview_js_pages_page2.md\":\"C3qdwZPn\",\"interview_js_pages_page3.md\":\"DR7HZJt8\",\"interview_js_pages_page4.md\":\"CsIRf4bo\",\"interview_js_pages_page5.md\":\"BNzLzCec\",\"interview_js_pages_page6.md\":\"BHGfhatt\",\"interview_js_pages_page7.md\":\"CAlMDSHR\",\"interview_js_pages_page8.md\":\"CmoC-I4l\",\"interview_js_pages_page9.md\":\"D3JXZEX4\",\"interview_old_page.md\":\"DRwqL1py\",\"interview_old_pages_page1.md\":\"pRUysvM8\",\"interview_old_pages_page2.md\":\"BiBdRzrW\",\"interview_old_pages_page3.md\":\"DrvZtRks\",\"interview_old_pages_page4.md\":\"BE4SXAFA\",\"interview_old_pages_page5.md\":\"ymZyOO8B\",\"interview_old_pages_page6.md\":\"DBUDM73N\",\"interview_old_pages_page7.md\":\"CvJcm6fk\",\"interview_pc_page.md\":\"XlmwteLu\",\"interview_pc_pages_page1.md\":\"OCnRmHgU\",\"interview_react_page.md\":\"sPflvqWp\",\"interview_vue_page.md\":\"CWJJreyp\",\"interview_vue_pages_page1.md\":\"EBaOY0AF\",\"interview_vue_pages_page10.md\":\"C2_arYEm\",\"interview_vue_pages_page11.md\":\"BDKOcJs3\",\"interview_vue_pages_page12.md\":\"CUvtUkxY\",\"interview_vue_pages_page13.md\":\"B5bC25Te\",\"interview_vue_pages_page14.md\":\"DosVM6QG\",\"interview_vue_pages_page15.md\":\"OYiEH3R5\",\"interview_vue_pages_page16.md\":\"Y2uWHG8d\",\"interview_vue_pages_page17.md\":\"DufsFrZE\",\"interview_vue_pages_page18.md\":\"D9ss_6cX\",\"interview_vue_pages_page19.md\":\"CWy0SBjB\",\"interview_vue_pages_page2.md\":\"C1ZO0wLn\",\"interview_vue_pages_page20.md\":\"C2kDU0AC\",\"interview_vue_pages_page21.md\":\"CMS9ojif\",\"interview_vue_pages_page22.md\":\"BKBpCGKH\",\"interview_vue_pages_page23.md\":\"D8qPmuwk\",\"interview_vue_pages_page24.md\":\"yhSGDmwa\",\"interview_vue_pages_page25.md\":\"9X49533q\",\"interview_vue_pages_page3.md\":\"B8mFRNm3\",\"interview_vue_pages_page4.md\":\"CJUCRfPJ\",\"interview_vue_pages_page5.md\":\"Bn0vsBeX\",\"interview_vue_pages_page6.md\":\"u6UJM6nA\",\"interview_vue_pages_page7.md\":\"DuIbYgMj\",\"interview_vue_pages_page8.md\":\"vL9xJA6N\",\"interview_vue_pages_page9.md\":\"RUvS3Or4\",\"learn_chinese_skill.md\":\"Be8fWrjP\",\"learn_math_skill.md\":\"BDyDok41\",\"learning_browsernetwork_modules_page1.md\":\"CTxxk-g3\",\"learning_browsernetwork_modules_page10.md\":\"CvLRW8mp\",\"learning_browsernetwork_modules_page11.md\":\"B32r__I1\",\"learning_browsernetwork_modules_page2.md\":\"BkeB4iSJ\",\"learning_browsernetwork_modules_page3.md\":\"CdSMssCZ\",\"learning_browsernetwork_modules_page4.md\":\"BIQv1x4j\",\"learning_browsernetwork_modules_page5.md\":\"BuEDwS6c\",\"learning_browsernetwork_modules_page6.md\":\"D1ejB6Xe\",\"learning_browsernetwork_modules_page7.md\":\"DHYY72Hs\",\"learning_browsernetwork_modules_page8.md\":\"CaMAVka6\",\"learning_browsernetwork_modules_page9.md\":\"B8Erdwy1\",\"learning_browsernetwork_page.md\":\"Cmcwl2Fy\",\"learning_core_modules_page1.md\":\"D5IDl2BU\",\"learning_core_modules_page10.md\":\"H2_xV9oV\",\"learning_core_modules_page11.md\":\"Bf9sONFw\",\"learning_core_modules_page2.md\":\"CoSjRC8g\",\"learning_core_modules_page3.md\":\"DGZMWinV\",\"learning_core_modules_page4.md\":\"DwDp4nqO\",\"learning_core_modules_page5.md\":\"BYJsx3Ed\",\"learning_core_modules_page6.md\":\"Dr82QhuS\",\"learning_core_modules_page7.md\":\"Cy1YKg8y\",\"learning_core_modules_page8.md\":\"DrIU5Zha\",\"learning_core_modules_page9.md\":\"CoFnRKEP\",\"learning_core_page.md\":\"DXS9ZBXJ\",\"learning_engineering_modules_page1.md\":\"BHZK-k7d\",\"learning_engineering_modules_page10.md\":\"BzOZAwVK\",\"learning_engineering_modules_page11.md\":\"rTkuG3B-\",\"learning_engineering_modules_page2.md\":\"BMIctFY_\",\"learning_engineering_modules_page3.md\":\"z6cl2kcf\",\"learning_engineering_modules_page4.md\":\"DGQLaTNW\",\"learning_engineering_modules_page5.md\":\"CC_ss6KX\",\"learning_engineering_modules_page6.md\":\"Bf3mlG48\",\"learning_engineering_modules_page7.md\":\"C0eJbnqu\",\"learning_engineering_modules_page8.md\":\"CCc3z0TF\",\"learning_engineering_modules_page9.md\":\"B9tPU31C\",\"learning_engineering_page.md\":\"BHPAunSn\",\"learning_layoutstyle_modules_page1.md\":\"8I61RgO6\",\"learning_layoutstyle_modules_page10.md\":\"CIobOiow\",\"learning_layoutstyle_modules_page11.md\":\"DOx7BN8m\",\"learning_layoutstyle_modules_page2.md\":\"B2_yAok7\",\"learning_layoutstyle_modules_page3.md\":\"BQtjVMdj\",\"learning_layoutstyle_modules_page4.md\":\"CQAzVnHQ\",\"learning_layoutstyle_modules_page5.md\":\"DCQBdrUI\",\"learning_layoutstyle_modules_page6.md\":\"CPNKLLYe\",\"learning_layoutstyle_modules_page7.md\":\"CvmNyJW2\",\"learning_layoutstyle_modules_page8.md\":\"BfXRYzCK\",\"learning_layoutstyle_modules_page9.md\":\"Csciua0w\",\"learning_layoutstyle_page.md\":\"B8XP_66u\",\"learning_optimization_modules_page1.md\":\"BEKC5-Wv\",\"learning_optimization_modules_page10.md\":\"xcsjzqvt\",\"learning_optimization_modules_page11.md\":\"DcytKTAN\",\"learning_optimization_modules_page2.md\":\"QReMhO4I\",\"learning_optimization_modules_page3.md\":\"lqdG6eZ8\",\"learning_optimization_modules_page4.md\":\"BzyZkEOV\",\"learning_optimization_modules_page5.md\":\"CSzsPdP0\",\"learning_optimization_modules_page6.md\":\"CmOTKQ2O\",\"learning_optimization_modules_page7.md\":\"BUymNKLz\",\"learning_optimization_modules_page8.md\":\"4MA-D1ZP\",\"learning_optimization_modules_page9.md\":\"yJngcYy5\",\"learning_optimization_page.md\":\"B4w8PfcS\",\"learning_other_modules_page1.md\":\"ih8drhHj\",\"learning_other_page.md\":\"BNaXWEKy\",\"learning_vue_modules_page1.md\":\"1gctmXbs\",\"learning_vue_modules_page10.md\":\"CbtY9OV7\",\"learning_vue_modules_page11.md\":\"BhZ4z67v\",\"learning_vue_modules_page12.md\":\"CKcVVvUj\",\"learning_vue_modules_page13.md\":\"Buh7pzp-\",\"learning_vue_modules_page14.md\":\"aeCFovpt\",\"learning_vue_modules_page15.md\":\"CTSH-j3b\",\"learning_vue_modules_page2.md\":\"Czk3n6CT\",\"learning_vue_modules_page3.md\":\"C3NumnXp\",\"learning_vue_modules_page4.md\":\"D-99hs4s\",\"learning_vue_modules_page5.md\":\"CHTbM0Q7\",\"learning_vue_modules_page6.md\":\"HOgkjid4\",\"learning_vue_modules_page7.md\":\"DGF3fJXU\",\"learning_vue_modules_page8.md\":\"Cy7JyUtS\",\"learning_vue_modules_page9.md\":\"BF-WYefq\",\"learning_vue_page.md\":\"BYc3NLKC\",\"note_css_css.md\":\"BhAXVX2u\",\"note_electron_page1.md\":\"C7-vKILJ\",\"note_react.md\":\"CQyHCxgs\",\"note_vitepress_page1.md\":\"Biiu4_Bo\",\"note_vitepress_page2.md\":\"D-C-JPYX\",\"note_vitepress_page3.md\":\"D4-Og9cX\",\"note_vitepress_page4.md\":\"Du8sl5J2\",\"note_vitepress_page5.md\":\"UTf7a1wK\",\"note_vitepress_page6.md\":\"BNiflsNK\",\"note_vitepress_page7.md\":\"BAgnDIMV\",\"note_vitepress_page8.md\":\"CB78Kv9R\",\"note_vue.md\":\"BUDaKK-s\",\"novel_overachiever_page.md\":\"CgH1e_bq\",\"novel_overachiever_pages_page1.md\":\"CKzplxOL\",\"novel_overachiever_pages_page10.md\":\"BW6qUtOR\",\"novel_overachiever_pages_page11.md\":\"Cd3_mqSd\",\"novel_overachiever_pages_page12.md\":\"CcGEMMxM\",\"novel_overachiever_pages_page13.md\":\"DSZHhHSO\",\"novel_overachiever_pages_page14.md\":\"BFhm0XmP\",\"novel_overachiever_pages_page15.md\":\"BeLkGOTw\",\"novel_overachiever_pages_page16.md\":\"dGA4VLih\",\"novel_overachiever_pages_page17.md\":\"DqZyIIfE\",\"novel_overachiever_pages_page18.md\":\"orVuDcyh\",\"novel_overachiever_pages_page19.md\":\"ihBbtpu3\",\"novel_overachiever_pages_page2.md\":\"BkERmwh5\",\"novel_overachiever_pages_page20.md\":\"DkDZ-Iyf\",\"novel_overachiever_pages_page3.md\":\"DutLZoa-\",\"novel_overachiever_pages_page4.md\":\"DGpxpWmj\",\"novel_overachiever_pages_page5.md\":\"B0EX6f-e\",\"novel_overachiever_pages_page6.md\":\"BGKLT3xy\",\"novel_overachiever_pages_page7.md\":\"DyQuMVGg\",\"novel_overachiever_pages_page8.md\":\"CE8Rsuwe\",\"novel_overachiever_pages_page9.md\":\"yBpTh-gt\",\"opensource_open-source.md\":\"BhsuX0-Z\",\"site_framework.md\":\"BhtPOqrV\",\"site_html-css.md\":\"CMskE6kb\",\"site_page.md\":\"w5PG6WIv\",\"uniapp_page.md\":\"BCi9sWQ8\",\"vite_page.md\":\"DcEO9ZkE\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Luck Blog\",\"description\":\"关注web前端开发为主的博客网站和前端网址大全\",\"base\":\"/rookie-fly-blog/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/logo.png\",\"siteTitle\":false,\"nav\":[{\"text\":\"首页\",\"link\":\"/\"},{\"text\":\"前端导航\",\"link\":\"/guide/start\"},{\"text\":\"我的开源\",\"link\":\"/openSource/open-source\"},{\"text\":\"故知新\",\"items\":[{\"text\":\"浏览器与网络\",\"link\":\"/learning/browserNetwork/page\"},{\"text\":\"前端性能优化\",\"link\":\"/learning/optimization/page\"},{\"text\":\"JavaScript 核心\",\"link\":\"/learning/core/page\"},{\"text\":\"Vue 框架\",\"link\":\"/learning/vue/page\"},{\"text\":\"样式与布局\",\"link\":\"/learning/layoutStyle/page\"},{\"text\":\"构建工具及工程化\",\"link\":\"/learning/engineering/page\"},{\"text\":\"其它\",\"link\":\"/learning/other/page\"}]},{\"text\":\"小说\",\"items\":[{\"text\":\"卷王仙尊\",\"link\":\"/novel/overachiever/page\"}]}],\"sidebar\":{\"/learn/math/skill\":[{\"text\":\"从零开始用VitePress搭建个人博客的教程笔记\",\"items\":[{\"text\":\"1. VitePress的安装和运行\",\"link\":\"/note/vitePress/page1\"},{\"text\":\"2. VitePress默认首页和头部导航配置\",\"link\":\"/note/vitePress/page2\"},{\"text\":\"3. VitePress默认主题相关细节配置\",\"link\":\"/note/vitePress/page3\"},{\"text\":\"4. 如何自定义首页布局和主题样式修改？\",\"link\":\"/note/vitePress/page4\"},{\"text\":\"5. 第三方组件库的使用-搭建组件库文档？\",\"link\":\"/note/vitePress/page5\"},{\"text\":\"6. 如何用Github Actions自动化部署到Github Pages？\",\"link\":\"/note/vitePress/page6\"},{\"text\":\"7. VitePress如何非自动化部署到Github Pages？\",\"link\":\"/note/vitePress/page7\"},{\"text\":\"8. VitePress部署到Github Pages后发现样式全错乱了怎么办？\",\"link\":\"/note/vitePress/page8\"}]}],\"/Interview/js/page\":[{\"text\":\"javascript\",\"items\":[{\"text\":\"前端内存泄漏\",\"link\":\"/Interview/js/pages/page1\"},{\"text\":\"浏览器输入URL到页面加载过程\",\"link\":\"/Interview/js/pages/page2\"},{\"text\":\"首屏优化如何去做\",\"link\":\"/Interview/js/pages/page3\"},{\"text\":\"缓存\",\"link\":\"/Interview/js/pages/page4\"},{\"text\":\"HTTP1 和 HTTP2 的区别\",\"link\":\"/Interview/js/pages/page5\"},{\"text\":\"null和undefined的区别\",\"link\":\"/Interview/js/pages/page6\"},{\"text\":\"事件轮询（Event Loop）\",\"link\":\"/Interview/js/pages/page7\"},{\"text\":\"回流和重绘\",\"link\":\"/Interview/js/pages/page8\"},{\"text\":\"js宏任务和微任务\",\"link\":\"/Interview/js/pages/page9\"},{\"text\":\"延迟加载js的方法\",\"link\":\"/Interview/js/pages/page10\"},{\"text\":\"事件轮询（Event Loop）\",\"link\":\"/Interview/js/pages/page11\"}]}],\"/Interview/vue/page\":[{\"text\":\"vue\",\"items\":[{\"text\":\"1.vue的生命周期有哪些及每个生命周期做了什么\",\"link\":\"/Interview/vue/pages/page1\"},{\"text\":\"2.vue响应式原理是什么？vue3的响应式有何不同\",\"link\":\"/Interview/vue/pages/page2\"},{\"text\":\"3.vue3和vue2的区别\",\"link\":\"/Interview/vue/pages/page3\"},{\"text\":\"4.谈一谈对 MVVM 的理解？\",\"link\":\"/Interview/vue/pages/page4\"},{\"text\":\"5.在 Vue2.x 中如何检测数组的变化？\",\"link\":\"/Interview/vue/pages/page5\"},{\"text\":\"6.v-model 双向绑定的原理是什么？\",\"link\":\"/Interview/vue/pages/page6\"},{\"text\":\"7.vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下？\",\"link\":\"/Interview/vue/pages/page7\"},{\"text\":\"8.vue组件通信方式有哪些及原理\",\"link\":\"/Interview/vue/pages/page8\"},{\"text\":\"9.  Vue的路由实现, hash路由和history路由实现原理说一下\",\"link\":\"/Interview/vue/pages/page9\"},{\"text\":\"10. 说一下 v-if 与 v-show 的区别\",\"link\":\"/Interview/vue/pages/page10\"},{\"text\":\"11. keep-alive的常用属性有哪些及实现原理\",\"link\":\"/Interview/vue/pages/page11\"},{\"text\":\"12. nextTick 的作用是什么？他的实现原理是什么？\",\"link\":\"/Interview/vue/pages/page12\"},{\"text\":\"13.说一下 Vue SSR 的实现原理\",\"link\":\"/Interview/vue/pages/page13\"},{\"text\":\"14.Vue 组件的 data 为什么必须是函数\",\"link\":\"/Interview/vue/pages/page14\"},{\"text\":\"15.说一下 Vue 的 computed 的实现原理\",\"link\":\"/Interview/vue/pages/page15\"},{\"text\":\"16.说一下 Vue complier 的实现原理是什么样的？\",\"link\":\"/Interview/vue/pages/page16\"},{\"text\":\"17.Vue 与  React 的区别是什么？\",\"link\":\"/Interview/vue/pages/page17\"},{\"text\":\"18.说一下 watch 与 computed 的区别是什么？以及他们的使用场景分别是什么？\",\"link\":\"/Interview/vue/pages/page18\"},{\"text\":\"19.说一下你知道的 vue 修饰符都有哪些？\",\"link\":\"/Interview/vue/pages/page19\"},{\"text\":\"20.如何实现 vue 项目中的性能优化？\",\"link\":\"/Interview/vue/pages/page20\"},{\"text\":\"21.vue 中的 spa 应用如何优化首屏加载速度?\",\"link\":\"/Interview/vue/pages/page21\"},{\"text\":\"22.Vue 中的 Key 的作用是什么？\",\"link\":\"/Interview/vue/pages/page22\"},{\"text\":\"23.组件中写 name 选项有哪些好处\",\"link\":\"/Interview/vue/pages/page23\"},{\"text\":\"24.说一下 ref 的作用是什么？\",\"link\":\"/Interview/vue/pages/page24\"},{\"text\":\"25.你的接口请求一般放在哪个生命周期中？为什么要这样做？\",\"link\":\"/Interview/vue/pages/page25\"}]}],\"/Interview/old/page\":[{\"text\":\"温故\",\"items\":[{\"text\":\"浏览器输入URL到渲染过程\",\"link\":\"/Interview/old/pages/page1\"},{\"text\":\"前端性能优化\",\"link\":\"/Interview/old/pages/page2\"},{\"text\":\"前端首屏优化\",\"link\":\"/Interview/old/pages/page3\"},{\"text\":\"前端内存泄漏\",\"link\":\"/Interview/old/pages/page4\"},{\"text\":\"前端缓存\",\"link\":\"/Interview/old/pages/page5\"},{\"text\":\"前端事件轮询\",\"link\":\"/Interview/old/pages/page6\"},{\"text\":\"ES6新特性\",\"link\":\"/Interview/old/pages/page7\"}]}],\"/novel/overachiever/page\":[{\"text\":\"卷一：凡界卷\",\"items\":[{\"text\":\"第一章：前端工程师被噶了？\",\"link\":\"/novel/overachiever/pages/page1\"},{\"text\":\"第二章：草棚中的异乡人\",\"link\":\"/novel/overachiever/pages/page2\"},{\"text\":\"第三章：卷出炼体经验\",\"link\":\"/novel/overachiever/pages/page3\"},{\"text\":\"第四章：你炼三天？我炼三十天！\",\"link\":\"/novel/overachiever/pages/page4\"},{\"text\":\"第五章：全村被我带卷了\",\"link\":\"/novel/overachiever/pages/page5\"},{\"text\":\"第六章：炼体卷王初显威\",\"link\":\"/novel/overachiever/pages/page6\"},{\"text\":\"第七章：无灵根觉醒！天命被打碎了！\",\"link\":\"/novel/overachiever/pages/page7\"},{\"text\":\"第八章：逆修之道！卷命入识！\",\"link\":\"/novel/overachiever/pages/page8\"},{\"text\":\"第九章：灵山宗震动！系统流天命叛逆者诞生！\",\"link\":\"/novel/overachiever/pages/page9\"},{\"text\":\"第十章：三日死卷！神识技横空出世\",\"link\":\"/novel/overachiever/pages/page10\"},{\"text\":\"第十一章：外门初入，卷王乱风起！\",\"link\":\"/novel/overachiever/pages/page11\"},{\"text\":\"第十二章：副本之门！卷王对卷王！\",\"link\":\"/novel/overachiever/pages/page12\"},{\"text\":\"第十三章：战力榜挑战！天骄对决！\",\"link\":\"/novel/overachiever/pages/page13\"},{\"text\":\"第十四章：识海突破！炼体极限冲破枷锁！\",\"link\":\"/novel/overachiever/pages/page14\"},{\"text\":\"第十五章：灵根者来袭！系统卷修首次对炼气！\",\"link\":\"/novel/overachiever/pages/page15\"},{\"text\":\"第十六章：灵根动摇！宗门危机初现！\",\"link\":\"/novel/overachiever/pages/page16\"},{\"text\":\"第十七章：封顶令下！十日内卷战前十！\",\"link\":\"/novel/overachiever/pages/page17\"},{\"text\":\"第十八章：幻风三式！系统对抗灵根术法！\",\"link\":\"/novel/overachiever/pages/page18\"},{\"text\":\"第十九章：秘境开启，卷进遗迹\",\"link\":\"/novel/overachiever/pages/page19\"},{\"text\":\"第二十章：反派登场，惊觉主角不可卷\",\"link\":\"/novel/overachiever/pages/page20\"},{\"text\":\"第二十一章：杀出凡界第一杀阵\",\"link\":\"/novel/overachiever/pages/page21\"},{\"text\":\"第二十二章：系统升级，卷力+100\",\"link\":\"/novel/overachiever/pages/page22\"},{\"text\":\"第二十三章：破境炼气，踏入灵修路\",\"link\":\"/novel/overachiever/pages/page23\"},{\"text\":\"第二十四章：冰艳告别，留下一缕青丝\",\"link\":\"/novel/overachiever/pages/page24\"},{\"text\":\"第二十五章：我卷出了凡界！\",\"link\":\"/novel/overachiever/pages/page25\"}]},{\"text\":\"第一卷：凡尘加班人，异界修仙王\",\"items\":[{\"text\":\"第一卷：凡尘加班人，异界修仙王\",\"link\":\"/novel/overachiever/pages/page1\"},{\"text\":\"第二章：这世界不对劲\",\"link\":\"/novel/overachiever/pages/page2\"},{\"text\":\"第二章：草地上睁眼，这世界不对劲\",\"link\":\"/novel/overachiever/pages/page2\"}]}],\"/learning/browserNetwork/page\":{\"text\":\"浏览器与网络\",\"items\":[{\"text\":\"浏览器输入URL到渲染过程\",\"link\":\"/learning/browserNetwork/modules/page1\"},{\"text\":\"事件轮询 (Event Loop)\",\"link\":\"/learning/browserNetwork/modules/page2\"},{\"text\":\"跨域及 JSONP\",\"link\":\"/learning/browserNetwork/modules/page3\"},{\"text\":\"HTTP1.1 与 HTTP2 区别\",\"link\":\"/learning/browserNetwork/modules/page4\"},{\"text\":\"OPTIONS 预请求\",\"link\":\"/learning/browserNetwork/modules/page5\"}]},\"/learning/browserNetwork/modules/page1\":{\"text\":\"浏览器与网络\",\"items\":[{\"text\":\"浏览器输入URL到渲染过程\",\"link\":\"/learning/browserNetwork/modules/page1\"},{\"text\":\"事件轮询 (Event Loop)\",\"link\":\"/learning/browserNetwork/modules/page2\"},{\"text\":\"跨域及 JSONP\",\"link\":\"/learning/browserNetwork/modules/page3\"},{\"text\":\"HTTP1.1 与 HTTP2 区别\",\"link\":\"/learning/browserNetwork/modules/page4\"},{\"text\":\"OPTIONS 预请求\",\"link\":\"/learning/browserNetwork/modules/page5\"}]},\"/learning/browserNetwork/modules/page2\":{\"text\":\"浏览器与网络\",\"items\":[{\"text\":\"浏览器输入URL到渲染过程\",\"link\":\"/learning/browserNetwork/modules/page1\"},{\"text\":\"事件轮询 (Event Loop)\",\"link\":\"/learning/browserNetwork/modules/page2\"},{\"text\":\"跨域及 JSONP\",\"link\":\"/learning/browserNetwork/modules/page3\"},{\"text\":\"HTTP1.1 与 HTTP2 区别\",\"link\":\"/learning/browserNetwork/modules/page4\"},{\"text\":\"OPTIONS 预请求\",\"link\":\"/learning/browserNetwork/modules/page5\"}]},\"/learning/browserNetwork/modules/page3\":{\"text\":\"浏览器与网络\",\"items\":[{\"text\":\"浏览器输入URL到渲染过程\",\"link\":\"/learning/browserNetwork/modules/page1\"},{\"text\":\"事件轮询 (Event Loop)\",\"link\":\"/learning/browserNetwork/modules/page2\"},{\"text\":\"跨域及 JSONP\",\"link\":\"/learning/browserNetwork/modules/page3\"},{\"text\":\"HTTP1.1 与 HTTP2 区别\",\"link\":\"/learning/browserNetwork/modules/page4\"},{\"text\":\"OPTIONS 预请求\",\"link\":\"/learning/browserNetwork/modules/page5\"}]},\"/learning/browserNetwork/modules/page4\":{\"text\":\"浏览器与网络\",\"items\":[{\"text\":\"浏览器输入URL到渲染过程\",\"link\":\"/learning/browserNetwork/modules/page1\"},{\"text\":\"事件轮询 (Event Loop)\",\"link\":\"/learning/browserNetwork/modules/page2\"},{\"text\":\"跨域及 JSONP\",\"link\":\"/learning/browserNetwork/modules/page3\"},{\"text\":\"HTTP1.1 与 HTTP2 区别\",\"link\":\"/learning/browserNetwork/modules/page4\"},{\"text\":\"OPTIONS 预请求\",\"link\":\"/learning/browserNetwork/modules/page5\"}]},\"/learning/browserNetwork/modules/page5\":{\"text\":\"浏览器与网络\",\"items\":[{\"text\":\"浏览器输入URL到渲染过程\",\"link\":\"/learning/browserNetwork/modules/page1\"},{\"text\":\"事件轮询 (Event Loop)\",\"link\":\"/learning/browserNetwork/modules/page2\"},{\"text\":\"跨域及 JSONP\",\"link\":\"/learning/browserNetwork/modules/page3\"},{\"text\":\"HTTP1.1 与 HTTP2 区别\",\"link\":\"/learning/browserNetwork/modules/page4\"},{\"text\":\"OPTIONS 预请求\",\"link\":\"/learning/browserNetwork/modules/page5\"}]},\"/learning/optimization/page\":{\"text\":\"前端性能优化\",\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/learning/optimization/modules/page1\"},{\"text\":\"前端首屏优化\",\"link\":\"/learning/optimization/modules/page2\"},{\"text\":\"前端缓存\",\"link\":\"/learning/optimization/modules/page3\"},{\"text\":\"前端内存泄漏\",\"link\":\"/learning/optimization/modules/page4\"}]},\"/learning/optimization/modules/page1\":{\"text\":\"前端性能优化\",\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/learning/optimization/modules/page1\"},{\"text\":\"前端首屏优化\",\"link\":\"/learning/optimization/modules/page2\"},{\"text\":\"前端缓存\",\"link\":\"/learning/optimization/modules/page3\"},{\"text\":\"前端内存泄漏\",\"link\":\"/learning/optimization/modules/page4\"}]},\"/learning/optimization/modules/page2\":{\"text\":\"前端性能优化\",\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/learning/optimization/modules/page1\"},{\"text\":\"前端首屏优化\",\"link\":\"/learning/optimization/modules/page2\"},{\"text\":\"前端缓存\",\"link\":\"/learning/optimization/modules/page3\"},{\"text\":\"前端内存泄漏\",\"link\":\"/learning/optimization/modules/page4\"}]},\"/learning/optimization/modules/page3\":{\"text\":\"前端性能优化\",\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/learning/optimization/modules/page1\"},{\"text\":\"前端首屏优化\",\"link\":\"/learning/optimization/modules/page2\"},{\"text\":\"前端缓存\",\"link\":\"/learning/optimization/modules/page3\"},{\"text\":\"前端内存泄漏\",\"link\":\"/learning/optimization/modules/page4\"}]},\"/learning/optimization/modules/page4\":{\"text\":\"前端性能优化\",\"items\":[{\"text\":\"前端性能优化\",\"link\":\"/learning/optimization/modules/page1\"},{\"text\":\"前端首屏优化\",\"link\":\"/learning/optimization/modules/page2\"},{\"text\":\"前端缓存\",\"link\":\"/learning/optimization/modules/page3\"},{\"text\":\"前端内存泄漏\",\"link\":\"/learning/optimization/modules/page4\"}]},\"/learning/core/page\":{\"text\":\"JavaScript 核心\",\"items\":[{\"text\":\"ES6 新特性\",\"link\":\"/learning/core/modules/page1\"},{\"text\":\"箭头函数 vs 普通函数\",\"link\":\"/learning/core/modules/page2\"},{\"text\":\"原型和原型链\",\"link\":\"/learning/core/modules/page3\"},{\"text\":\"函数柯里化\",\"link\":\"/learning/core/modules/page4\"},{\"text\":\"事件轮询\",\"link\":\"/learning/core/modules/page5\"},{\"text\":\"CommonJS 与 模块化\",\"link\":\"/learning/core/modules/page6\"}]},\"/learning/core/modules/page1\":{\"text\":\"JavaScript 核心\",\"items\":[{\"text\":\"ES6 新特性\",\"link\":\"/learning/core/modules/page1\"},{\"text\":\"箭头函数 vs 普通函数\",\"link\":\"/learning/core/modules/page2\"},{\"text\":\"原型和原型链\",\"link\":\"/learning/core/modules/page3\"},{\"text\":\"函数柯里化\",\"link\":\"/learning/core/modules/page4\"},{\"text\":\"事件轮询\",\"link\":\"/learning/core/modules/page5\"},{\"text\":\"CommonJS 与 模块化\",\"link\":\"/learning/core/modules/page6\"}]},\"/learning/core/modules/page2\":{\"text\":\"JavaScript 核心\",\"items\":[{\"text\":\"ES6 新特性\",\"link\":\"/learning/core/modules/page1\"},{\"text\":\"箭头函数 vs 普通函数\",\"link\":\"/learning/core/modules/page2\"},{\"text\":\"原型和原型链\",\"link\":\"/learning/core/modules/page3\"},{\"text\":\"函数柯里化\",\"link\":\"/learning/core/modules/page4\"},{\"text\":\"事件轮询\",\"link\":\"/learning/core/modules/page5\"},{\"text\":\"CommonJS 与 模块化\",\"link\":\"/learning/core/modules/page6\"}]},\"/learning/core/modules/page3\":{\"text\":\"JavaScript 核心\",\"items\":[{\"text\":\"ES6 新特性\",\"link\":\"/learning/core/modules/page1\"},{\"text\":\"箭头函数 vs 普通函数\",\"link\":\"/learning/core/modules/page2\"},{\"text\":\"原型和原型链\",\"link\":\"/learning/core/modules/page3\"},{\"text\":\"函数柯里化\",\"link\":\"/learning/core/modules/page4\"},{\"text\":\"事件轮询\",\"link\":\"/learning/core/modules/page5\"},{\"text\":\"CommonJS 与 模块化\",\"link\":\"/learning/core/modules/page6\"}]},\"/learning/core/modules/page4\":{\"text\":\"JavaScript 核心\",\"items\":[{\"text\":\"ES6 新特性\",\"link\":\"/learning/core/modules/page1\"},{\"text\":\"箭头函数 vs 普通函数\",\"link\":\"/learning/core/modules/page2\"},{\"text\":\"原型和原型链\",\"link\":\"/learning/core/modules/page3\"},{\"text\":\"函数柯里化\",\"link\":\"/learning/core/modules/page4\"},{\"text\":\"事件轮询\",\"link\":\"/learning/core/modules/page5\"},{\"text\":\"CommonJS 与 模块化\",\"link\":\"/learning/core/modules/page6\"}]},\"/learning/core/modules/page5\":{\"text\":\"JavaScript 核心\",\"items\":[{\"text\":\"ES6 新特性\",\"link\":\"/learning/core/modules/page1\"},{\"text\":\"箭头函数 vs 普通函数\",\"link\":\"/learning/core/modules/page2\"},{\"text\":\"原型和原型链\",\"link\":\"/learning/core/modules/page3\"},{\"text\":\"函数柯里化\",\"link\":\"/learning/core/modules/page4\"},{\"text\":\"事件轮询\",\"link\":\"/learning/core/modules/page5\"},{\"text\":\"CommonJS 与 模块化\",\"link\":\"/learning/core/modules/page6\"}]},\"/learning/core/modules/page6\":{\"text\":\"JavaScript 核心\",\"items\":[{\"text\":\"ES6 新特性\",\"link\":\"/learning/core/modules/page1\"},{\"text\":\"箭头函数 vs 普通函数\",\"link\":\"/learning/core/modules/page2\"},{\"text\":\"原型和原型链\",\"link\":\"/learning/core/modules/page3\"},{\"text\":\"函数柯里化\",\"link\":\"/learning/core/modules/page4\"},{\"text\":\"事件轮询\",\"link\":\"/learning/core/modules/page5\"},{\"text\":\"CommonJS 与 模块化\",\"link\":\"/learning/core/modules/page6\"}]},\"/learning/vue/page\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page1\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page2\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page3\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page4\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page5\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page6\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page7\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page8\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page9\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page10\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page11\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page12\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page13\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page14\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/vue/modules/page15\":{\"text\":\"Vue 框架\",\"items\":[{\"text\":\"Vue 双向绑定原理\",\"link\":\"/learning/vue/modules/page1\"},{\"text\":\"Vue 生命周期详解\",\"link\":\"/learning/vue/modules/page2\"},{\"text\":\"Vue 自定义指令\",\"link\":\"/learning/vue/modules/page3\"},{\"text\":\"Vue 如何优化 SEO\",\"link\":\"/learning/vue/modules/page4\"},{\"text\":\"Vue2 vs Vue3\",\"link\":\"/learning/vue/modules/page5\"},{\"text\":\"Vue3 组件通信与原理\",\"link\":\"/learning/vue/modules/page6\"},{\"text\":\"Vue 路由实现原理\",\"link\":\"/learning/vue/modules/page7\"},{\"text\":\"Vue keep-alive 原理\",\"link\":\"/learning/vue/modules/page8\"},{\"text\":\"Vue computed 原理\",\"link\":\"/learning/vue/modules/page9\"},{\"text\":\"vue3 watch vs watchEffect\",\"link\":\"/learning/vue/modules/page10\"},{\"text\":\"Vue SSR 的实现原理\",\"link\":\"/learning/vue/modules/page11\"},{\"text\":\"vue2和 vuex3渲染器的 diff算法\",\"link\":\"/learning/vue/modules/page12\"},{\"text\":\"Vue nextTick\",\"link\":\"/learning/vue/modules/page13\"},{\"text\":\"Vue complier 的实现原理\",\"link\":\"/learning/vue/modules/page14\"},{\"text\":\"Vue 中的 Key\",\"link\":\"/learning/vue/modules/page15\"}]},\"/learning/layoutStyle/page\":{\"text\":\"样式与布局\",\"items\":[{\"text\":\"Flex\",\"link\":\"/learning/layoutStyle/modules/page1\"},{\"text\":\"BFC\",\"link\":\"/learning/layoutStyle/modules/page2\"}]},\"/learning/layoutStyle/modules/page1\":{\"text\":\"样式与布局\",\"items\":[{\"text\":\"Flex\",\"link\":\"/learning/layoutStyle/modules/page1\"},{\"text\":\"BFC\",\"link\":\"/learning/layoutStyle/modules/page2\"}]},\"/learning/layoutStyle/modules/page2\":{\"text\":\"样式与布局\",\"items\":[{\"text\":\"Flex\",\"link\":\"/learning/layoutStyle/modules/page1\"},{\"text\":\"BFC\",\"link\":\"/learning/layoutStyle/modules/page2\"}]},\"/learning/engineering/page\":{\"text\":\"构建工具及工程化\",\"items\":[{\"text\":\"Webpack 的构建流程\",\"link\":\"/learning/engineering/modules/page1\"},{\"text\":\"vite 的构建流程\",\"link\":\"/learning/engineering/modules/page2\"},{\"text\":\"Webpack vs vite\",\"link\":\"/learning/engineering/modules/page3\"},{\"text\":\"TypeScript\",\"link\":\"/learning/engineering/modules/page4\"},{\"text\":\"Uniapp\",\"link\":\"/learning/engineering/modules/page5\"}]},\"/learning/engineering/modules/page1\":{\"text\":\"构建工具及工程化\",\"items\":[{\"text\":\"Webpack 的构建流程\",\"link\":\"/learning/engineering/modules/page1\"},{\"text\":\"vite 的构建流程\",\"link\":\"/learning/engineering/modules/page2\"},{\"text\":\"Webpack vs vite\",\"link\":\"/learning/engineering/modules/page3\"},{\"text\":\"TypeScript\",\"link\":\"/learning/engineering/modules/page4\"},{\"text\":\"Uniapp\",\"link\":\"/learning/engineering/modules/page5\"}]},\"/learning/engineering/modules/page2\":{\"text\":\"构建工具及工程化\",\"items\":[{\"text\":\"Webpack 的构建流程\",\"link\":\"/learning/engineering/modules/page1\"},{\"text\":\"vite 的构建流程\",\"link\":\"/learning/engineering/modules/page2\"},{\"text\":\"Webpack vs vite\",\"link\":\"/learning/engineering/modules/page3\"},{\"text\":\"TypeScript\",\"link\":\"/learning/engineering/modules/page4\"},{\"text\":\"Uniapp\",\"link\":\"/learning/engineering/modules/page5\"}]},\"/learning/engineering/modules/page3\":{\"text\":\"构建工具及工程化\",\"items\":[{\"text\":\"Webpack 的构建流程\",\"link\":\"/learning/engineering/modules/page1\"},{\"text\":\"vite 的构建流程\",\"link\":\"/learning/engineering/modules/page2\"},{\"text\":\"Webpack vs vite\",\"link\":\"/learning/engineering/modules/page3\"},{\"text\":\"TypeScript\",\"link\":\"/learning/engineering/modules/page4\"},{\"text\":\"Uniapp\",\"link\":\"/learning/engineering/modules/page5\"}]},\"/learning/engineering/modules/page4\":{\"text\":\"构建工具及工程化\",\"items\":[{\"text\":\"Webpack 的构建流程\",\"link\":\"/learning/engineering/modules/page1\"},{\"text\":\"vite 的构建流程\",\"link\":\"/learning/engineering/modules/page2\"},{\"text\":\"Webpack vs vite\",\"link\":\"/learning/engineering/modules/page3\"},{\"text\":\"TypeScript\",\"link\":\"/learning/engineering/modules/page4\"},{\"text\":\"Uniapp\",\"link\":\"/learning/engineering/modules/page5\"}]},\"/learning/engineering/modules/page5\":{\"text\":\"构建工具及工程化\",\"items\":[{\"text\":\"Webpack 的构建流程\",\"link\":\"/learning/engineering/modules/page1\"},{\"text\":\"vite 的构建流程\",\"link\":\"/learning/engineering/modules/page2\"},{\"text\":\"Webpack vs vite\",\"link\":\"/learning/engineering/modules/page3\"},{\"text\":\"TypeScript\",\"link\":\"/learning/engineering/modules/page4\"},{\"text\":\"Uniapp\",\"link\":\"/learning/engineering/modules/page5\"}]},\"/learning/other/page\":{\"text\":\"其它\",\"items\":[{\"text\":\"大文件上传\",\"link\":\"/learning/other/modules/page1\"}]},\"/learning/other/modules/page1\":{\"text\":\"其它\",\"items\":[{\"text\":\"大文件上传\",\"link\":\"/learning/other/modules/page1\"}]}},\"outlineTitle\":\"本页目录\",\"outline\":{\"level\":[2,3],\"label\":\"目录\"},\"footer\":{\"copyright\":\"Copyright © 2025-rookie\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/shufei021/rookie-fly-blog\"}],\"search\":{\"provider\":\"local\"},\"lastUpdatedText\":\"最后更新\",\"docFooter\":{\"prev\":\"上一篇\",\"next\":\"下一篇\"},\"mermaid\":{\"enable\":true,\"options\":{\"theme\":\"default\"}}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>