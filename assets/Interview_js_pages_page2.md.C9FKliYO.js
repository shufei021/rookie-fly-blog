import{_ as a,a as l,o as i,b0 as o}from"./chunks/framework.BBy0ZaTh.js";const u=JSON.parse('{"title":"浏览器输入URL到页面加载的过程","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/js/pages/page2.md","filePath":"Interview/js/pages/page2.md","lastUpdated":1751338681000}'),t={name:"Interview/js/pages/page2.md"};function s(d,e,c,r,n,h){return i(),l("div",null,e[0]||(e[0]=[o(`<h1 id="浏览器输入url到页面加载的过程" tabindex="-1">浏览器输入URL到页面加载的过程 <a class="header-anchor" href="#浏览器输入url到页面加载的过程" aria-label="Permalink to &quot;浏览器输入URL到页面加载的过程&quot;">​</a></h1><h2 id="一、用户输入-url" tabindex="-1">一、用户输入 URL <a class="header-anchor" href="#一、用户输入-url" aria-label="Permalink to &quot;一、用户输入 URL&quot;">​</a></h2><p>例如：<a href="https://www.example.com/index.html" target="_blank" rel="noreferrer">https://www.example.com/index.html</a></p><h2 id="二、浏览器解析-url" tabindex="-1">二、浏览器解析 URL <a class="header-anchor" href="#二、浏览器解析-url" aria-label="Permalink to &quot;二、浏览器解析 URL&quot;">​</a></h2><p>提取出 <code>协议</code>（如 HTTPS）、<code>域名</code>（如 www.example.com）、<code>端口号</code>（默认为 443 或 80）和<code>路径（如 /index.html）等信息</code>。</p><h2 id="三、dns-解析-域名解析" tabindex="-1">三、DNS 解析（域名解析） <a class="header-anchor" href="#三、dns-解析-域名解析" aria-label="Permalink to &quot;三、DNS 解析（域名解析）&quot;">​</a></h2><blockquote><p><code>目标</code>：将 www.example.com 转换为一个 IP 地址，比如 93.184.216.34。</p></blockquote><ul><li>（查缓存）<code>浏览器缓存</code>：浏览器是否有该域名的缓存记录。</li><li>（查缓存）<code>操作系统缓存</code>：操作系统中是否缓存了这个域名对应的 IP 地址。</li><li>（查缓存）<code>路由器缓存</code>：如果前面没找到，可能会查询路由器的 DNS 缓存。</li><li>（查询）<code>运营商 DNS 服务器</code>：最终向 ISP 提供的 DNS 服务器发起查询。</li><li>（查询）<code>递归/迭代查询</code>：DNS 服务器可能需要通过<code>根域名服务器</code>、<code>顶级域名服务器</code>、<code>权威域名</code>服务器来获取最终 IP。</li></ul><p><strong>3查缓存2查询</strong></p><h2 id="四、建立-tcp-连接-三次握手" tabindex="-1">四、建立 TCP 连接（三次握手） <a class="header-anchor" href="#四、建立-tcp-连接-三次握手" aria-label="Permalink to &quot;四、建立 TCP 连接（三次握手）&quot;">​</a></h2><blockquote><p><code>目标</code>：与目标服务器建立连接</p></blockquote><p>浏览器与目标服务器建立 TCP 连接：</p><ul><li><code>客户端发送 SYN包</code>：请求建立连接</li><li><code>服务端响应 SYN-ACK</code> 包： 确认收到请求，并同意建立连接</li><li><code>客户端再发 ACK包</code>：确认收到服务器的回复，连接建立。</li></ul><h2 id="tls握手-https" tabindex="-1">TLS握手（HTTPS） <a class="header-anchor" href="#tls握手-https" aria-label="Permalink to &quot;TLS握手（HTTPS）&quot;">​</a></h2><p>如果使用HTTPS协议，在TCP连接建立后，还需要进行TLS握手</p><ul><li><code>ClientHello</code>： 客户端发送支持的TLS版本、加密套件列表、随机数等信息</li><li><code>ServerHello</code>: 服务器选择加密套件、发送随机数、证书（包含公钥）</li><li><code>密钥交换</code>：客户端生成主密钥，用服务器公钥加密发送</li><li><code>完成握手</code>：双方生成会话密钥，后续通信使用对称加密</li></ul><h2 id="五、发送-http-s-请求" tabindex="-1">五、发送 HTTP(S) 请求 <a class="header-anchor" href="#五、发送-http-s-请求" aria-label="Permalink to &quot;五、发送 HTTP(S) 请求&quot;">​</a></h2><p>浏览器发送一个 HTTP 请求，例如：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /index.html</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HTTP/1.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Host:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.example.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">User-Agent:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Accept:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> text/html,...</span></span></code></pre></div><h2 id="六、服务器接收请求并返回响应" tabindex="-1">六、服务器接收请求并返回响应 <a class="header-anchor" href="#六、服务器接收请求并返回响应" aria-label="Permalink to &quot;六、服务器接收请求并返回响应&quot;">​</a></h2><ul><li><code>负载均衡</code>：请求可能被分发到多台服务器中的一台</li><li><code>业务逻辑处理</code>：执行相应的应用逻辑，如数据库查询、模板渲染等</li><li><code>返回响应</code>：服务器生成 HTTP 响应，包含状态码、响应头、响应体</li></ul><h2 id="七、浏览器接收响应并解析" tabindex="-1">七、浏览器接收响应并解析 <a class="header-anchor" href="#七、浏览器接收响应并解析" aria-label="Permalink to &quot;七、浏览器接收响应并解析&quot;">​</a></h2><ul><li><code>解析 HTML</code>：构建 DOM 树</li><li><code>解析 CSS</code>：构建 CSSOM 树</li><li><code>合并生成 Render Tree</code>：将 DOM 树 和 CSSOM 树 合并生成渲染树，只包含需要渲染的节点及其样式信息</li><li><code>布局（Layout）</code>：计算每个元素在页面上的位置和大小</li><li><code>绘制（Paint）</code>：将像素绘制到屏幕上</li><li><code>合成（Composite）</code>：将多个图层合并，优化渲染性能，最终显示在屏幕上</li></ul><p><strong>6步</strong></p><h2 id="八、加载子资源-js、css、图片等" tabindex="-1">八、加载子资源（JS、CSS、图片等） <a class="header-anchor" href="#八、加载子资源-js、css、图片等" aria-label="Permalink to &quot;八、加载子资源（JS、CSS、图片等）&quot;">​</a></h2><ul><li>页面中的 &lt; script&gt;、&lt; link&gt;、&lt; img&gt; 等标签会触发额外的 HTTP 请求；</li><li>JavaScript 可能会修改 DOM/CSSOM，导致重新渲染；</li><li>异步请求（AJAX）也可能在此阶段发起，用于局部更新或数据加载。</li></ul><h2 id="九、页面加载完成" tabindex="-1">九、页面加载完成 <a class="header-anchor" href="#九、页面加载完成" aria-label="Permalink to &quot;九、页面加载完成&quot;">​</a></h2><ul><li>所有资源加载完毕；</li><li>window.onload 事件被触发；</li><li>用户可以开始与页面交互。</li></ul><h2 id="十、断开连接-四次挥手" tabindex="-1">十、断开连接（四次挥手） <a class="header-anchor" href="#十、断开连接-四次挥手" aria-label="Permalink to &quot;十、断开连接（四次挥手）&quot;">​</a></h2><p>TCP 连接在一定时间内没有数据传输后，双方协商关闭连接。 数据传输完成后，协商关闭连接过程：</p><ul><li><code>客户端发送FIN包</code>：请求关闭连接</li><li><code>服务器回复ACK包</code>：确认收到关闭请求</li><li><code>服务器发送FIN包</code>：服务器也请求关闭连接</li><li><code>客户端回复ACK包</code>：确认服务器的关闭请求，连接断开</li></ul><h2 id="拓展知识点-加分项" tabindex="-1">拓展知识点（加分项） <a class="header-anchor" href="#拓展知识点-加分项" aria-label="Permalink to &quot;拓展知识点（加分项）&quot;">​</a></h2><ul><li>CDN 加速：资源可能从 CDN 获取，提高访问速度；</li><li>HTTP/2 &amp; HTTP/3：使用更高效的协议减少延迟；</li><li>预加载策略：如 DNS Prefetch、Preconnect、Prefetch、Prerender；</li><li>Service Worker &amp; PWA：离线缓存和增强用户体验；</li><li>安全相关：如 CSP、SameSite Cookie 属性、HTTPS 的作用等。</li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><blockquote><p>当我在浏览器中输入一个 URL 后，整个过程涉及到了 DNS 解析、TCP 建立连接、发送 HTTP 请求、服务器处理请求并返回响应、浏览器解析 HTML 和渲染页面等多个步骤。同时，现代浏览器还优化了加载性能，比如异步加载资源、使用缓存、利用 CDN 等技术手段。整个过程背后体现了客户端与服务器端的协作，也涉及到网络、操作系统、前端渲染等多个层面的知识。</p></blockquote>`,35)]))}const k=a(t,[["render",s]]);export{u as __pageData,k as default};
