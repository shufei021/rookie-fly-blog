import{_ as n,g as r,a as u,o as s,b0 as d,d as a,b as l,j as i,f as o}from"./chunks/framework.BBy0ZaTh.js";const g=JSON.parse('{"title":"首屏优化如何去做","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/js/pages/page3.md","filePath":"Interview/js/pages/page3.md","lastUpdated":1751439771000}'),c={name:"Interview/js/pages/page3.md"};function S(_,e,p,C,f,h){const t=r("VStyle");return s(),u("div",null,[e[5]||(e[5]=d('<h1 id="首屏优化如何去做" tabindex="-1">首屏优化如何去做 <a class="header-anchor" href="#首屏优化如何去做" aria-label="Permalink to &quot;首屏优化如何去做&quot;">​</a></h1><h2 id="🎯-理解问题背景" tabindex="-1">🎯 理解问题背景 <a class="header-anchor" href="#🎯-理解问题背景" aria-label="Permalink to &quot;🎯 理解问题背景&quot;">​</a></h2><p>首屏优化的核心目标是<code>提升用户感知加载速度</code>，<code>减少白屏时间</code>，<code>让用户尽快看到内容</code>，从而提升用户体验和转化率。</p><h2 id="🧱-二、从整体流程出发-分阶段优化" tabindex="-1">🧱 二、从整体流程出发，分阶段优化 <a class="header-anchor" href="#🧱-二、从整体流程出发-分阶段优化" aria-label="Permalink to &quot;🧱 二、从整体流程出发，分阶段优化&quot;">​</a></h2>',4)),a(t,{style:{color:"#036aca",fontWeight:"600"}},{default:i(()=>e[0]||(e[0]=[o(" 1. 资源加载优化（Load） ")])),_:1,__:[0]}),e[6]||(e[6]=d("<ul><li><code>压缩资源</code>：使用 Gzip / Brotli 压缩 JS/CSS/HTML。</li><li><code>图片懒加载</code>：非首屏图片延迟加载，使用 loading=&quot;lazy&quot; 或 Intersection Observer。</li><li><code>CDN 加速</code>：静态资源部署到 CDN，缩短请求路径。</li><li><code>字体优化</code>：只加载必要的字体子集，避免阻塞渲染。</li><li><code>关键资源优先级</code>：通过 rel=&quot;preload&quot; 预加载关键 CSS、JS、字体。</li></ul>",1)),a(t,{style:{color:"#036aca",fontWeight:"600"}},{default:i(()=>e[1]||(e[1]=[o("2. 代码分割与打包优化（Build）")])),_:1,__:[1]}),e[7]||(e[7]=l("ul",null,[l("li",null,[l("code",null,"按需加载（Code Splitting）"),o("：使用动态 import() 拆分非首屏模块。")]),l("li",null,[l("code",null,"Tree Shaking"),o("：移除未使用的代码，减小包体积。")]),l("li",null,[l("code",null,"SplitChunks"),o("：将第三方库和业务代码分离，利用缓存。")])],-1)),a(t,{style:{color:"#036aca",fontWeight:"600"}},{default:i(()=>e[2]||(e[2]=[o("3. 服务端配合（Server）")])),_:1,__:[2]}),e[8]||(e[8]=l("ul",null,[l("li",null,[l("code",null,"服务端渲染（SSR）或预渲染（Prerendering）"),o("：提前返回 HTML 内容，加快首屏显示。")]),l("li",null,[l("code",null,"HTTP/2 / HTTP/3 协议"),o("：多路复用，减少请求耗时。")]),l("li",null,[l("code",null,"服务端缓存策略"),o("：合理设置缓存头（Cache-Control、ETag），减少重复请求。")])],-1)),a(t,{style:{color:"#036aca",fontWeight:"600"}},{default:i(()=>e[3]||(e[3]=[o("4. 浏览器渲染优化（Render）")])),_:1,__:[3]}),e[9]||(e[9]=l("ul",null,[l("li",null,[l("code",null,"Critical Rendering Path（CRP）优化"),o("： "),l("ul",null,[l("li",null,"减少关键请求链长度。"),l("li",null,"减少关键资源大小。")])]),l("li",null,[l("code",null,"内联关键 CSS（Critical CSS）"),o("：提前注入首屏需要的样式，避免 FOUC。")]),l("li",null,[l("code",null,"避免阻塞渲染的脚本"),o("：不将 JS 放在 < head> 中同步加载，使用 async 或 defer。")])],-1)),a(t,{style:{color:"#036aca",fontWeight:"600"}},{default:i(()=>e[4]||(e[4]=[o("5. 监控与持续优化")])),_:1,__:[4]}),e[10]||(e[10]=d('<ul><li>使用 <code>Lighthouse</code>、<code>PageSpeed Insights</code>、<code>Web Vitals</code> 等工具评估性能指标。</li><li>关注核心指标如： <ul><li>FCP（First Contentful Paint）</li><li>LCP（Largest Contentful Paint）</li><li>FID（First Input Delay）</li><li>CLS（Cumulative Layout Shift）</li></ul></li></ul><h2 id="💡-三、结合项目经验举例说明" tabindex="-1">💡 三、结合项目经验举例说明 <a class="header-anchor" href="#💡-三、结合项目经验举例说明" aria-label="Permalink to &quot;💡 三、结合项目经验举例说明&quot;">​</a></h2><blockquote><p>示例：在我上一个项目中，我们通过 <code>SSR</code> + <code>骨架屏</code> + <code>Critical CSS</code> 的方式，将 FCP 从 4s 缩短到 1.5s。同时，通过 <code>Webpack</code> 的 <code>Code Splitting</code> 和<code>懒加载</code>，将首页 JS <code>包体积</code>从 3MB 减少到 600KB，显著提升了加载速度。</p></blockquote><h2 id="📈-四、总结与价值输出" tabindex="-1">📈 四、总结与价值输出 <a class="header-anchor" href="#📈-四、总结与价值输出" aria-label="Permalink to &quot;📈 四、总结与价值输出&quot;">​</a></h2><blockquote><p>“前端性能优化不仅关乎技术实现，更是产品体验的重要保障。作为开发者，我们需要从用户视角出发，持续关注性能指标，并通过工程化手段保持长期优化。”</p></blockquote><h2 id="✅-加分项" tabindex="-1">✅ 加分项 <a class="header-anchor" href="#✅-加分项" aria-label="Permalink to &quot;✅ 加分项&quot;">​</a></h2><ul><li>能区分客户端渲染（CSR）和服务器端渲染（SSR）下的不同优化策略。</li><li>对现代构建工具（Webpack/Vite）有深入理解。</li><li>能说出具体的性能指标及其优化方法。</li><li>能结合具体项目谈经验，体现落地能力。</li></ul>',7))])}const P=n(c,[["render",S]]);export{g as __pageData,P as default};
