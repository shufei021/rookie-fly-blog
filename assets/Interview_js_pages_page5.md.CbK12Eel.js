import{_ as e,a,o as l,b0 as r}from"./chunks/framework.D10JOWeE.js";const p=JSON.parse('{"title":"HTTP1 和 HTTP2 的区别","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/js/pages/page5.md","filePath":"Interview/js/pages/page5.md","lastUpdated":1752997743000}'),i={name:"Interview/js/pages/page5.md"};function n(s,t,d,g,h,o){return l(),a("div",null,t[0]||(t[0]=[r('<h1 id="http1-和-http2-的区别" tabindex="-1">HTTP1 和 HTTP2 的区别 <a class="header-anchor" href="#http1-和-http2-的区别" aria-label="Permalink to &quot;HTTP1 和 HTTP2 的区别&quot;">​</a></h1><h2 id="🌟-前言" tabindex="-1">🌟 前言 <a class="header-anchor" href="#🌟-前言" aria-label="Permalink to &quot;🌟 前言&quot;">​</a></h2><blockquote><p>“HTTP/2 是对 HTTP/1.x 协议的重大升级，主要目标是提升网页加载速度、减少延迟、提高安全性。它基于 Google 的 SPDY 协议发展而来。”</p></blockquote><h2 id="📊-分点对比-清晰易懂" tabindex="-1">📊 分点对比：清晰易懂 <a class="header-anchor" href="#📊-分点对比-清晰易懂" aria-label="Permalink to &quot;📊 分点对比：清晰易懂&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:right;">特性</th><th style="text-align:right;">HTTP/1.1</th><th style="text-align:right;">HTTP/2</th></tr></thead><tbody><tr><td style="text-align:right;">传输格式</td><td style="text-align:right;">明文（文本）</td><td style="text-align:right;">二进制</td></tr><tr><td style="text-align:right;">多路复用</td><td style="text-align:right;">不支持，需多个连接</td><td style="text-align:right;">支持，单连接并发请求</td></tr><tr><td style="text-align:right;">头部压缩</td><td style="text-align:right;">无压缩</td><td style="text-align:right;">使用 HPACK 压缩</td></tr><tr><td style="text-align:right;">服务器推送</td><td style="text-align:right;">不支持</td><td style="text-align:right;">支持 Server Push</td></tr><tr><td style="text-align:right;">请求优先级</td><td style="text-align:right;">不支持</td><td style="text-align:right;">支持设置优先级</td></tr><tr><td style="text-align:right;">必须加密</td><td style="text-align:right;">否</td><td style="text-align:right;">推荐使用 TLS（通常加密）</td></tr></tbody></table><h2 id="🔍-深入讲解每个关键点" tabindex="-1">🔍 深入讲解每个关键点 <a class="header-anchor" href="#🔍-深入讲解每个关键点" aria-label="Permalink to &quot;🔍 深入讲解每个关键点&quot;">​</a></h2><p><strong>1. 二进制分帧层（Binary Framing Layer）</strong></p><ul><li>HTTP/1.1 是基于文本解析的，效率低。</li><li>HTTP/2 将所有通信数据划分为更小的帧（frame），并封装成流（stream），实现高效的数据交换。</li></ul><p><strong>2. 多路复用（Multiplexing）</strong></p><ul><li>HTTP/1.1 每个请求/响应需要单独的 TCP 连接或阻塞式串行传输。</li><li>HTTP/2 可以在一个连接中发送多个请求和响应，避免“队头阻塞”，显著降低延迟。</li></ul><p><strong>3. 头部压缩（HPACK）</strong></p><ul><li>HTTP/1.1 每次请求都重复发送大量相同的头部信息（如 Cookie、User-Agent）。</li><li>HTTP/2 使用 HPACK 算法压缩头部，减少冗余数据传输。</li></ul><p><strong>4. 服务器推送（Server Push）</strong></p><ul><li>HTTP/2 允许服务器主动将资源推送给客户端，提前缓存，加快页面渲染速度。</li></ul><p><strong>5. 请求优先级（Stream Prioritization）</strong></p><ul><li>客户端可以指定哪些请求更重要，服务器据此调整响应顺序，优化用户体验</li></ul><h2 id="💡-结合实际场景举例说明优势" tabindex="-1">💡 结合实际场景举例说明优势 <a class="header-anchor" href="#💡-结合实际场景举例说明优势" aria-label="Permalink to &quot;💡 结合实际场景举例说明优势&quot;">​</a></h2><p><strong>比如打开一个包含多个图片、CSS、JS 文件的网页：</strong></p><ul><li>HTTP/1.1 需要建立多个连接或排队请求，容易造成延迟；</li><li>HTTP/2 可以在一个连接中同时加载所有资源，并通过服务器推送预加载关键资源，使页面加载更快。</li></ul>',19)]))}const P=e(i,[["render",n]]);export{p as __pageData,P as default};
