import{_ as s,a,o as t,b0 as l}from"./chunks/framework.BBy0ZaTh.js";const c=JSON.parse('{"title":"温故而知新","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/old/page.md","filePath":"Interview/old/page.md","lastUpdated":1751439771000}'),e={name:"Interview/old/page.md"};function n(o,i,d,r,h,p){return t(),a("div",null,i[0]||(i[0]=[l(`<h1 id="温故而知新" tabindex="-1">温故而知新 <a class="header-anchor" href="#温故而知新" aria-label="Permalink to &quot;温故而知新&quot;">​</a></h1><h2 id="javsscript-相关" tabindex="-1">JavsScript 相关 <a class="header-anchor" href="#javsscript-相关" aria-label="Permalink to &quot;JavsScript 相关&quot;">​</a></h2><h3 id="箭头函数和普通函数的区别" tabindex="-1">箭头函数和普通函数的区别 <a class="header-anchor" href="#箭头函数和普通函数的区别" aria-label="Permalink to &quot;箭头函数和普通函数的区别&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>箭头函数</th><th>普通函数</th></tr></thead><tbody><tr><td><code>this</code> 指向</td><td>外层作用域</td><td>调用者</td></tr><tr><td><code>arguments</code></td><td>不支持</td><td>支持</td></tr><tr><td><code>new</code> 调用</td><td>不可作为构造函数</td><td>可以</td></tr><tr><td><code>prototype</code> 属性</td><td>无</td><td>有</td></tr><tr><td><code>super</code></td><td>不支持</td><td>支持</td></tr></tbody></table><h2 id="vue-js-相关" tabindex="-1">Vue.js 相关 <a class="header-anchor" href="#vue-js-相关" aria-label="Permalink to &quot;Vue.js 相关&quot;">​</a></h2><h3 id="vue-的双向数据绑定原理" tabindex="-1">Vue 的双向数据绑定原理 <a class="header-anchor" href="#vue-的双向数据绑定原理" aria-label="Permalink to &quot;Vue 的双向数据绑定原理&quot;">​</a></h3><p>Vue 的双向绑定核心是通过 <code>Object.defineProperty</code>（Vue2）或 <code>Proxy</code>（Vue3）劫持数据的读写操作，并结合发布订阅模式实现。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Vue2 实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineReactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, key, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> val;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVal) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newVal;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;数据更新了&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineReactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Vue3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 控制台输出 &quot;数据更新了&quot;</span></span></code></pre></div><hr><h3 id="vue-的生命周期有哪些及每个生命周期做了什么" tabindex="-1">Vue 的生命周期有哪些及每个生命周期做了什么 <a class="header-anchor" href="#vue-的生命周期有哪些及每个生命周期做了什么" aria-label="Permalink to &quot;Vue 的生命周期有哪些及每个生命周期做了什么&quot;">​</a></h3><table tabindex="0"><thead><tr><th>生命周期钩子</th><th>描述</th></tr></thead><tbody><tr><td><code>beforeCreate</code></td><td>实例初始化之后，数据观测和事件配置之前</td></tr><tr><td><code>created</code></td><td>实例创建完成，数据观测、属性和方法的运算、watch/event 事件回调建立</td></tr><tr><td><code>beforeMount</code></td><td>模板编译挂载之前</td></tr><tr><td><code>mounted</code></td><td>模板编译挂载完成</td></tr><tr><td><code>beforeUpdate</code></td><td>数据更新时，虚拟 DOM 重新渲染之前</td></tr><tr><td><code>updated</code></td><td>虚拟 DOM 重新渲染之后</td></tr><tr><td><code>beforeUnmount</code></td><td>实例销毁之前</td></tr><tr><td><code>unmounted</code></td><td>实例销毁之后</td></tr></tbody></table><hr><h3 id="vue-的自定义指令用过吗-有哪些" tabindex="-1">Vue 的自定义指令用过吗，有哪些 <a class="header-anchor" href="#vue-的自定义指令用过吗-有哪些" aria-label="Permalink to &quot;Vue 的自定义指令用过吗，有哪些&quot;">​</a></h3><ul><li><code>v-focus</code>：自动聚焦输入框；</li><li><code>v-permission</code>：权限控制；</li><li><code>v-lazy</code>：图片懒加载；</li><li><code>v-throttle</code>：防抖节流；</li><li><code>v-draggable</code>：拖拽行为。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 注册自定义指令 v-focus</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;focus&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    el.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h3 id="vue-如何优化-seo" tabindex="-1">Vue 如何优化 SEO <a class="header-anchor" href="#vue-如何优化-seo" aria-label="Permalink to &quot;Vue 如何优化 SEO&quot;">​</a></h3><ul><li><strong>SSR（服务端渲染）</strong>：使用 Nuxt.js 实现首屏直出；</li><li><strong>预渲染（Prerendering）</strong>：静态站点可用 <code>prerender-spa-plugin</code>；</li><li><strong>Meta 标签动态注入</strong>：使用 <code>vue-meta</code> 管理 meta 信息；</li><li><strong>结构语义化标签</strong>：合理使用 <code>h1~h6</code>、<code>nav</code>、<code>main</code> 等；</li><li><strong>服务端渲染 + 客户端激活（Hydration）</strong>：兼顾性能与 SEO。</li></ul><hr><h3 id="vue2-和-vue3-的区别" tabindex="-1">Vue2 和 Vue3 的区别 <a class="header-anchor" href="#vue2-和-vue3-的区别" aria-label="Permalink to &quot;Vue2 和 Vue3 的区别&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>Vue2</th><th>Vue3</th></tr></thead><tbody><tr><td>响应式系统</td><td><code>Object.defineProperty</code></td><td><code>Proxy</code></td></tr><tr><td>Composition API</td><td>无</td><td>有</td></tr><tr><td>Tree Shaking</td><td>有限</td><td>支持</td></tr><tr><td>性能</td><td>较低</td><td>更高</td></tr><tr><td>模块化</td><td>无</td><td>支持</td></tr><tr><td>类型支持</td><td>无</td><td>支持 TypeScript</td></tr></tbody></table><hr><h3 id="vue-的组件通信方式有哪些及原理" tabindex="-1">Vue 的组件通信方式有哪些及原理 <a class="header-anchor" href="#vue-的组件通信方式有哪些及原理" aria-label="Permalink to &quot;Vue 的组件通信方式有哪些及原理&quot;">​</a></h3><ol><li><strong>props / $emit</strong>：父传子、子传父；</li><li><strong>$root / $parent / $children</strong>：跨级通信；</li><li><strong>EventBus</strong>：非父子组件通信；</li><li><strong>Vuex / Pinia</strong>：全局状态管理；</li><li><strong>provide / inject</strong>：跨层级通信；</li><li><strong>$attrs / $listeners</strong>：传递非 props 属性和事件。</li></ol><hr><h3 id="vue-的路由实现-hash-路由和-history-路由实现原理" tabindex="-1">Vue 的路由实现，hash 路由和 history 路由实现原理 <a class="header-anchor" href="#vue-的路由实现-hash-路由和-history-路由实现原理" aria-label="Permalink to &quot;Vue 的路由实现，hash 路由和 history 路由实现原理&quot;">​</a></h3><ul><li><strong>Hash 路由</strong>：通过 URL 的 <code>#</code> 后面的字符变化实现路由，不触发页面刷新。</li><li><strong>History 路由</strong>：使用 HTML5 的 <code>pushState</code> 和 <code>replaceState</code> 方法，URL 更美观，但需要服务器配置支持。</li></ul><h3 id="keep-alive的实现原理和常用属性" tabindex="-1">keep-alive的实现原理和常用属性 <a class="header-anchor" href="#keep-alive的实现原理和常用属性" aria-label="Permalink to &quot;keep-alive的实现原理和常用属性&quot;">​</a></h3><p><code>&lt;keep-alive&gt;</code> 是 Vue.js 中的一个抽象组件，它用于缓存动态组件实例，从而避免重复渲染和销毁过程，提高用户体验和性能。下面是 <code>&lt;keep-alive&gt;</code> 的一些常用属性及其简要说明：</p><h4 id="常用属性" tabindex="-1">常用属性 <a class="header-anchor" href="#常用属性" aria-label="Permalink to &quot;常用属性&quot;">​</a></h4><ol><li><strong>include</strong>：字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li><strong>exclude</strong>：字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li><strong>max</strong>：数字。定义缓存组中可以保存的最大组件实例数量。</li></ol><p>示例：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exclude</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;c&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> :</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">max</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;component :is=&quot;currentView&quot;&gt;&lt;/component&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">keep-alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>在这个例子中，仅当 <code>currentView</code> 是组件 <code>a</code> 或 <code>b</code> 时，它们才会被缓存，并且缓存的组件总数不会超过 10 个。</p><h4 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h4><p><code>&lt;keep-alive&gt;</code> 组件的工作原理主要依赖于 Vue 的生命周期钩子以及内部的状态管理机制。以下是其大致工作流程：</p><ol><li><p>当一个组件被包裹在 <code>&lt;keep-alive&gt;</code> 标签内并且开始渲染时，Vue 会检查该组件是否符合 <code>include</code> 和 <code>exclude</code> 规则（如果设置了的话）。符合条件的组件将进入缓存逻辑处理。</p></li><li><p>如果组件已经被缓存过，则 <code>&lt;keep-alive&gt;</code> 不会重新创建一个新的实例，而是直接从缓存中取出并激活这个组件实例。这通过调用组件的 <code>deactivated</code> 生命周期钩子来暂停组件，而再次进入可视状态时调用 <code>activated</code> 钩子来恢复组件。</p></li><li><p>对于新的组件或者不在缓存中的组件，Vue 将正常地挂载这些组件。一旦这些组件离开可视区域，它们的状态（包括 DOM 结构、组件实例等）会被存储在一个 LRU (Least Recently Used) 缓存中。</p></li><li><p>如果设置了 <code>max</code> 属性，当达到最大缓存限制时，最近最少使用的组件实例将会被移除以腾出空间给新的组件实例。</p></li></ol><p>通过这种方式，<code>&lt;keep-alive&gt;</code> 能够有效地管理组件的状态和生命周期，提升应用性能，特别是在需要频繁切换显示不同视图的情况下非常有用。</p><h3 id="vue-的-computed-的实现原理" tabindex="-1">Vue 的 computed 的实现原理 <a class="header-anchor" href="#vue-的-computed-的实现原理" aria-label="Permalink to &quot;Vue 的 computed 的实现原理&quot;">​</a></h3><p>Vue 的 <code>computed</code> 属性实现的核心在于依赖追踪和响应式系统。简要来说，其实现原理包括以下几个关键点：</p><ul><li><ol><li><strong>依赖收集</strong>：当一个计算属性（computed property）被访问时，Vue 会自动追踪在这个过程中哪些响应式数据（reactive data）被访问了。这是通过 Vue 的响应式系统来完成的，该系统会在读取响应式数据时进行依赖收集。</li></ol></li><li><ol start="2"><li><strong>缓存机制</strong>：计算属性的结果会被缓存起来，并且只有在其依赖的数据发生变化时才会重新计算。这意味着如果相关依赖未发生改变，多次访问同一个计算属性将会立即返回缓存的结果，而不会重复执行计算逻辑。</li></ol></li><li><ol start="3"><li><strong>响应更新</strong>：一旦某个计算属性所依赖的数据发生了变化，Vue 就会知道需要重新计算这个计算属性的值，并更新相应的视图。这种更新是自动的，开发者不需要手动干预。</li></ol></li><li><ol start="4"><li><strong>惰性求值</strong>：计算属性采用惰性求值策略，即仅在访问计算属性时才执行计算逻辑，而不是在定义时就立即执行。这样可以避免不必要的计算，提高性能。</li></ol></li></ul><p>综上所述，Vue 的 <code>computed</code> 利用了依赖追踪、缓存机制以及响应式更新等特性，使得它能够高效地管理复杂状态逻辑，同时简化了代码的编写和维护工作。</p><h2 id="前端工程化" tabindex="-1">前端工程化 <a class="header-anchor" href="#前端工程化" aria-label="Permalink to &quot;前端工程化&quot;">​</a></h2><h3 id="webpack-的构建流程" tabindex="-1">Webpack 的构建流程 <a class="header-anchor" href="#webpack-的构建流程" aria-label="Permalink to &quot;Webpack 的构建流程&quot;">​</a></h3><ul><li><ol><li>初始化参数：读取配置文件，合并默认参数；</li></ol></li><li><ol start="2"><li>入口分析：根据 <code>entry</code> 找到入口模块；</li></ol></li><li><ol start="3"><li>编译模块：使用 loader 转换不同类型的资源；</li></ol></li><li><ol start="4"><li>依赖收集：递归解析模块依赖，构建依赖图；</li></ol></li><li><ol start="5"><li>优化打包：Tree Shaking、代码分割（Code Splitting）、合并 chunk；</li></ol></li><li><ol start="6"><li>输出资源：将最终资源写入 <code>dist</code> 目录。</li></ol></li></ul><h4 id="常用的loader-plugin" tabindex="-1">常用的Loader/plugin <a class="header-anchor" href="#常用的loader-plugin" aria-label="Permalink to &quot;常用的Loader/plugin&quot;">​</a></h4><p>Webpack 是一个强大的模块打包工具，它通过各种插件和 loader 来增强其功能。下面列出一些常用的 Webpack 插件和 loader：</p><h5 id="常用-loader" tabindex="-1">常用 Loader <a class="header-anchor" href="#常用-loader" aria-label="Permalink to &quot;常用 Loader&quot;">​</a></h5><ul><li><ol><li><strong>Babel-loader</strong>: 将 ES6+ 代码转换为向后兼容的 JavaScript 版本。</li></ol></li><li><ol start="2"><li><strong>Css-loader &amp; Style-loader</strong>: <code>css-loader</code> 解析 CSS 文件中的 <code>@import</code> 和 <code>url()</code>，而 <code>style-loader</code> 将 CSS 注入到 DOM 中。</li></ol></li><li><ol start="3"><li><strong>File-loader</strong>: 用于处理文件导入（如图片、字体等），将它们复制到输出目录，并返回正确的 URL。</li></ol></li><li><ol start="4"><li><strong>Url-loader</strong>: 功能类似于 file-loader，但可以将文件转换成 base64 URI。</li></ol></li><li><ol start="5"><li><strong>Sass/Less-loader</strong>: 如果项目使用 Sass 或 Less 等预处理器，则需要对应的 loader 来解析这些文件。</li></ol></li><li><ol start="6"><li><strong>Postcss-loader</strong>: 结合 PostCSS 插件自动添加浏览器前缀或进行其他 CSS 处理。</li></ol></li><li><ol start="7"><li><strong>Ts-loader</strong>: 如果你的项目是 TypeScript 项目，那么你可能需要 ts-loader 来编译 TypeScript。</li></ol></li></ul><h5 id="常用插件" tabindex="-1">常用插件 <a class="header-anchor" href="#常用插件" aria-label="Permalink to &quot;常用插件&quot;">​</a></h5><ul><li><ol><li><strong>Html-webpack-plugin</strong>: 自动生成 HTML 文件，并在其中自动引入所有生成的 bundle。</li></ol></li><li><ol start="2"><li><strong>Clean-webpack-plugin</strong>: 在每次构建之前清理输出目录。</li></ol></li><li><ol start="3"><li><strong>Mini-css-extract-plugin</strong>: 提取 CSS 到单独的文件中，而不是像 style-loader 那样直接注入到 HTML 中。</li></ol></li><li><ol start="4"><li><strong>Copy-webpack-plugin</strong>: 可以方便地将单个文件或整个目录复制到构建目录。</li></ol></li><li><ol start="5"><li><strong>Define-plugin</strong>: 允许创建可在编译时配置的全局常量。</li></ol></li><li><ol start="6"><li><strong>Hot-module-replacement (HMR)</strong>: 不刷新页面的情况下更新模块，提高开发效率。</li></ol></li><li><ol start="7"><li><strong>Terser-webpack-plugin</strong>: 压缩你的 JavaScript。</li></ol></li><li><ol start="8"><li><strong>Optimize-css-assets-webpack-plugin</strong>: 压缩和优化 CSS 文件。</li></ol></li><li><ol start="9"><li><strong>Bundle-analyzer-plugin</strong>: 可视化展示你的包内容，帮助分析和优化包大小。</li></ol></li></ul><p>每个项目的需求不同，因此选择哪些 loader 和插件取决于项目的具体需求。随着 Webpack 的版本迭代，一些插件和 loader 可能会有更好的替代品或者新的功能加入，请根据实际情况进行选择和配置。</p><h3 id="vite-的构建流程" tabindex="-1">vite 的构建流程 <a class="header-anchor" href="#vite-的构建流程" aria-label="Permalink to &quot;vite 的构建流程&quot;">​</a></h3><p>Vite 是一个基于原生 ES 模块（ESM）的前端构建工具，旨在提供更快、更高效的开发体验。它与传统的打包工具（如 Webpack、Rollup）不同，主要利用浏览器对原生 ES Modules 的支持，在开发模式下实现<strong>无需打包编译的即时加载</strong>。</p><h4 id="常用的plugin" tabindex="-1">常用的plugin <a class="header-anchor" href="#常用的plugin" aria-label="Permalink to &quot;常用的plugin&quot;">​</a></h4><p>Vite 是一个现代的前端构建工具，它提供了快速的开发服务器和优化的构建流程。与 Webpack 不同，Vite 利用了浏览器对 ES 模块的支持来提供更快的开发体验，并且它的插件系统基于 Rollup 的插件系统。下面是一些常用的 Vite 插件以及它们的作用：</p><p><strong>常用插件</strong></p><ul><li><code>@vitejs/plugin-react</code>: 支持 React 项目，包括 JSX 和 React Fast Refresh（在开发过程中无需刷新页面即可更新组件）。</li><li><code>@vitejs/plugin-vue</code>: 支持 Vue 3 项目，包含对单文件组件(SFC)、JSX 和其他 Vue 特性的支持。</li><li><code>@vitejs/plugin-legacy</code>: 生成针对旧版浏览器的包，确保兼容性。</li><li><code>vite-plugin-eslint</code>: 在开发过程中实时检查代码风格错误。</li><li><code>vite-plugin-style-import</code>: 对于使用 Ant Design 等组件库时，可以按需导入样式，减少打包体积。 +<code> vite-plugin-mock</code>: 提供模拟 API 的功能，方便前端独立开发和调试。</li><li><code>vite-plugin-pwa</code>: 添加 PWA 支持，使你的应用可以离线运行。</li><li><code>vite-plugin-compression</code>: 为生产环境生成压缩版本的资源文件（如 Gzip 或 Brotli）。</li><li><code>vite-plugin-imagemin</code>: 压缩图片资源，减小图片大小。</li></ul><p><strong>注意事项</strong></p><p>虽然 Vite 主要依赖于插件而非 loader 来扩展其功能，但需要注意的是，由于 Vite 直接利用了原生 ES 模块进行开发，许多在 Webpack 中需要通过 loader 处理的任务（例如处理 CSS、图片等静态资源）在 Vite 中通常不需要额外配置或只需要简单的配置即可完成。</p><p>下面是 <strong>Vite 的构建流程详解</strong>，分为 <strong>开发模式（Dev Server）</strong> 和 <strong>生产构建（Build）</strong> 两个阶段：</p><h4 id="🚀-一、开发模式-dev-server" tabindex="-1">🚀 一、开发模式（Dev Server） <a class="header-anchor" href="#🚀-一、开发模式-dev-server" aria-label="Permalink to &quot;🚀 一、开发模式（Dev Server）&quot;">​</a></h4><p>在开发模式下，Vite 并不会将整个项目打包成 bundle 文件，而是通过浏览器原生支持的 <code>import</code> / <code>export</code> 来按需加载模块。</p><h5 id="🔁-核心流程如下" tabindex="-1">🔁 核心流程如下： <a class="header-anchor" href="#🔁-核心流程如下" aria-label="Permalink to &quot;🔁 核心流程如下：&quot;">​</a></h5><ol><li><p><strong>启动开发服务器</strong></p><ul><li>启动一个本地 HTTP 服务器，默认监听 <code>localhost:5173</code>。</li><li>支持热更新（HMR）、TypeScript、JSX、CSS 预处理器等。</li></ul></li><li><p><strong>浏览器请求入口文件（如：index.html）</strong></p><ul><li>浏览器加载 HTML 文件后，会解析其中的 <code>&lt;script type=&quot;module&quot;&gt;</code> 标签。</li><li>请求对应的 JavaScript 入口文件（如：<code>main.js</code>）。</li></ul></li><li><p><strong>中间件处理请求</strong></p><ul><li>Vite 使用插件系统来拦截和处理各种类型的文件请求： <ul><li><code>.js</code>, <code>.ts</code>, <code>.vue</code>, <code>.jsx</code>, <code>.css</code>, <code>.json</code> 等。</li></ul></li><li>插件可以进行： <ul><li>类型转换（如 TypeScript 编译为 JS）</li><li>CSS 预处理器编译（Sass、Less、PostCSS）</li><li>路径别名解析</li><li>HMR 更新通知</li></ul></li></ul></li><li><p><strong>按需编译和返回模块</strong></p><ul><li>只有当浏览器实际请求某个模块时，Vite 才会对其进行编译。</li><li>例如：<code>import { createApp } from &#39;vue&#39;</code> 会被 Vite 解析并重写为 <code>/@modules/vue.js</code>，然后从缓存或 node_modules 中读取并返回给浏览器。</li></ul></li><li><p><strong>热更新（HMR）</strong></p><ul><li>当源文件发生更改时，Vite 会自动检测变化，并只更新变更的部分，而不需要刷新整个页面。</li></ul></li><li><p><strong>缓存优化</strong></p><ul><li>第一次请求的模块会被缓存，后续请求直接从内存中获取，提升速度。</li></ul></li></ol><h5 id="✅-开发模式优点" tabindex="-1">✅ 开发模式优点： <a class="header-anchor" href="#✅-开发模式优点" aria-label="Permalink to &quot;✅ 开发模式优点：&quot;">​</a></h5><ul><li>极快的冷启动时间（几乎瞬间）</li><li>即时热更新（毫秒级响应）</li><li>无需等待整个项目打包</li></ul><hr><h4 id="🛠️-二、生产构建-production-build" tabindex="-1">🛠️ 二、生产构建（Production Build） <a class="header-anchor" href="#🛠️-二、生产构建-production-build" aria-label="Permalink to &quot;🛠️ 二、生产构建（Production Build）&quot;">​</a></h4><p>在生产环境中，为了兼容旧浏览器和提高性能，Vite 会使用 <a href="https://rollupjs.org/" target="_blank" rel="noreferrer">Rollup</a> 进行真正的打包操作。</p><h5 id="🔧-构建流程如下" tabindex="-1">🔧 构建流程如下： <a class="header-anchor" href="#🔧-构建流程如下" aria-label="Permalink to &quot;🔧 构建流程如下：&quot;">​</a></h5><ol><li><p><strong>执行 <code>vite build</code> 命令</strong></p><ul><li>Vite 内部调用 Rollup 配置生成打包计划。</li></ul></li><li><p><strong>依赖分析</strong></p><ul><li>Rollup 分析所有依赖项，并确定需要打包的模块。</li></ul></li><li><p><strong>代码压缩与优化</strong></p><ul><li>使用 <code>terser</code>（JS）和 <code>csso</code>（CSS）进行代码压缩。</li><li>Tree-shaking 移除未使用的代码。</li></ul></li><li><p><strong>输出静态资源</strong></p><ul><li>将最终的 JS、CSS、图片等资源输出到 <code>dist/</code> 目录（默认）。</li><li>输出结构包括： <ul><li>JS chunk</li><li>CSS chunk</li><li>静态资源（图片、字体等）</li><li>HTML 入口文件</li></ul></li></ul></li><li><p><strong>配置支持</strong></p><ul><li>支持自定义 Rollup 配置，用于控制输出格式、拆包策略等。</li></ul></li></ol><h5 id="📦-生产环境特点" tabindex="-1">📦 生产环境特点： <a class="header-anchor" href="#📦-生产环境特点" aria-label="Permalink to &quot;📦 生产环境特点：&quot;">​</a></h5><ul><li>支持代码分割（Code Splitting）</li><li>支持异步加载（Dynamic Import）</li><li>支持多种输出格式（如 IIFE、ESM、UMD）</li><li>自动 Polyfill（如果目标浏览器不支持 ESM）</li></ul><hr><h4 id="🧩-插件机制-plugin-system" tabindex="-1">🧩 插件机制（Plugin System） <a class="header-anchor" href="#🧩-插件机制-plugin-system" aria-label="Permalink to &quot;🧩 插件机制（Plugin System）&quot;">​</a></h4><p>Vite 的强大之处在于其插件系统，开发者可以通过插件扩展功能，比如：</p><ul><li>支持 Vue、React、Preact</li><li>TypeScript 支持（<code>@vitejs/plugin-vue</code>, <code>@vitejs/plugin-react</code>, <code>@vitejs/plugin-typescript</code>）</li><li>CSS 预处理器（Sass、Less）</li><li>PostCSS、Tailwind CSS 集成</li><li>自定义插件编写</li></ul><hr><h4 id="📌-总结对比表" tabindex="-1">📌 总结对比表 <a class="header-anchor" href="#📌-总结对比表" aria-label="Permalink to &quot;📌 总结对比表&quot;">​</a></h4><table tabindex="0"><thead><tr><th>阶段</th><th>特点</th><th>技术基础</th><th>优点</th></tr></thead><tbody><tr><td>开发模式</td><td>按需加载、热更新</td><td>原生 ESM</td><td>极快冷启动、快速 HMR</td></tr><tr><td>生产构建</td><td>打包、压缩、Tree-shaking</td><td>Rollup</td><td>体积小、性能优、兼容性强</td></tr></tbody></table><hr><h4 id="🧪-示例命令" tabindex="-1">🧪 示例命令 <a class="header-anchor" href="#🧪-示例命令" aria-label="Permalink to &quot;🧪 示例命令&quot;">​</a></h4><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 启动开发服务器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 构建生产版本</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 预览构建结果</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> preview</span></span></code></pre></div>`,84)]))}const u=s(e,[["render",n]]);export{c as __pageData,u as default};
