import{_ as o,a as e,o as r,b0 as l}from"./chunks/framework.BBy0ZaTh.js";const u=JSON.parse('{"title":"前端首屏优化","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/old/pages/page3.md","filePath":"Interview/old/pages/page3.md","lastUpdated":1752457654000}'),a={name:"Interview/old/pages/page3.md"};function i(n,t,s,d,g,p){return r(),e("div",null,t[0]||(t[0]=[l('<h1 id="前端首屏优化" tabindex="-1">前端首屏优化 <a class="header-anchor" href="#前端首屏优化" aria-label="Permalink to &quot;前端首屏优化&quot;">​</a></h1><p><a href="../pdf/3.pdf" target="_blank">PDF查看流程</a></p><h2 id="加载优化" tabindex="-1">加载优化 <a class="header-anchor" href="#加载优化" aria-label="Permalink to &quot;加载优化&quot;">​</a></h2><ul><li><strong>压缩资源</strong>：使用Gzip或Brotli对JS、CSS和HTML进行压缩。</li><li><strong>图片懒加载</strong>：延迟加载非首屏图片，可以使用<code>loading=&quot;lazy&quot;</code>属性或者Intersection Observer API。</li><li><strong>CDN加速</strong>：将静态资源部署到内容分发网络(CDN)，缩短请求路径。</li><li><strong>字体优化</strong>：仅加载必要的字体子集，避免阻塞页面渲染。</li><li><strong>关键资源优先级</strong>：通过<code>rel=&quot;preload&quot;</code>预加载关键CSS、JS和字体。</li><li><strong>按需加载(Code Splitting)</strong>：采用动态<code>import()</code>拆分非首屏模块。</li></ul><h2 id="构建优化" tabindex="-1">构建优化 <a class="header-anchor" href="#构建优化" aria-label="Permalink to &quot;构建优化&quot;">​</a></h2><ul><li><strong>Tree Shaking</strong>：移除未使用的代码以减小包体积。</li><li><strong>SplitChunks</strong>：分离第三方库和业务代码，以便更好地利用缓存。</li><li><strong>服务端渲染(SSR)或预渲染(Prerendering)</strong>：提前生成HTML内容，加快首屏显示速度。</li><li><strong>HTTP/2/HTTP/3协议</strong>：利用多路复用技术减少请求耗时。</li></ul><h2 id="服务端配合" tabindex="-1">服务端配合 <a class="header-anchor" href="#服务端配合" aria-label="Permalink to &quot;服务端配合&quot;">​</a></h2><ul><li><strong>服务端缓存策略</strong>：合理设置缓存头（如Cache-Control、ETag），减少重复请求。</li><li><strong>最小化资源数量和大小</strong>：减少不必要的资源请求，并通过合并和压缩CSS、JavaScript文件以及图像压缩来减小传输时间。</li></ul><h2 id="关键渲染路径-crp-优化" tabindex="-1">关键渲染路径(CRP)优化 <a class="header-anchor" href="#关键渲染路径-crp-优化" aria-label="Permalink to &quot;关键渲染路径(CRP)优化&quot;">​</a></h2><ul><li><strong>内联关键CSS(Critical CSS)</strong>：提前注入首屏需要的样式，防止无样式内容闪烁(FOUC)。</li><li><strong>避免阻塞渲染的脚本</strong>：不将JS放在<code>&lt;head&gt;</code>中同步加载，而是使用<code>async</code>或<code>defer</code>。</li></ul><h2 id="渲染优化" tabindex="-1">渲染优化 <a class="header-anchor" href="#渲染优化" aria-label="Permalink to &quot;渲染优化&quot;">​</a></h2><ul><li><p><strong>最小化CSS和JavaScript</strong>：确保只加载当前页面需要的CSS和JavaScript代码，避免加载不必要的资源。可以通过构建工具（如Webpack、Gulp等）实现代码分割，仅加载必需的部分。</p></li><li><p><strong>异步加载非关键资源</strong>：对于不影响首屏显示的JavaScript和CSS文件，使用异步或延迟加载的方式，以避免阻塞页面的主要内容渲染。</p></li><li><p><strong>内联关键CSS</strong>：将影响首屏样式的关键CSS直接内联到HTML文档中，可以减少外部资源请求，加快首屏渲染速度。</p></li><li><p><strong>服务端渲染（SSR）或静态生成</strong>：通过服务端渲染或者静态站点生成技术（如Next.js、Nuxt.js等），可以在服务器上预先渲染好HTML，然后发送给客户端，这样浏览器可以直接展示内容，无需等待JavaScript执行。</p></li><li><p><strong>图片懒加载</strong>：对不在首屏显示区域内的图片实施懒加载，即当用户滚动页面至这些图片即将进入视口时再进行加载，从而减少初始页面加载时间。</p></li><li><p><strong>使用现代图像格式</strong>：采用更高效的图像格式如WebP代替传统的JPEG和PNG格式，能够有效减小图像大小，加快图像加载速度。</p></li><li><p><strong>DNS预取和预连接</strong>：利用<code>&lt;link rel=&quot;dns-prefetch&quot;&gt;</code>和<code>&lt;link rel=&quot;preconnect&quot;&gt;</code>标签提前解析域名和建立连接，减少资源加载延迟。</p></li><li><p><strong>资源提示（Preload, Prefetch）</strong>：使用<code>&lt;link rel=&quot;preload&quot;&gt;</code>提前加载关键资源，以及<code>&lt;link rel=&quot;prefetch&quot;&gt;</code>为可能需要的资源做准备，提高资源加载优先级。</p></li><li><p><strong>减少重定向</strong>：尽可能减少HTTP重定向的数量，因为每一次重定向都会增加额外的HTTP请求往返时间。</p></li><li><p><strong>优化字体加载</strong>：对于自定义字体，考虑使用<code>font-display</code>属性来控制字体加载行为，避免文本不可见的情况；也可以尝试使用系统字体以减少网络请求。</p></li></ul><p>这个分类涵盖了从资源加载、构建过程、服务端支持到浏览器渲染等多个方面的优化措施</p>',13)]))}const S=o(a,[["render",i]]);export{u as __pageData,S as default};
