import{_ as a,a as l,o,b0 as t}from"./chunks/framework.BBy0ZaTh.js";const p=JSON.parse('{"title":"前端缓存","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/old/pages/page5.md","filePath":"Interview/old/pages/page5.md","lastUpdated":1751439771000}'),i={name:"Interview/old/pages/page5.md"};function r(d,e,c,n,h,s){return o(),l("div",null,e[0]||(e[0]=[t('<h1 id="前端缓存" tabindex="-1">前端缓存 <a class="header-anchor" href="#前端缓存" aria-label="Permalink to &quot;前端缓存&quot;">​</a></h1><p><a href="../../../.vitepress/theme/pdf/1.pdf" target="_blank">PDF查看流程</a></p><h2 id="一、什么是前端缓存" tabindex="-1">一、什么是前端缓存？ <a class="header-anchor" href="#一、什么是前端缓存" aria-label="Permalink to &quot;一、什么是前端缓存？&quot;">​</a></h2><p>前端缓存是指在客户端（浏览器）或靠近客户端的网络节点中临时存储资源的一种机制。其目的是减少网络请求、提高页面加载速度、减轻服务器压力，从而提升用户体验和性能。</p><hr><h2 id="二、前端缓存的分类" tabindex="-1">二、前端缓存的分类 <a class="header-anchor" href="#二、前端缓存的分类" aria-label="Permalink to &quot;二、前端缓存的分类&quot;">​</a></h2><p>前端缓存主要分为两大类：<strong>HTTP 缓存</strong> 和 <strong>本地存储类缓存</strong>。</p><ul><li>强缓存：完全依赖于浏览器缓存，当缓存未过期时直接使用，不与服务器交互。</li><li>协商缓存：需要与服务器进行交互，确保获取到最新的资源，但相对增加了延迟。</li></ul><h3 id="_1-http-缓存" tabindex="-1">1. HTTP 缓存 <a class="header-anchor" href="#_1-http-缓存" aria-label="Permalink to &quot;1. HTTP 缓存&quot;">​</a></h3><p>这是浏览器默认支持的缓存机制，根据是否需要重新请求服务器可以分为：</p><h4 id="_1-强缓存-strong-cache" tabindex="-1">（1）强缓存（Strong Cache） <a class="header-anchor" href="#_1-强缓存-strong-cache" aria-label="Permalink to &quot;（1）强缓存（Strong Cache）&quot;">​</a></h4><ul><li>浏览器直接从本地缓存读取资源，不向服务器发送请求。</li><li>控制字段： <ul><li><code>Expires</code>（HTTP/1.0）：指定一个绝对时间，表示在此时间前使用缓存。</li><li><code>Cache-Control</code>（HTTP/1.1）：更灵活，优先级高于 <code>Expires</code>。 <ul><li><code>max-age=3600</code>：缓存最大有效时间（单位秒）</li><li><code>no-cache</code>：每次都要验证</li><li><code>no-store</code>：不缓存</li><li><code>public / private</code>：是否允许中间代理缓存</li></ul></li></ul></li></ul><h4 id="_2-协商缓存-revalidate-cache" tabindex="-1">（2）协商缓存（Revalidate Cache） <a class="header-anchor" href="#_2-协商缓存-revalidate-cache" aria-label="Permalink to &quot;（2）协商缓存（Revalidate Cache）&quot;">​</a></h4><ul><li>浏览器发送请求，但服务器判断是否使用缓存。</li><li>控制字段： <ul><li><code>Last-Modified / If-Modified-Since</code></li><li><code>ETag / If-None-Match</code></li></ul></li></ul><blockquote><p>两者的区别：<br><code>Last-Modified</code> 是基于时间的，可能精度不够；<br><code>ETag</code> 是基于资源内容生成的哈希值，更准确。</p></blockquote><h3 id="_2-本地存储类缓存-浏览器本地存储" tabindex="-1">2. 本地存储类缓存（浏览器本地存储） <a class="header-anchor" href="#_2-本地存储类缓存-浏览器本地存储" aria-label="Permalink to &quot;2. 本地存储类缓存（浏览器本地存储）&quot;">​</a></h3><p>这些是开发者主动控制的缓存方式：</p><h4 id="_1-cookie" tabindex="-1">（1）Cookie <a class="header-anchor" href="#_1-cookie" aria-label="Permalink to &quot;（1）Cookie&quot;">​</a></h4><ul><li>存储容量小（约4KB），每次请求都会携带在 HTTP 头中。</li><li>可设置过期时间、作用域等。</li><li>常用于身份认证信息。</li></ul><h4 id="_2-localstorage" tabindex="-1">（2）LocalStorage <a class="header-anchor" href="#_2-localstorage" aria-label="Permalink to &quot;（2）LocalStorage&quot;">​</a></h4><ul><li>容量大（一般5MB左右），持久化存储。</li><li>不会随请求发送到服务器。</li><li>生命周期永久，除非手动清除。</li></ul><h4 id="_3-sessionstorage" tabindex="-1">（3）SessionStorage <a class="header-anchor" href="#_3-sessionstorage" aria-label="Permalink to &quot;（3）SessionStorage&quot;">​</a></h4><ul><li>类似于 LocalStorage，但生命周期仅限当前会话。</li><li>关闭浏览器标签页后数据被清除。</li></ul><h4 id="_4-indexeddb" tabindex="-1">（4）IndexedDB <a class="header-anchor" href="#_4-indexeddb" aria-label="Permalink to &quot;（4）IndexedDB&quot;">​</a></h4><ul><li>浏览器端的 NoSQL 数据库，适合存储大量结构化数据。</li><li>异步操作，不会阻塞主线程。</li><li>支持事务、索引查询等功能。</li></ul><h2 id="三、缓存的应用场景" tabindex="-1">三、缓存的应用场景 <a class="header-anchor" href="#三、缓存的应用场景" aria-label="Permalink to &quot;三、缓存的应用场景&quot;">​</a></h2><table tabindex="0"><thead><tr><th>缓存类型</th><th>适用场景</th></tr></thead><tbody><tr><td><code>强缓存</code></td><td>静态资源如图片、CSS、JS 文件</td></tr><tr><td><code>协商缓存</code></td><td>经常更新但变化不频繁的资源</td></tr><tr><td><code>Cookie</code></td><td>用户登录状态、跟踪信息</td></tr><tr><td><code>LocalStorage</code></td><td>用户偏好设置、离线数据</td></tr><tr><td><code>SessionStorage</code></td><td>页面间临时数据传递</td></tr><tr><td><code>IndexedDB</code></td><td>离线应用、复杂数据存储</td></tr></tbody></table><hr><h2 id="四、如何优化缓存策略" tabindex="-1">四、如何优化缓存策略？ <a class="header-anchor" href="#四、如何优化缓存策略" aria-label="Permalink to &quot;四、如何优化缓存策略？&quot;">​</a></h2><ol><li><p><strong>合理设置 Cache-Control</strong></p><ul><li>对不变资源设置较长的 <code>max-age</code></li><li>对经常变动资源设置 <code>no-cache</code> 或协商缓存</li></ul></li><li><p><strong>版本号控制静态资源</strong></p><ul><li>如：<code>app.js?v=1.0.1</code>，避免缓存污染</li></ul></li><li><p><strong>利用 Service Worker 实现 PWA 缓存</strong></p><ul><li>可拦截请求并自定义缓存策略</li><li>支持离线访问</li></ul></li><li><p><strong>清理旧缓存</strong></p><ul><li>使用 LocalStorage 或 IndexedDB 时注意及时清理无用数据</li></ul></li></ol><hr><h2 id="五、常见问题与解决方案" tabindex="-1">五、常见问题与解决方案 <a class="header-anchor" href="#五、常见问题与解决方案" aria-label="Permalink to &quot;五、常见问题与解决方案&quot;">​</a></h2><ul><li><strong>缓存失效问题</strong>：使用文件指纹（hash）、版本号等方式强制刷新</li><li><strong>缓存污染问题</strong>：不同环境（开发、测试、生产）使用不同的命名空间</li><li><strong>跨域缓存问题</strong>：确保 CORS 设置正确，必要时使用 <code>Vary</code> 响应头</li><li><strong>隐私安全问题</strong>：敏感数据避免使用 LocalStorage，可考虑内存缓存或加密处理</li></ul><hr><h2 id="六、总结" tabindex="-1">六、总结 <a class="header-anchor" href="#六、总结" aria-label="Permalink to &quot;六、总结&quot;">​</a></h2><p>前端缓存是性能优化的重要手段之一。理解各种缓存机制的工作原理及其适用场景，能帮助我们更好地提升网站性能、改善用户体验。同时，也要注意缓存带来的副作用，如缓存过期、一致性等问题，需结合业务需求制定合理的缓存策略。</p>',36)]))}const g=a(i,[["render",r]]);export{p as __pageData,g as default};
