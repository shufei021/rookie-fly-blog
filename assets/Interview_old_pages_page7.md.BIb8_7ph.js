import{_ as a,a as o,o as t,b0 as r}from"./chunks/framework.D10JOWeE.js";const g=JSON.parse('{"title":"ES6 新特性","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/old/pages/page7.md","filePath":"Interview/old/pages/page7.md","lastUpdated":1752997743000}'),c={name:"Interview/old/pages/page7.md"};function d(s,e,n,l,i,h){return t(),o("div",null,e[0]||(e[0]=[r('<h1 id="es6-新特性" tabindex="-1">ES6 新特性 <a class="header-anchor" href="#es6-新特性" aria-label="Permalink to &quot;ES6 新特性&quot;">​</a></h1><p><strong>ES6（ECMAScript 2015）引入了许多新特性，使得JavaScript编程更加便捷和强大。大约15个特性</strong></p><h2 id="let-const" tabindex="-1">let/const <a class="header-anchor" href="#let-const" aria-label="Permalink to &quot;let/const&quot;">​</a></h2><p><strong><code>let</code> / <code>const</code></strong>：<code>let</code>允许你声明一个块级作用域的变量，解决了使用<code>var</code>时存在的变量提升问题。<code>const</code>用于声明常量，一旦赋值就不能再改变。</p><h2 id="箭头函数" tabindex="-1">箭头函数 <a class="header-anchor" href="#箭头函数" aria-label="Permalink to &quot;箭头函数&quot;">​</a></h2><p><strong>箭头函数</strong>：提供了一种更简洁的函数书写方式，如<code>const func = (arg) =&gt; arg * 2;</code>。它还改变了<code>this</code>的绑定规则，通常在回调函数中特别有用。</p><h2 id="模板字符串" tabindex="-1">模板字符串 <a class="header-anchor" href="#模板字符串" aria-label="Permalink to &quot;模板字符串&quot;">​</a></h2><p><strong>模板字符串</strong>：使用反引号(``)定义的字符串，可以嵌入变量或表达式<code>${expression}</code>，方便动态生成字符串内容。</p><h2 id="解构赋值" tabindex="-1">解构赋值 <a class="header-anchor" href="#解构赋值" aria-label="Permalink to &quot;解构赋值&quot;">​</a></h2><p><strong>解构赋值</strong>：可以从数组或对象中提取数据并赋值给变量，例如<code>let {a, b} = {a: 1, b: 2};</code>。</p><h2 id="默认参数" tabindex="-1">默认参数 <a class="header-anchor" href="#默认参数" aria-label="Permalink to &quot;默认参数&quot;">​</a></h2><p><strong>默认参数</strong>：允许为函数的参数设置默认值，如果调用时未传递对应的参数，则使用默认值，如<code>function(a=1){}</code>。</p><h2 id="rest-参数" tabindex="-1">rest 参数 <a class="header-anchor" href="#rest-参数" aria-label="Permalink to &quot;rest 参数&quot;">​</a></h2><p><strong>rest 参数</strong>：使用<code>...</code>前缀的参数可以将不确定数量的参数表示为数组，如<code>function(...args){}</code>。</p><h2 id="扩展运算符" tabindex="-1">扩展运算符 <a class="header-anchor" href="#扩展运算符" aria-label="Permalink to &quot;扩展运算符&quot;">​</a></h2><p><strong>扩展运算符</strong>：与rest参数类似，但用于解构数组或对象，或者是在函数调用时展开数组或对象，如<code>Math.max(...[1, 2, 3])</code>。</p><h2 id="class-类" tabindex="-1">class 类 <a class="header-anchor" href="#class-类" aria-label="Permalink to &quot;class 类&quot;">​</a></h2><p><strong>类</strong>：提供了基于原型的面向对象编程的语法糖，使创建类和继承变得更加直观和简单。</p><h2 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-label="Permalink to &quot;模块化&quot;">​</a></h2><p><strong>模块化</strong>：支持原生的模块导入导出功能，通过<code>import</code>和<code>export</code>关键字实现代码的分割和复用。</p><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-label="Permalink to &quot;Promise&quot;">​</a></h2><p><strong><code>Promise</code></strong>：用于处理异步操作的对象，代表了一个异步操作的最终完成（或失败）及其结果值。</p><h2 id="symbol" tabindex="-1">Symbol <a class="header-anchor" href="#symbol" aria-label="Permalink to &quot;Symbol&quot;">​</a></h2><p><strong><code>Symbol</code></strong>：一种基本数据类型，通常用来创建对象的唯一属性键。</p><h2 id="set-map" tabindex="-1">Set/Map <a class="header-anchor" href="#set-map" aria-label="Permalink to &quot;Set/Map&quot;">​</a></h2><p><strong><code>Set</code> / <code>Map</code></strong>：<code>Set</code>是值的集合，且每个值都是唯一的；<code>Map</code>是一个键值对的集合，键可以是任意类型。</p><h2 id="迭代器与生成器" tabindex="-1">迭代器与生成器 <a class="header-anchor" href="#迭代器与生成器" aria-label="Permalink to &quot;迭代器与生成器&quot;">​</a></h2><p><strong>迭代器与生成器</strong>：迭代器是一种特殊对象，遵循特定协议以供循环遍历；生成器则允许定义一个返回迭代器对象的函数。</p><h2 id="proxy-reflect" tabindex="-1">Proxy/Reflect <a class="header-anchor" href="#proxy-reflect" aria-label="Permalink to &quot;Proxy/Reflect&quot;">​</a></h2><p><strong><code>Proxy</code> / <code>Reflect</code></strong>：<code>Proxy</code>用于创建一个对象的代理，从而拦截并重新定义基本操作（如属性查找、赋值等）。<code>Reflect</code>提供了一些静态方法来执行原本由操作符完成的操作（如<code>.deleteProperty</code>）。</p><h2 id="async-await" tabindex="-1">async/await <a class="header-anchor" href="#async-await" aria-label="Permalink to &quot;async/await&quot;">​</a></h2><p><strong><code>async</code>/<code>await</code></strong>：提供了一种更清晰的方式来处理异步代码，使得异步代码看起来像是同步代码一样易于理解。<code>async</code>函数返回一个<code>Promise</code>，而<code>await</code>等待这个<code>Promise</code>解决。</p>',32)]))}const m=a(c,[["render",d]]);export{g as __pageData,m as default};
