import{_ as a,a as r,o as n,b as e,f as l}from"./chunks/framework.D10JOWeE.js";const f=JSON.parse('{"title":"vue响应式原理是什么？vue3的响应式有何不同","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/vue/pages/page2.md","filePath":"Interview/vue/pages/page2.md","lastUpdated":1753172304000}'),p={name:"Interview/vue/pages/page2.md"};function u(o,t,s,i,c,d){return n(),r("div",null,t[0]||(t[0]=[e("h1",{id:"vue响应式原理是什么-vue3的响应式有何不同",tabindex:"-1"},[l("vue响应式原理是什么？vue3的响应式有何不同 "),e("a",{class:"header-anchor",href:"#vue响应式原理是什么-vue3的响应式有何不同","aria-label":'Permalink to "vue响应式原理是什么？vue3的响应式有何不同"'},"​")],-1),e("p",null,"Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。",-1),e("p",null,"Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。",-1),e("p",null,"Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？",-1),e("p",null,"判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。",-1),e("p",null,"监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？",-1),e("p",null,"我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。",-1)]))}const g=a(p,[["render",u]]);export{f as __pageData,g as default};
