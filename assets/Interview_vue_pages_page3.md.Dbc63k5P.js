import{_ as t,a as i,o as p,b0 as u}from"./chunks/framework.BBy0ZaTh.js";const c=JSON.parse('{"title":"vue3和vue2的区别","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/vue/pages/page3.md","filePath":"Interview/vue/pages/page3.md","lastUpdated":1750206274000}'),a={name:"Interview/vue/pages/page3.md"};function l(r,e,o,s,n,v){return p(),i("div",null,e[0]||(e[0]=[u('<h1 id="vue3和vue2的区别" tabindex="-1">vue3和vue2的区别 <a class="header-anchor" href="#vue3和vue2的区别" aria-label="Permalink to &quot;vue3和vue2的区别&quot;">​</a></h1><ul><li><p>双向绑定的方法不一样： Vue3 使用了new Proxy，Vue2 使用了Object.defineProperty</p></li><li><p>$set 在Vue3中没有，因为 <code>new Proxy</code> 不需要</p></li></ul><ul><li><p>Vue2 是选项式 API，Vue3 向下兼容，可以是 选项式 也可以 是组合式，语法糖 setup</p></li><li><p>Vue2 v-for 优先级大于 v-if，Vue3 是 v-if 大于 v-for</p></li><li><p>源码组织方式变化：使用 TS 重写</p></li><li><p>支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）</p></li><li><p><code>响应式系统提升</code>：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化</p></li><li><p>编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容</p></li><li><p>打包体积优化：移除了一些不常用的api（inline-template、filter）</p></li><li><p>生命周期的变化：使用setup代替了之前的beforeCreate和created</p></li><li><p>Vue3 的 template 模板支持多个根标签</p></li><li><p>Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore</p></li><li><p>Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例</p></li><li><p>Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</p></li><li><p>父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</p></li></ul>',3)]))}const _=t(a,[["render",l]]);export{c as __pageData,_ as default};
