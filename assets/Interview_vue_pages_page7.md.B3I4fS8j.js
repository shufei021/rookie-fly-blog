import{_ as i,a,o as t,b0 as f}from"./chunks/framework.BBy0ZaTh.js";const x=JSON.parse('{"title":"vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/vue/pages/page7.md","filePath":"Interview/vue/pages/page7.md","lastUpdated":1751439771000}'),n={name:"Interview/vue/pages/page7.md"};function r(p,e,d,u,l,o){return t(),a("div",null,e[0]||(e[0]=[f('<h1 id="vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下" tabindex="-1">vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下 <a class="header-anchor" href="#vue2-x-和-vuex3-x-渲染器的-diff-算法分别说一下" aria-label="Permalink to &quot;vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下&quot;">​</a></h1><p>简单来说，diff算法有以下过程</p><ul><li>同级比较，再比较子节点</li><li>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较都有子节点的情况(核心diff)</li><li>递归比较子节点</li></ul><p>正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -&gt; O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p><p>Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p><p>Vue3.x借鉴了 ivi算法和 inferno算法 在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)</p><p>该算法中还运用了动态规划的思想求解最长递归子序列。</p>',7)]))}const _=i(n,[["render",r]]);export{x as __pageData,_ as default};
