import{_ as i,a as s,o as e,b0 as t}from"./chunks/framework.D10JOWeE.js";const c=JSON.parse('{"title":"事件轮询（Event Loop）","description":"","frontmatter":{},"headers":[],"relativePath":"learning/browserNetwork/modules/page2.md","filePath":"learning/browserNetwork/modules/page2.md","lastUpdated":1753172304000}'),l={name:"learning/browserNetwork/modules/page2.md"};function n(o,a,h,r,d,p){return e(),s("div",null,a[0]||(a[0]=[t(`<h1 id="事件轮询-event-loop" tabindex="-1">事件轮询（Event Loop） <a class="header-anchor" href="#事件轮询-event-loop" aria-label="Permalink to &quot;事件轮询（Event Loop）&quot;">​</a></h1><h3 id="一、整体概述" tabindex="-1">一、整体概述 <a class="header-anchor" href="#一、整体概述" aria-label="Permalink to &quot;一、整体概述&quot;">​</a></h3><blockquote><p><strong>一句话总结</strong>： 事件轮询是 JavaScript 引擎用来协调代码执行、处理异步任务的一种机制，确保主线程不会被阻塞，并保证异步操作能按顺序执行。</p></blockquote><p>JavaScript 是单线程语言，意味着同一时间只能做一件事。为了实现异步非阻塞的能力，JavaScript 引擎通过 <strong>调用栈（Call Stack）</strong>、<strong>消息队列（Callback Queue）</strong> 和 <strong>事件循环机制</strong> 来管理任务调度。</p><hr><h3 id="二、核心组成部分与工作流程" tabindex="-1">二、核心组成部分与工作流程 <a class="header-anchor" href="#二、核心组成部分与工作流程" aria-label="Permalink to &quot;二、核心组成部分与工作流程&quot;">​</a></h3><h4 id="_1-调用栈-call-stack" tabindex="-1">1. 调用栈（Call Stack） <a class="header-anchor" href="#_1-调用栈-call-stack" aria-label="Permalink to &quot;1. 调用栈（Call Stack）&quot;">​</a></h4><ul><li>JS 引擎用来记录当前正在执行的函数调用。</li><li>函数调用时入栈，执行完成后出栈。</li></ul><h4 id="_2-浏览器-api-web-apis" tabindex="-1">2. 浏览器 API（Web APIs） <a class="header-anchor" href="#_2-浏览器-api-web-apis" aria-label="Permalink to &quot;2. 浏览器 API（Web APIs）&quot;">​</a></h4><ul><li>包括 <code>setTimeout</code>、<code>setInterval</code>、<code>DOM 事件</code>、<code>fetch</code> 等浏览器原生功能。</li><li>当这些异步操作完成时，它们会将回调函数交给“消息队列”。</li></ul><h4 id="_3-消息队列-callback-queue" tabindex="-1">3. 消息队列（Callback Queue） <a class="header-anchor" href="#_3-消息队列-callback-queue" aria-label="Permalink to &quot;3. 消息队列（Callback Queue）&quot;">​</a></h4><ul><li>存放已经完成异步操作的回调函数。</li><li>例如：<code>setTimeout</code> 到时间后，其回调会被放入这个队列。</li></ul><h4 id="_4-事件循环-event-loop" tabindex="-1">4. 事件循环（Event Loop） <a class="header-anchor" href="#_4-事件循环-event-loop" aria-label="Permalink to &quot;4. 事件循环（Event Loop）&quot;">​</a></h4><ul><li>不断检查调用栈是否为空，如果空了，就从消息队列取出第一个回调推入调用栈执行。</li><li>这就是事件循环的核心逻辑。</li></ul><hr><h3 id="三、宏任务-微任务-microtask" tabindex="-1">三、宏任务 &amp; 微任务（Microtask） <a class="header-anchor" href="#三、宏任务-微任务-microtask" aria-label="Permalink to &quot;三、宏任务 &amp; 微任务（Microtask）&quot;">​</a></h3><p>这是理解事件循环的关键点之一。</p><table tabindex="0"><thead><tr><th>类型</th><th>示例</th><th>特点</th></tr></thead><tbody><tr><td>宏任务（Macro Task）</td><td><code>setTimeout</code>, <code>setInterval</code>, <code>I/O</code>, <code>UI 渲染</code>, <code>script</code> 整体代码</td><td>每次事件循环执行一个宏任务</td></tr><tr><td>微任务（Micro Task）</td><td><code>Promise.then/catch/finally</code>, <code>MutationObserver</code>, <code>queueMicrotask</code></td><td>在当前宏任务结束后立即执行，优先于下一个宏任务</td></tr></tbody></table><h4 id="✅-执行顺序规则" tabindex="-1">✅ 执行顺序规则： <a class="header-anchor" href="#✅-执行顺序规则" aria-label="Permalink to &quot;✅ 执行顺序规则：&quot;">​</a></h4><ol><li>执行同步代码（整个 script 是宏任务）</li><li>同步代码执行完，清空微任务队列</li><li>取出一个宏任务执行，重复上述过程</li></ol><h4 id="🧪-示例说明" tabindex="-1">🧪 示例说明： <a class="header-anchor" href="#🧪-示例说明" aria-label="Permalink to &quot;🧪 示例说明：&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;start&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;setTimeout&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;promise then&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;end&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出顺序：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// start → end → promise then → setTimeout</span></span></code></pre></div><hr><h3 id="四、实际应用和常见问题" tabindex="-1">四、实际应用和常见问题 <a class="header-anchor" href="#四、实际应用和常见问题" aria-label="Permalink to &quot;四、实际应用和常见问题&quot;">​</a></h3><h4 id="_1-为什么-promise-比-settimeout-快" tabindex="-1">1. 为什么 Promise 比 setTimeout 快？ <a class="header-anchor" href="#_1-为什么-promise-比-settimeout-快" aria-label="Permalink to &quot;1. 为什么 Promise 比 setTimeout 快？&quot;">​</a></h4><ul><li>因为 <code>Promise.then</code> 是微任务，会在当前宏任务结束后立即执行；</li><li>而 <code>setTimeout</code> 是宏任务，必须等到下一轮事件循环才会执行。</li></ul><h4 id="_2-微任务堆积问题" tabindex="-1">2. 微任务堆积问题 <a class="header-anchor" href="#_2-微任务堆积问题" aria-label="Permalink to &quot;2. 微任务堆积问题&quot;">​</a></h4><ul><li>如果有大量微任务（如递归调用 <code>Promise.then</code>），会导致页面无法渲染（因为渲染是宏任务），造成“饥饿”现象。</li><li>应避免无限递归微任务。</li></ul><h4 id="_3-dom-更新延迟" tabindex="-1">3. DOM 更新延迟 <a class="header-anchor" href="#_3-dom-更新延迟" aria-label="Permalink to &quot;3. DOM 更新延迟&quot;">​</a></h4><ul><li>DOM 的更新通常发生在宏任务之间，所以即使你修改了 DOM，也可能不会立刻反映到界面上，直到当前宏任务结束。</li></ul><hr><h3 id="五、总结归纳-适合结尾" tabindex="-1">五、总结归纳（适合结尾） <a class="header-anchor" href="#五、总结归纳-适合结尾" aria-label="Permalink to &quot;五、总结归纳（适合结尾）&quot;">​</a></h3><blockquote><p>我可以用一句话总结事件轮询： “<strong>事件轮询负责协调调用栈、消息队列和微任务队列，确保 JavaScript 在单线程下依然可以高效地处理异步操作。</strong>”</p></blockquote><p>掌握事件循环不仅可以帮助我们写出更高效的异步代码，还能解释很多看似奇怪的行为，比如为什么 <code>Promise.then</code> 总比 <code>setTimeout</code> 先执行，以及如何避免微任务堆积等问题。</p><hr><h2 id="🧠-延伸建议-加分项" tabindex="-1">🧠 延伸建议（加分项） <a class="header-anchor" href="#🧠-延伸建议-加分项" aria-label="Permalink to &quot;🧠 延伸建议（加分项）&quot;">​</a></h2><p>如果你在面试中能提到以下内容，会让你脱颖而出：</p><ul><li>Node.js 中的事件循环与浏览器的区别（Node 有多个阶段的宏任务队列）</li><li>使用 <code>queueMicrotask()</code> 或 <code>MutationObserver</code> 实现异步更新</li><li>如何利用微任务实现“异步安全”的状态更新（Vue.next(), React 的 flushSync）</li></ul><hr><h2 id="📝-延申问题" tabindex="-1">📝 延申问题 <a class="header-anchor" href="#📝-延申问题" aria-label="Permalink to &quot;📝 延申问题&quot;">​</a></h2><ol><li><code>setTimeout(fn, 0)</code> 和 <code>Promise.then(fn)</code> 有什么区别？</li><li>如何判断一个任务是宏任务还是微任务？</li><li>什么是事件循环的 tick？</li><li>为什么不能在微任务中频繁操作 DOM？</li><li>微任务队列和回调队列的关系？</li></ol>`,41)]))}const u=i(l,[["render",n]]);export{c as __pageData,u as default};
