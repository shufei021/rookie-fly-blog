import{_ as i,a,o as t,b0 as e}from"./chunks/framework.BBy0ZaTh.js";const c=JSON.parse('{"title":"✅ 什么是 OPTIONS 预检请求？","description":"","frontmatter":{},"headers":[],"relativePath":"learning/browserNetwork/modules/page5.md","filePath":"learning/browserNetwork/modules/page5.md","lastUpdated":1752403471000}'),n={name:"learning/browserNetwork/modules/page5.md"};function l(h,s,o,p,d,r){return t(),a("div",null,s[0]||(s[0]=[e(`<h1 id="✅-什么是-options-预检请求" tabindex="-1">✅ 什么是 OPTIONS 预检请求？ <a class="header-anchor" href="#✅-什么是-options-预检请求" aria-label="Permalink to &quot;✅ 什么是 OPTIONS 预检请求？&quot;">​</a></h1><h3 id="一、一句话总结" tabindex="-1">一、一句话总结 <a class="header-anchor" href="#一、一句话总结" aria-label="Permalink to &quot;一、一句话总结&quot;">​</a></h3><blockquote><p><strong>OPTIONS 请求是浏览器在发送某些跨域请求之前，自动发起的一个“探路”请求，用于确认服务器是否允许该跨域请求，这就是 CORS 中的预检机制（Preflight）。</strong></p></blockquote><h3 id="二、什么时候会触发-options-预检请求" tabindex="-1">二、什么时候会触发 OPTIONS 预检请求？ <a class="header-anchor" href="#二、什么时候会触发-options-预检请求" aria-label="Permalink to &quot;二、什么时候会触发 OPTIONS 预检请求？&quot;">​</a></h3><p>当请求满足以下任意条件时，就会触发预检请求：</p><table tabindex="0"><thead><tr><th>条件</th><th>示例</th></tr></thead><tbody><tr><td>使用了除 <code>GET</code>、<code>HEAD</code>、<code>POST</code> 以外的方法</td><td>如 <code>PUT</code>、<code>DELETE</code>、<code>PATCH</code></td></tr><tr><td>设置了自定义请求头</td><td>如 <code>Authorization</code>、<code>X-Requested-With</code> 等</td></tr><tr><td>设置了 <code>Content-Type</code> 不是以下三种之一</td><td><code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></td></tr></tbody></table><blockquote><p>📌 <strong>注意：</strong> 即使是一个简单的 POST 请求，只要设置了 <code>application/json</code> 的 Content-Type，也会触发预检。</p></blockquote><hr><h3 id="三、options-请求做了什么" tabindex="-1">三、OPTIONS 请求做了什么？ <a class="header-anchor" href="#三、options-请求做了什么" aria-label="Permalink to &quot;三、OPTIONS 请求做了什么？&quot;">​</a></h3><ol><li>浏览器向目标服务器发送一个 <code>OPTIONS</code> 请求。</li><li>请求头中包含： <ul><li><code>Origin</code>：当前页面的源</li><li><code>Access-Control-Request-Method</code>：实际要使用的 HTTP 方法</li><li><code>Access-Control-Request-Headers</code>：实际要设置的请求头字段</li></ul></li><li>服务器根据这些信息决定是否允许请求，并返回相应的响应头： <ul><li><code>Access-Control-Allow-Origin</code></li><li><code>Access-Control-Allow-Methods</code></li><li><code>Access-Control-Allow-Headers</code></li></ul></li><li>如果服务器允许，则浏览器继续发送真正的请求；否则，阻止请求并报错。</li></ol><hr><h3 id="四、为什么需要-options-请求" tabindex="-1">四、为什么需要 OPTIONS 请求？ <a class="header-anchor" href="#四、为什么需要-options-请求" aria-label="Permalink to &quot;四、为什么需要 OPTIONS 请求？&quot;">​</a></h3><p>这是为了防止恶意网站通过 JavaScript 发送一些敏感或破坏性的请求（如 <code>DELETE</code> 删除资源），从而保护服务器安全。</p><blockquote><p>🔒 它是 CORS 安全机制的一部分，确保服务器明确同意接受特定类型的跨域请求。</p></blockquote><hr><h3 id="五、举个例子说明" tabindex="-1">五、举个例子说明 <a class="header-anchor" href="#五、举个例子说明" aria-label="Permalink to &quot;五、举个例子说明&quot;">​</a></h3><p>假设你从 <code>https://a.com</code> 向 <code>https://api.b.com/user/1</code> 发送了一个带 Token 的 PUT 请求：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://api.b.com/user/1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  method: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;PUT&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;application/json&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;Authorization&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Bearer token123&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  body: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">JSON</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Alice&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>浏览器发现这是一个跨域请求，且使用了 <code>PUT</code> 方法和自定义 Header（<code>Authorization</code>），于是会先发送一个 OPTIONS 请求来“探路”。</p><hr><h3 id="六、后端如何配置支持-options-请求" tabindex="-1">六、后端如何配置支持 OPTIONS 请求？ <a class="header-anchor" href="#六、后端如何配置支持-options-请求" aria-label="Permalink to &quot;六、后端如何配置支持 OPTIONS 请求？&quot;">​</a></h3><p>服务端必须正确响应 OPTIONS 请求，返回如下关键头部：</p><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://a.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Methods</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PUT, GET, POST, DELETE</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Headers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Content-Type, Authorization</span></span></code></pre></div><p>否则，浏览器将拒绝后续的实际请求，并提示类似错误：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header present.</span></span></code></pre></div><hr><h3 id="七、常见问题与调试建议" tabindex="-1">七、常见问题与调试建议 <a class="header-anchor" href="#七、常见问题与调试建议" aria-label="Permalink to &quot;七、常见问题与调试建议&quot;">​</a></h3><h4 id="❓-怎么判断是否触发了-options" tabindex="-1">❓ 怎么判断是否触发了 OPTIONS？ <a class="header-anchor" href="#❓-怎么判断是否触发了-options" aria-label="Permalink to &quot;❓ 怎么判断是否触发了 OPTIONS？&quot;">​</a></h4><ul><li>打开 Chrome DevTools 的 Network 面板，查看是否有 <code>OPTIONS</code> 类型的请求。</li><li>如果看到 <code>preflight</code> 标记，说明确实触发了预检。</li></ul><h4 id="❓-options-请求失败怎么办" tabindex="-1">❓ OPTIONS 请求失败怎么办？ <a class="header-anchor" href="#❓-options-请求失败怎么办" aria-label="Permalink to &quot;❓ OPTIONS 请求失败怎么办？&quot;">​</a></h4><ul><li>检查后端是否正确处理了 OPTIONS 请求；</li><li>确保返回了正确的 CORS 响应头；</li><li>检查服务器是否允许对应的 <code>method</code> 和 <code>header</code>。</li></ul><hr><h3 id="八、总结" tabindex="-1">八、总结 <a class="header-anchor" href="#八、总结" aria-label="Permalink to &quot;八、总结&quot;">​</a></h3><blockquote><p>我可以用一句话总结： “<strong>OPTIONS 请求是浏览器在发送复杂跨域请求前的‘通行证’，它确保服务器愿意接受这个请求，是 CORS 安全机制的重要组成部分。</strong>”</p></blockquote><p>掌握 OPTIONS 预检请求的原理，有助于我们更好地理解和解决开发中的跨域问题，尤其是在前后端分离架构中，能够更高效地定位和修复接口通信异常。</p><p>当然可以！以下是针对你之前提到的 <strong>“延伸加分项”</strong> 和 <strong>“面试官可能会追问的问题”</strong> 的简要参考答案，适合在面试中简洁清晰地表达。</p><hr><h2 id="🧠-知识延伸" tabindex="-1">🧠 知识延伸 <a class="header-anchor" href="#🧠-知识延伸" aria-label="Permalink to &quot;🧠 知识延伸&quot;">​</a></h2><h3 id="_1-options-请求是幂等的-可以被缓存" tabindex="-1">1. <strong>OPTIONS 请求是幂等的，可以被缓存</strong> <a class="header-anchor" href="#_1-options-请求是幂等的-可以被缓存" aria-label="Permalink to &quot;1. **OPTIONS 请求是幂等的，可以被缓存**&quot;">​</a></h3><ul><li>是的，OPTIONS 是 HTTP 幂等方法之一。</li><li>浏览器可以通过 <code>Access-Control-Max-Age</code> 头部缓存预检结果，避免重复发送 OPTIONS 请求，提升性能。</li></ul><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Max-Age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 86400  # 表示缓存一天</span></span></code></pre></div><h3 id="_2-node-js-express-中如何配置-options-支持" tabindex="-1">2. <strong>Node.js Express 中如何配置 OPTIONS 支持</strong> <a class="header-anchor" href="#_2-node-js-express-中如何配置-options-支持" aria-label="Permalink to &quot;2. **Node.js Express 中如何配置 OPTIONS 支持**&quot;">​</a></h3><p>使用中间件设置响应头即可：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">app.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Origin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Methods&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;GET, POST, PUT, DELETE, OPTIONS&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Headers&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Content-Type, Authorization&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (req.method </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;OPTIONS&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sendStatus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">204</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 快速返回</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="_3-nginx-中如何设置跨域响应头" tabindex="-1">3. <strong>Nginx 中如何设置跨域响应头</strong> <a class="header-anchor" href="#_3-nginx-中如何设置跨域响应头" aria-label="Permalink to &quot;3. **Nginx 中如何设置跨域响应头**&quot;">​</a></h3><p>在 Nginx 配置文件中添加以下头部：</p><div class="language-nginx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add_header </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Origin&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add_header </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Methods&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;GET, POST, PUT, DELETE, OPTIONS&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add_header </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Access-Control-Allow-Headers&#39;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Content-Type, Authorization&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="_4-微服务中跨域配置统一网关处理的优势" tabindex="-1">4. <strong>微服务中跨域配置统一网关处理的优势</strong> <a class="header-anchor" href="#_4-微服务中跨域配置统一网关处理的优势" aria-label="Permalink to &quot;4. **微服务中跨域配置统一网关处理的优势**&quot;">​</a></h3><ul><li>避免每个服务单独配置 CORS，降低维护成本；</li><li>统一安全策略、日志记录、限流等逻辑；</li><li>提升系统可扩展性和一致性。</li></ul><hr><h2 id="❓-深层次" tabindex="-1">❓ 深层次 <a class="header-anchor" href="#❓-深层次" aria-label="Permalink to &quot;❓ 深层次&quot;">​</a></h2><table tabindex="0"><thead><tr><th>问题</th><th>简要回答</th></tr></thead><tbody><tr><td><strong>1. OPTIONS 请求会携带 Cookie 吗？</strong></td><td>不会。OPTIONS 请求本身不携带 Cookie，但后续实际请求是否带 Cookie 取决于 <code>withCredentials</code> 设置。</td></tr><tr><td><strong>2. 如何避免频繁触发 OPTIONS 请求？</strong></td><td>使用 <code>Access-Control-Max-Age</code> 缓存预检结果，减少重复请求。</td></tr><tr><td><strong>3. OPTIONS 请求失败了怎么排查？</strong></td><td>查看响应头是否包含正确的 CORS 相关字段；检查服务器是否正确处理 OPTIONS 方法；查看后端日志是否有错误。</td></tr><tr><td><strong>4. CORS 中简单请求和非简单请求的区别？</strong></td><td>简单请求不会触发 OPTIONS，如 GET/POST + 标准 Content-Type；非简单请求（如 PUT、DELETE、自定义 Header）会触发预检。</td></tr><tr><td><strong>5. 如何在 Node.js 或 Nginx 中配置跨域？</strong></td><td>Node.js：设置响应头并处理 OPTIONS；Nginx：通过 <code>add_header</code> 添加 CORS 相关字段。</td></tr></tbody></table>`,52)]))}const E=i(n,[["render",l]]);export{c as __pageData,E as default};
