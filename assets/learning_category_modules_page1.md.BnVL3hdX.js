import{_ as s,a,o as e,b0 as l}from"./chunks/framework.D10JOWeE.js";const c=JSON.parse('{"title":"Vite 相关","description":"","frontmatter":{},"headers":[],"relativePath":"learning/category/modules/page1.md","filePath":"learning/category/modules/page1.md","lastUpdated":1752997743000}'),t={name:"learning/category/modules/page1.md"};function n(h,i,o,p,r,d){return e(),a("div",null,i[0]||(i[0]=[l(`<h1 id="vite-相关" tabindex="-1">Vite 相关 <a class="header-anchor" href="#vite-相关" aria-label="Permalink to &quot;Vite 相关&quot;">​</a></h1><p>以下是与 Vite 相关的，涵盖原理、使用、优化等多个方面</p><h2 id="💡-一、vite-基础原理类" tabindex="-1">💡 一、Vite 基础原理类 <a class="header-anchor" href="#💡-一、vite-基础原理类" aria-label="Permalink to &quot;💡 一、Vite 基础原理类&quot;">​</a></h2><h3 id="_1-vite-和-webpack-的核心区别是什么" tabindex="-1">1. <strong>Vite 和 Webpack 的核心区别是什么？</strong> <a class="header-anchor" href="#_1-vite-和-webpack-的核心区别是什么" aria-label="Permalink to &quot;1. **Vite 和 Webpack 的核心区别是什么？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li><p>构建原理不同：</p><ul><li><strong>Vite</strong>：基于原生 ES 模块（ESM），开发环境无需打包，使用浏览器动态加载模块。</li><li><strong>Webpack</strong>：一开始就需要打包所有模块。</li></ul></li><li><p>启动速度：</p><ul><li><strong>Vite</strong>：冷启动快，大文件项目优势明显。</li><li><strong>Webpack</strong>：项目越大，启动越慢。</li></ul></li><li><p>构建工具：</p><ul><li><strong>Vite</strong> 使用 <code>esbuild</code> 和 <code>rollup</code>，其中 <code>esbuild</code> 是用 Go 写的，构建速度快。</li></ul></li><li><p>HMR（热更新）：</p><ul><li>Vite 的 HMR 更快、更轻量，因为是按模块更新。</li></ul></li></ul><hr><h3 id="_2-vite-为什么启动速度快" tabindex="-1">2. <strong>Vite 为什么启动速度快？</strong> <a class="header-anchor" href="#_2-vite-为什么启动速度快" aria-label="Permalink to &quot;2. **Vite 为什么启动速度快？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li>开发时<strong>不打包全部模块</strong>，而是<strong>按需编译和加载</strong>。</li><li>利用浏览器的原生 ES 模块支持（native ESM）。</li><li>使用 <code>esbuild</code> 进行依赖预构建（极快的编译器）。</li><li>缓存机制使得依赖变化时无需重新构建全部模块。</li></ul><hr><h3 id="_3-vite-的构建流程是怎样的" tabindex="-1">3. <strong>Vite 的构建流程是怎样的？</strong> <a class="header-anchor" href="#_3-vite-的构建流程是怎样的" aria-label="Permalink to &quot;3. **Vite 的构建流程是怎样的？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ol><li><p><strong>开发阶段（dev）</strong>：</p><ul><li>解析 HTML 文件</li><li>使用 <code>esbuild</code> 预构建依赖（如 vue、react 等）</li><li>以中间服务器形式拦截请求，按需转换 <code>.ts/.vue</code> 等文件</li><li>浏览器通过原生 ESModule 加载模块</li></ul></li><li><p><strong>构建阶段（build）</strong>：</p><ul><li>使用 <code>rollup</code> 进行打包构建</li><li>支持代码分割、tree-shaking、压缩等优化</li></ul></li></ol><hr><h3 id="_4-vite-为什么要使用-esbuild" tabindex="-1">4. <strong>Vite 为什么要使用 esbuild？</strong> <a class="header-anchor" href="#_4-vite-为什么要使用-esbuild" aria-label="Permalink to &quot;4. **Vite 为什么要使用 esbuild？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li><code>esbuild</code> 是 Go 编写的构建工具，性能比 babel 快 10-100 倍。</li><li>用于<strong>依赖预构建</strong>和开发环境下的<strong>语法转译</strong>，大大提升启动速度。</li><li>构建阶段仍使用 <code>rollup</code>，兼顾速度和灵活性。</li></ul><hr><h3 id="_5-vite-支持哪些前端框架" tabindex="-1">5. <strong>Vite 支持哪些前端框架？</strong> <a class="header-anchor" href="#_5-vite-支持哪些前端框架" aria-label="Permalink to &quot;5. **Vite 支持哪些前端框架？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li>Vue（官方提供 <code>@vitejs/plugin-vue</code>）</li><li>React（官方提供 <code>@vitejs/plugin-react</code>）</li><li>Svelte、Solid、Lit 等现代框架</li><li>也支持 VanillaJS、TypeScript、PReact、以及 SSR</li></ul><hr><h2 id="⚙️-二、配置与插件类" tabindex="-1">⚙️ 二、配置与插件类 <a class="header-anchor" href="#⚙️-二、配置与插件类" aria-label="Permalink to &quot;⚙️ 二、配置与插件类&quot;">​</a></h2><h3 id="_6-vite-配置文件默认文件名是什么-是否支持多个环境配置" tabindex="-1">6. <strong>Vite 配置文件默认文件名是什么？是否支持多个环境配置？</strong> <a class="header-anchor" href="#_6-vite-配置文件默认文件名是什么-是否支持多个环境配置" aria-label="Permalink to &quot;6. **Vite 配置文件默认文件名是什么？是否支持多个环境配置？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li><p>默认配置文件：<code>vite.config.ts</code> / <code>vite.config.js</code></p></li><li><p>支持不同环境配置文件：</p><ul><li><code>.env</code>、<code>.env.development</code>、<code>.env.production</code></li><li>可通过 <code>import.meta.env</code> 访问环境变量</li></ul></li></ul><hr><h3 id="_7-如何在-vite-中使用别名-alias" tabindex="-1">7. <strong>如何在 Vite 中使用别名 alias？</strong> <a class="header-anchor" href="#_7-如何在-vite-中使用别名-alias" aria-label="Permalink to &quot;7. **如何在 Vite 中使用别名 alias？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vite.config.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { defineConfig } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vite&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;path&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  resolve: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    alias: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;@&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;src&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><hr><h3 id="_8-如何在-vite-中使用插件机制" tabindex="-1">8. <strong>如何在 Vite 中使用插件机制？</strong> <a class="header-anchor" href="#_8-如何在-vite-中使用插件机制" aria-label="Permalink to &quot;8. **如何在 Vite 中使用插件机制？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li>插件机制类似于 Rollup 插件体系，使用 <code>plugins</code> 配置。</li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@vitejs/plugin-vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ul><li><p>插件可以实现：</p><ul><li>文件解析（transform）</li><li>热更新（handleHotUpdate）</li><li>服务启动钩子（configureServer）等</li></ul></li></ul><hr><h3 id="_9-如何设置-vite-的跨域代理" tabindex="-1">9. <strong>如何设置 Vite 的跨域代理？</strong> <a class="header-anchor" href="#_9-如何设置-vite-的跨域代理" aria-label="Permalink to &quot;9. **如何设置 Vite 的跨域代理？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vite.config.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  server: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    proxy: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;/api&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        target: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;https://backend.com&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        changeOrigin: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        rewrite</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#22863A;--shiki-light-font-weight:bold;--shiki-dark:#85E89D;--shiki-dark-font-weight:bold;">\\/</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">api</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><hr><h2 id="🚀-三、优化与进阶类" tabindex="-1">🚀 三、优化与进阶类 <a class="header-anchor" href="#🚀-三、优化与进阶类" aria-label="Permalink to &quot;🚀 三、优化与进阶类&quot;">​</a></h2><h3 id="_10-vite-中的依赖预构建-pre-bundling-机制是什么" tabindex="-1">10. <strong>Vite 中的依赖预构建（pre-bundling）机制是什么？</strong> <a class="header-anchor" href="#_10-vite-中的依赖预构建-pre-bundling-机制是什么" aria-label="Permalink to &quot;10. **Vite 中的依赖预构建（pre-bundling）机制是什么？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li>默认使用 <code>esbuild</code> 对 <code>node_modules</code> 中的依赖进行预构建（提升冷启动性能）。</li><li>会生成 <code>.vite/deps</code> 缓存。</li><li>可通过 <code>optimizeDeps.include/exclude</code> 手动配置预构建的包。</li></ul><hr><h3 id="_11-如何解决-vite-构建产物过大或慢的问题" tabindex="-1">11. <strong>如何解决 Vite 构建产物过大或慢的问题？</strong> <a class="header-anchor" href="#_11-如何解决-vite-构建产物过大或慢的问题" aria-label="Permalink to &quot;11. **如何解决 Vite 构建产物过大或慢的问题？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li>使用 <code>build.rollupOptions.output.manualChunks</code> 手动分包</li><li>利用 <code>dynamic import</code> 进行代码分割</li><li>压缩第三方库</li><li>优化图片、SVG、字体等静态资源</li><li>减少不必要的插件</li></ul><hr><h3 id="_12-vite-的-hmr-热更新原理简述" tabindex="-1">12. <strong>Vite 的 HMR 热更新原理简述？</strong> <a class="header-anchor" href="#_12-vite-的-hmr-热更新原理简述" aria-label="Permalink to &quot;12. **Vite 的 HMR 热更新原理简述？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li>基于 WebSocket 与浏览器通信</li><li>当文件变化后，只更新变化的模块，不刷新整个页面</li><li>利用模块之间的依赖关系，实现模块热替换（类似 Vue 的 <code>hot.accept()</code>）</li></ul><hr><h2 id="🔐-四、兼容性与部署类" tabindex="-1">🔐 四、兼容性与部署类 <a class="header-anchor" href="#🔐-四、兼容性与部署类" aria-label="Permalink to &quot;🔐 四、兼容性与部署类&quot;">​</a></h2><h3 id="_13-vite-构建后能在-ie-上运行吗" tabindex="-1">13. <strong>Vite 构建后能在 IE 上运行吗？</strong> <a class="header-anchor" href="#_13-vite-构建后能在-ie-上运行吗" aria-label="Permalink to &quot;13. **Vite 构建后能在 IE 上运行吗？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li>默认不支持 IE（因为使用了原生 ES Module 和现代语法）</li><li>可使用插件如 <code>vite-plugin-legacy</code> 提供兼容性构建：</li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> legacy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@vitejs/plugin-legacy&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    legacy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      targets: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;defaults&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;not IE 11&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><hr><h3 id="_14-vite-打包后的静态资源如何部署" tabindex="-1">14. <strong>Vite 打包后的静态资源如何部署？</strong> <a class="header-anchor" href="#_14-vite-打包后的静态资源如何部署" aria-label="Permalink to &quot;14. **Vite 打包后的静态资源如何部署？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li>执行 <code>vite build</code> 会生成 <code>dist/</code> 目录</li><li>将其部署到静态服务器（如 Nginx、Vercel、Netlify）</li><li>可配置 <code>base</code> 路径用于 CDN 或子目录部署：</li></ul><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defineConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  base: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/my-app/&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 部署到 mydomain.com/my-app/</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><hr><h3 id="_15-如何在-vite-项目中启用-ssr-服务端渲染" tabindex="-1">15. <strong>如何在 Vite 项目中启用 SSR（服务端渲染）？</strong> <a class="header-anchor" href="#_15-如何在-vite-项目中启用-ssr-服务端渲染" aria-label="Permalink to &quot;15. **如何在 Vite 项目中启用 SSR（服务端渲染）？**&quot;">​</a></h3><p><strong>参考答案：</strong></p><ul><li>Vite 官方支持 SSR 模式（见 <a href="https://vitejs.dev/guide/ssr.html%EF%BC%89" target="_blank" rel="noreferrer">https://vitejs.dev/guide/ssr.html）</a></li><li>项目结构需拆分为 <code>server</code> 与 <code>client</code> 两端</li><li>SSR 中可使用 <code>vite.createServer()</code> 动态注入模块，支持热更新与按需构建</li></ul><hr><p>以下是一套为<strong>前端面试准备的 Vite 口述问答题模板</strong>，每道题包含了：</p><ul><li>✅【题目】</li><li>💬【答题结构提示】</li><li>🧠【模拟口述回答（简洁有逻辑）】</li></ul><hr><h2 id="📘-一、基础原理类" tabindex="-1">📘 一、基础原理类 <a class="header-anchor" href="#📘-一、基础原理类" aria-label="Permalink to &quot;📘 一、基础原理类&quot;">​</a></h2><hr><h3 id="✅【题目1】vite-是什么-解决了哪些痛点" tabindex="-1">✅【题目1】Vite 是什么？解决了哪些痛点？ <a class="header-anchor" href="#✅【题目1】vite-是什么-解决了哪些痛点" aria-label="Permalink to &quot;✅【题目1】Vite 是什么？解决了哪些痛点？&quot;">​</a></h3><p>💬结构提示：</p><ul><li>定义</li><li>核心优势</li><li>解决的问题</li></ul><p>🧠模拟口述回答：</p><blockquote><p>Vite 是一个由 Evan You 开发的前端构建工具，主打极速启动和开发体验。它通过利用浏览器原生的 ES Module 机制，在开发阶段不再需要打包，从而大大提升启动速度。同时，它使用 esbuild 预构建依赖，用 Rollup 进行生产构建，兼顾了开发效率和产物优化。 Vite 主要解决了传统打包工具启动慢、热更新卡顿、配置繁琐等问题。</p></blockquote><hr><h3 id="✅【题目2】vite-和-webpack-的区别有哪些" tabindex="-1">✅【题目2】Vite 和 Webpack 的区别有哪些？ <a class="header-anchor" href="#✅【题目2】vite-和-webpack-的区别有哪些" aria-label="Permalink to &quot;✅【题目2】Vite 和 Webpack 的区别有哪些？&quot;">​</a></h3><p>💬结构提示：</p><ul><li>启动原理</li><li>打包方式</li><li>热更新</li><li>插件生态</li></ul><p>🧠模拟口述回答：</p><blockquote><p>Vite 开发时不打包，而 Webpack 需要先打包全部模块。Vite 利用浏览器原生 ESModule 按需加载，Webpack 用的是 CommonJS 或打包成 bundle。 热更新方面，Vite 精准更新受影响模块，而 Webpack 热更新粒度更粗。 插件上，Vite 用的是 Rollup 插件体系，相对轻量，而 Webpack 插件功能更强但复杂。 总体来说，Vite 更适合现代框架的开发场景，启动更快。</p></blockquote><hr><h3 id="✅【题目3】为什么-vite-冷启动快" tabindex="-1">✅【题目3】为什么 Vite 冷启动快？ <a class="header-anchor" href="#✅【题目3】为什么-vite-冷启动快" aria-label="Permalink to &quot;✅【题目3】为什么 Vite 冷启动快？&quot;">​</a></h3><p>💬结构提示：</p><ul><li>按需加载</li><li>预构建机制</li><li>esbuild</li></ul><p>🧠模拟口述回答：</p><blockquote><p>Vite 冷启动快，主要是因为开发阶段不打包项目源码，只在浏览器请求时按需加载和转换模块。同时，Vite 使用 esbuild 对依赖库进行预构建，比传统 JS 打包器快几十倍。 这就避免了一开始全量打包的过程，大大提升了开发体验。</p></blockquote><hr><h2 id="⚙️-二、配置使用类" tabindex="-1">⚙️ 二、配置使用类 <a class="header-anchor" href="#⚙️-二、配置使用类" aria-label="Permalink to &quot;⚙️ 二、配置使用类&quot;">​</a></h2><hr><h3 id="✅【题目4】vite-中如何配置环境变量" tabindex="-1">✅【题目4】Vite 中如何配置环境变量？ <a class="header-anchor" href="#✅【题目4】vite-中如何配置环境变量" aria-label="Permalink to &quot;✅【题目4】Vite 中如何配置环境变量？&quot;">​</a></h3><p>💬结构提示：</p><ul><li><code>.env</code> 文件</li><li><code>import.meta.env</code> 使用方式</li><li>命名规范</li></ul><p>🧠模拟口述回答：</p><blockquote><p>Vite 支持多环境配置文件，例如 <code>.env.development</code>、<code>.env.production</code>。我们可以通过 <code>VITE_</code> 前缀来定义环境变量，比如 <code>VITE_API_URL</code>。 在代码中通过 <code>import.meta.env.VITE_API_URL</code> 来访问。这样就可以根据不同环境注入对应配置。</p></blockquote><hr><h3 id="✅【题目5】如何在-vite-项目中配置路径别名" tabindex="-1">✅【题目5】如何在 Vite 项目中配置路径别名？ <a class="header-anchor" href="#✅【题目5】如何在-vite-项目中配置路径别名" aria-label="Permalink to &quot;✅【题目5】如何在 Vite 项目中配置路径别名？&quot;">​</a></h3><p>💬结构提示：</p><ul><li><code>resolve.alias</code> 的用法</li><li>配合 TypeScript 时需要注意 tsconfig</li></ul><p>🧠模拟口述回答：</p><blockquote><p>在 <code>vite.config.ts</code> 中使用 <code>resolve.alias</code> 可以配置路径别名，例如 <code>@</code> 指向 <code>src</code> 目录。代码中就可以用 <code>@/components</code> 替代相对路径。 同时，如果使用 TypeScript，还需要在 <code>tsconfig.json</code> 中同步配置 <code>paths</code> 字段保持一致。</p></blockquote><hr><h3 id="✅【题目6】vite-如何配置代理解决跨域" tabindex="-1">✅【题目6】Vite 如何配置代理解决跨域？ <a class="header-anchor" href="#✅【题目6】vite-如何配置代理解决跨域" aria-label="Permalink to &quot;✅【题目6】Vite 如何配置代理解决跨域？&quot;">​</a></h3><p>💬结构提示：</p><ul><li><code>server.proxy</code> 用法</li><li>rewrite 和 changeOrigin 含义</li></ul><p>🧠模拟口述回答：</p><blockquote><p>Vite 提供了内置的开发服务器代理功能，通过 <code>server.proxy</code> 配置项可以设置代理规则。比如 <code>/api</code> 请求可以转发到后端服务器，同时通过 <code>rewrite</code> 去除前缀。 设置 <code>changeOrigin: true</code> 可以伪装请求头，解决跨域问题。</p></blockquote><hr><h2 id="🚀-三、性能优化与构建类" tabindex="-1">🚀 三、性能优化与构建类 <a class="header-anchor" href="#🚀-三、性能优化与构建类" aria-label="Permalink to &quot;🚀 三、性能优化与构建类&quot;">​</a></h2><hr><h3 id="✅【题目7】vite-的依赖预构建机制是怎样的" tabindex="-1">✅【题目7】Vite 的依赖预构建机制是怎样的？ <a class="header-anchor" href="#✅【题目7】vite-的依赖预构建机制是怎样的" aria-label="Permalink to &quot;✅【题目7】Vite 的依赖预构建机制是怎样的？&quot;">​</a></h3><p>💬结构提示：</p><ul><li>esbuild 的作用</li><li>预构建触发的时机</li><li>缓存机制</li></ul><p>🧠模拟口述回答：</p><blockquote><p>Vite 使用 esbuild 对 <code>node_modules</code> 中的依赖库进行一次性预构建，将其转为 ESM 格式并缓存到 <code>.vite/deps</code>。这一步在项目首次启动或依赖变化时发生。 这样可以加快浏览器加载速度，同时避免重复转译。</p></blockquote><hr><h3 id="✅【题目8】vite-如何进行构建优化" tabindex="-1">✅【题目8】Vite 如何进行构建优化？ <a class="header-anchor" href="#✅【题目8】vite-如何进行构建优化" aria-label="Permalink to &quot;✅【题目8】Vite 如何进行构建优化？&quot;">​</a></h3><p>💬结构提示：</p><ul><li>分包策略（manualChunks）</li><li>资源压缩</li><li>CDN 配置（base）</li><li>构建参数</li></ul><p>🧠模拟口述回答：</p><blockquote><p>构建阶段可以通过 <code>rollupOptions.output.manualChunks</code> 进行手动分包，减少主包体积。 Vite 默认会压缩代码，也可以通过插件压缩图片等资源。 此外，还能设置 <code>base</code> 来适配部署在子路径或使用 CDN。通过合理配置这些项，可以大大提升加载速度。</p></blockquote><hr><h2 id="🔐-四、兼容性与扩展类" tabindex="-1">🔐 四、兼容性与扩展类 <a class="header-anchor" href="#🔐-四、兼容性与扩展类" aria-label="Permalink to &quot;🔐 四、兼容性与扩展类&quot;">​</a></h2><hr><h3 id="✅【题目9】vite-是否支持-ie-浏览器-怎么兼容" tabindex="-1">✅【题目9】Vite 是否支持 IE 浏览器？怎么兼容？ <a class="header-anchor" href="#✅【题目9】vite-是否支持-ie-浏览器-怎么兼容" aria-label="Permalink to &quot;✅【题目9】Vite 是否支持 IE 浏览器？怎么兼容？&quot;">​</a></h3><p>💬结构提示：</p><ul><li>默认不支持</li><li>插件方式兼容</li></ul><p>🧠模拟口述回答：</p><blockquote><p>默认情况下，Vite 不支持 IE，因为使用了原生 ES 模块和现代语法。 但可以使用 <code>@vitejs/plugin-legacy</code> 插件，为老浏览器生成 polyfill 和兼容代码，实现一定程度的兼容。</p></blockquote><hr><h3 id="✅【题目10】vite-插件机制是怎样的-和-webpack-有什么不同" tabindex="-1">✅【题目10】Vite 插件机制是怎样的？和 Webpack 有什么不同？ <a class="header-anchor" href="#✅【题目10】vite-插件机制是怎样的-和-webpack-有什么不同" aria-label="Permalink to &quot;✅【题目10】Vite 插件机制是怎样的？和 Webpack 有什么不同？&quot;">​</a></h3><p>💬结构提示：</p><ul><li>插件生命周期</li><li>插件来源</li><li>区别</li></ul><p>🧠模拟口述回答：</p><blockquote><p>Vite 的插件体系基于 Rollup 插件机制，也扩展了一些开发服务器相关钩子，比如 <code>configureServer</code>、<code>transformIndexHtml</code>。 插件可以处理文件转换、服务启动、热更新等功能。 相较于 Webpack，Vite 插件更加轻量、组合性更强，也更接近函数式。</p></blockquote><hr><h2 id="🎯-五、附加题-加分项" tabindex="-1">🎯 五、附加题（加分项） <a class="header-anchor" href="#🎯-五、附加题-加分项" aria-label="Permalink to &quot;🎯 五、附加题（加分项）&quot;">​</a></h2><hr><h3 id="✅【题目11】如何使用-vite-做-ssr-项目" tabindex="-1">✅【题目11】如何使用 Vite 做 SSR 项目？ <a class="header-anchor" href="#✅【题目11】如何使用-vite-做-ssr-项目" aria-label="Permalink to &quot;✅【题目11】如何使用 Vite 做 SSR 项目？&quot;">​</a></h3><p>💬结构提示：</p><ul><li>Vite 提供 API</li><li>服务端渲染入口</li><li>动态模块加载</li></ul><p>🧠模拟口述回答：</p><blockquote><p>Vite 提供 <code>createServer</code> API，可以集成到 Node 服务中，结合 Express 或 Koa 实现 SSR。 在开发时，Vite 会动态加载组件代码并提供热更新；在生产环境，则可以使用打包产物结合模板进行服务端渲染。Vue 和 React 都有对应的 SSR 方案。</p></blockquote><hr><h2 id="✅-如何使用这套模板" tabindex="-1">✅ 如何使用这套模板？ <a class="header-anchor" href="#✅-如何使用这套模板" aria-label="Permalink to &quot;✅ 如何使用这套模板？&quot;">​</a></h2><ul><li>每题<strong>按关键词结构</strong>口述</li><li>模拟真实面试时<strong>用简洁语气</strong>回答</li><li>可练习自我提问 + 回答 + 延展追问（比如“能举个例子吗？”）</li></ul>`,151)]))}const u=s(t,[["render",n]]);export{c as __pageData,u as default};
