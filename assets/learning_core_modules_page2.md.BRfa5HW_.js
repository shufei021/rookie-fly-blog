import{_ as i,a,o as t,b0 as n}from"./chunks/framework.BBy0ZaTh.js";const c=JSON.parse('{"title":"箭头函数 vs 普通函数","description":"","frontmatter":{},"headers":[],"relativePath":"learning/core/modules/page2.md","filePath":"learning/core/modules/page2.md","lastUpdated":1752408143000}'),e={name:"learning/core/modules/page2.md"};function l(h,s,p,r,k,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="箭头函数-vs-普通函数" tabindex="-1">箭头函数 vs 普通函数 <a class="header-anchor" href="#箭头函数-vs-普通函数" aria-label="Permalink to &quot;箭头函数 vs 普通函数&quot;">​</a></h1><blockquote><p>在现代 JavaScript 中，箭头函数（Arrow Functions）和普通函数（Function Declarations/Expressions）是两种定义函数的方式，它们在语法、用途以及行为上有一些关键的不同点。以下是它们的主要区别：</p></blockquote><h3 id="一、语法差异" tabindex="-1">一、语法差异 <a class="header-anchor" href="#一、语法差异" aria-label="Permalink to &quot;一、语法差异&quot;">​</a></h3><ul><li><p><strong>普通函数</strong>： 普通函数的定义方式较为传统，既可以作为函数声明也可以作为函数表达式使用。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>箭头函数</strong>： 箭头函数提供了一种更加简洁的语法来定义函数，尤其适用于简短的函数体。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span></code></pre></div></li></ul><h3 id="二、this-绑定" tabindex="-1">二、<code>this</code> 绑定 <a class="header-anchor" href="#二、this-绑定" aria-label="Permalink to &quot;二、\`this\` 绑定&quot;">​</a></h3><ul><li><p><strong>普通函数</strong>：<code>this</code> 的值取决于函数如何被调用。它可能指向全局对象（在非严格模式下），当前实例（对于方法），或 <code>undefined</code>（在严格模式下）。</p></li><li><p><strong>箭头函数</strong>：箭头函数不绑定自己的 <code>this</code> 值；相反，它会捕获并使用其定义时所在上下文的 <code>this</code> 值。这意味着箭头函数内部的 <code>this</code> 值与外部作用域中的 <code>this</code> 相同。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  regularFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this points to obj</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  arrowFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this points to the outer scope&#39;s this value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div></li></ul><h3 id="三、构造函数" tabindex="-1">三、构造函数 <a class="header-anchor" href="#三、构造函数" aria-label="Permalink to &quot;三、构造函数&quot;">​</a></h3><ul><li><p><strong>普通函数</strong>：可以作为构造函数使用，通过 <code>new</code> 关键字创建对象实例。</p></li><li><p><strong>箭头函数</strong>：不能用作构造函数，尝试使用 <code>new</code> 关键字调用箭头函数将抛出错误。</p></li></ul><h3 id="四、参数处理" tabindex="-1">四、参数处理 <a class="header-anchor" href="#四、参数处理" aria-label="Permalink to &quot;四、参数处理&quot;">​</a></h3><ul><li><p><strong>普通函数</strong>：支持 <code>arguments</code> 对象，它是一个类数组对象，包含传递给函数的所有参数。</p></li><li><p><strong>箭头函数</strong>：不拥有 <code>arguments</code> 对象，但可以通过剩余参数（rest parameters）实现类似功能。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> regularFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">arguments</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> arrowFunc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(args);</span></span></code></pre></div></li></ul><h3 id="五、原型属性" tabindex="-1">五、原型属性 <a class="header-anchor" href="#五、原型属性" aria-label="Permalink to &quot;五、原型属性&quot;">​</a></h3><ul><li><p><strong>普通函数</strong>：具有一个 <code>prototype</code> 属性，这对于基于原型的继承很重要。</p></li><li><p><strong>箭头函数</strong>：没有 <code>prototype</code> 属性。</p></li></ul><h3 id="六、super" tabindex="-1">六、super <a class="header-anchor" href="#六、super" aria-label="Permalink to &quot;六、super&quot;">​</a></h3><ul><li><p><strong>普通函数</strong>：能通过super继承父类的属性和方法</p></li><li><p><strong>箭头函数</strong>：不能通过super继承父类的属性和方法</p></li></ul><h3 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h3><ul><li><p><strong>普通函数</strong>：适用于需要动态 <code>this</code> 值的场景，如对象的方法、构造函数等。</p></li><li><p><strong>箭头函数</strong>：更适合用于匿名函数表达式，特别是当需要访问父级作用域的 <code>this</code> 值时，比如在回调函数中。</p></li></ul><h3 id="总结对比表" tabindex="-1">总结对比表： <a class="header-anchor" href="#总结对比表" aria-label="Permalink to &quot;总结对比表：&quot;">​</a></h3><table tabindex="0"><thead><tr><th>特性</th><th>普通函数</th><th>箭头函数</th></tr></thead><tbody><tr><td>语法</td><td>更加冗长</td><td>更为简洁</td></tr><tr><td><code>this</code> 绑定</td><td>动态绑定，依赖于调用方式</td><td>静态绑定，继承自外层作用域</td></tr><tr><td>构造函数</td><td>可以使用 <code>new</code> 创建实例</td><td>不允许使用 <code>new</code></td></tr><tr><td><code>arguments</code> 对象</td><td>支持</td><td>不直接支持，但可通过 rest 参数替代</td></tr><tr><td><code>prototype</code> 属性</td><td>存在</td><td>不存在</td></tr><tr><td>super</td><td>能</td><td>不能</td></tr></tbody></table>`,18)]))}const g=i(e,[["render",l]]);export{c as __pageData,g as default};
