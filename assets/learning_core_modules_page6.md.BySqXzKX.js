import{_ as i,a,o as t,b0 as n}from"./chunks/framework.BBy0ZaTh.js";const E=JSON.parse('{"title":"CommonJS 与模块化","description":"","frontmatter":{},"headers":[],"relativePath":"learning/core/modules/page6.md","filePath":"learning/core/modules/page6.md","lastUpdated":1752408143000}'),e={name:"learning/core/modules/page6.md"};function h(l,s,p,k,o,r){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="commonjs-与模块化" tabindex="-1">CommonJS 与模块化 <a class="header-anchor" href="#commonjs-与模块化" aria-label="Permalink to &quot;CommonJS 与模块化&quot;">​</a></h1><h2 id="🧠-一、什么是模块化" tabindex="-1">🧠 一、什么是模块化？ <a class="header-anchor" href="#🧠-一、什么是模块化" aria-label="Permalink to &quot;🧠 一、什么是模块化？&quot;">​</a></h2><p>模块化是一种将代码划分为独立、可复用部分的编程范式。它的目的是：</p><ul><li><strong>解耦</strong>：减少模块之间的依赖</li><li><strong>可维护性</strong>：便于调试和更新</li><li><strong>复用性</strong>：可以在多个项目中重复使用</li></ul><p>JavaScript 原生并不支持模块化，直到 ES6 才正式引入模块标准（ES Module）。</p><hr><h2 id="📦-二、commonjs-是什么" tabindex="-1">📦 二、CommonJS 是什么？ <a class="header-anchor" href="#📦-二、commonjs-是什么" aria-label="Permalink to &quot;📦 二、CommonJS 是什么？&quot;">​</a></h2><p><strong>CommonJS</strong> 是一种模块化规范，最初是为了解决 Node.js 中的模块问题而提出的。</p><h3 id="特点" tabindex="-1">特点： <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点：&quot;">​</a></h3><ul><li>使用 <code>require()</code> 同步加载模块</li><li>使用 <code>module.exports</code> 和 <code>exports</code> 导出模块</li><li>主要用于服务端（Node.js）</li></ul><h3 id="示例" tabindex="-1">示例： <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例：&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// math.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或者</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> math</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./math&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span></code></pre></div><h3 id="优点" tabindex="-1">优点： <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点：&quot;">​</a></h3><ul><li>简单易懂，语法清晰</li><li>Node.js 的默认模块系统</li></ul><h3 id="缺点" tabindex="-1">缺点： <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点：&quot;">​</a></h3><ul><li><strong>同步加载</strong>，不适合浏览器环境</li><li>不利于异步加载或按需加载</li></ul><hr><h2 id="🌐-三、es-module-esm" tabindex="-1">🌐 三、ES Module（ESM） <a class="header-anchor" href="#🌐-三、es-module-esm" aria-label="Permalink to &quot;🌐 三、ES Module（ESM）&quot;">​</a></h2><p>ES6 引入了官方模块系统 —— <strong>ECMAScript Module（ESM）</strong></p><h3 id="特点-1" tabindex="-1">特点： <a class="header-anchor" href="#特点-1" aria-label="Permalink to &quot;特点：&quot;">​</a></h3><ul><li>使用 <code>import</code> / <code>export</code> 语法</li><li>支持异步加载</li><li>静态分析能力强，适合 Tree Shaking</li></ul><h3 id="示例-1" tabindex="-1">示例： <a class="header-anchor" href="#示例-1" aria-label="Permalink to &quot;示例：&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// math.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { add } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./math.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><h3 id="优点-1" tabindex="-1">优点： <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点：&quot;">​</a></h3><ul><li>官方标准，未来主流</li><li>支持异步加载</li><li>可以做静态优化（如 Tree Shaking）</li></ul><h3 id="缺点-1" tabindex="-1">缺点： <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点：&quot;">​</a></h3><ul><li>浏览器兼容性早期较差（现已广泛支持）</li><li>不能直接在旧版 Node.js 中使用（需要配置 type=&quot;module&quot;）</li></ul><hr><h2 id="🔁-四、commonjs-与-esm-的区别" tabindex="-1">🔁 四、CommonJS 与 ESM 的区别 <a class="header-anchor" href="#🔁-四、commonjs-与-esm-的区别" aria-label="Permalink to &quot;🔁 四、CommonJS 与 ESM 的区别&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>CommonJS</th><th>ESM</th></tr></thead><tbody><tr><td>加载方式</td><td>同步</td><td>异步</td></tr><tr><td>语法</td><td><code>require()</code> / <code>module.exports</code></td><td><code>import</code> / <code>export</code></td></tr><tr><td>运行环境</td><td>Node.js</td><td>浏览器 &amp; Node.js</td></tr><tr><td>是否可动态导入</td><td>✅</td><td>❌（但可通过 <code>import()</code> 动态加载）</td></tr><tr><td>是否支持 Tree Shaking</td><td>❌</td><td>✅</td></tr></tbody></table><hr><h2 id="🚀-五、模块化的发展历史简述" tabindex="-1">🚀 五、模块化的发展历史简述 <a class="header-anchor" href="#🚀-五、模块化的发展历史简述" aria-label="Permalink to &quot;🚀 五、模块化的发展历史简述&quot;">​</a></h2><ol><li><strong>无模块时代</strong>：全局变量污染严重</li><li><strong>IIFE（立即执行函数）</strong>：解决命名冲突</li><li><strong>AMD（Asynchronous Module Definition）</strong>：适用于浏览器，如 RequireJS</li><li><strong>CMD（Common Module Definition）</strong>：SeaJS 提出，类似 AMD</li><li><strong>CommonJS</strong>：Node.js 默认模块系统</li><li><strong>ES Module（ES6）</strong>：现代 JS 标准模块系统</li></ol><hr><h2 id="💡-六、实际应用中的选择建议" tabindex="-1">💡 六、实际应用中的选择建议 <a class="header-anchor" href="#💡-六、实际应用中的选择建议" aria-label="Permalink to &quot;💡 六、实际应用中的选择建议&quot;">​</a></h2><table tabindex="0"><thead><tr><th>场景</th><th>推荐模块系统</th></tr></thead><tbody><tr><td>Node.js 项目（旧版本）</td><td>CommonJS</td></tr><tr><td>Node.js 项目（v14+）</td><td>ESM（推荐）</td></tr><tr><td>Web 项目（现代框架如 Vue/React）</td><td>ESM</td></tr><tr><td>需要做 Tree Shaking</td><td>ESM</td></tr><tr><td>需要动态导入模块</td><td><code>import()</code>（ESM 的动态导入）</td></tr></tbody></table><hr><h2 id="🧪-七、常见面试题总结" tabindex="-1">🧪 七、常见面试题总结 <a class="header-anchor" href="#🧪-七、常见面试题总结" aria-label="Permalink to &quot;🧪 七、常见面试题总结&quot;">​</a></h2><h3 id="_1-说说你对模块化的理解" tabindex="-1">1. 说说你对模块化的理解？ <a class="header-anchor" href="#_1-说说你对模块化的理解" aria-label="Permalink to &quot;1. 说说你对模块化的理解？&quot;">​</a></h3><blockquote><p>模块化是将一个复杂的系统拆分成多个独立的小单元，每个模块只关注自己的功能，提高可维护性和复用性。</p></blockquote><h3 id="_2-commonjs-和-esm-有什么区别" tabindex="-1">2. CommonJS 和 ESM 有什么区别？ <a class="header-anchor" href="#_2-commonjs-和-esm-有什么区别" aria-label="Permalink to &quot;2. CommonJS 和 ESM 有什么区别？&quot;">​</a></h3><blockquote><p>见上表对比。</p></blockquote><h3 id="_3-为什么-node-js-最初使用-commonjs-而不是-esm" tabindex="-1">3. 为什么 Node.js 最初使用 CommonJS 而不是 ESM？ <a class="header-anchor" href="#_3-为什么-node-js-最初使用-commonjs-而不是-esm" aria-label="Permalink to &quot;3. 为什么 Node.js 最初使用 CommonJS 而不是 ESM？&quot;">​</a></h3><blockquote><p>因为 ES6 出现较晚，在那之前 Node.js 已经采用 CommonJS。而且服务器端更适合同步加载模块。</p></blockquote><h3 id="_4-如何在-node-js-中使用-esm" tabindex="-1">4. 如何在 Node.js 中使用 ESM？ <a class="header-anchor" href="#_4-如何在-node-js-中使用-esm" aria-label="Permalink to &quot;4. 如何在 Node.js 中使用 ESM？&quot;">​</a></h3><blockquote><p>在 <code>package.json</code> 中设置 <code>&quot;type&quot;: &quot;module&quot;</code>，并使用 <code>.mjs</code> 扩展名或配合构建工具。</p></blockquote><h3 id="_5-import-和-require-的本质区别是什么" tabindex="-1">5. import 和 require 的本质区别是什么？ <a class="header-anchor" href="#_5-import-和-require-的本质区别是什么" aria-label="Permalink to &quot;5. import 和 require 的本质区别是什么？&quot;">​</a></h3><blockquote><p><code>require</code> 是运行时加载，<code>import</code> 是编译时加载，可以进行静态分析。</p></blockquote><hr><h2 id="📌-总结一句话" tabindex="-1">📌 总结一句话： <a class="header-anchor" href="#📌-总结一句话" aria-label="Permalink to &quot;📌 总结一句话：&quot;">​</a></h2><blockquote><p><strong>CommonJS 是 Node.js 的模块规范，强调同步加载；ES Module 是 JS 官方标准模块系统，强调异步加载和静态分析。随着技术发展，ES Module 正在逐步取代 CommonJS 成为主流。</strong></p></blockquote><h2 id="webpack-如何处理-commonjs-和-esm-模块" tabindex="-1">Webpack 如何处理 CommonJS 和 ESM 模块 <a class="header-anchor" href="#webpack-如何处理-commonjs-和-esm-模块" aria-label="Permalink to &quot;Webpack 如何处理 CommonJS 和 ESM 模块&quot;">​</a></h2><p>Webpack 是一个非常强大的模块打包工具，能够处理多种模块系统，包括 CommonJS 和 ECMAScript Modules (ESM)。下面我将解释 Webpack 如何处理这两种模块系统。</p><h3 id="commonjs-处理" tabindex="-1">CommonJS 处理 <a class="header-anchor" href="#commonjs-处理" aria-label="Permalink to &quot;CommonJS 处理&quot;">​</a></h3><p>在使用 CommonJS 模块时，你可以通过 <code>require</code> 来导入模块，并使用 <code>module.exports</code> 或 <code>exports</code> 导出模块。Webpack 原生支持 CommonJS 规范，可以无缝地解析和打包这类模块。</p><ul><li><strong>导入模块</strong>：使用 <code>require()</code> 函数来引入其他模块。</li><li><strong>导出模块</strong>：使用 <code>module.exports</code> 或者 <code>exports</code> 对象来定义模块的输出。</li></ul><p>例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// math.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> math</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./math&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 3</span></span></code></pre></div><p>当 Webpack 遇到上述代码时，它会自动解析 <code>require</code> 调用，并将其转换为适当的依赖关系，最终生成一个或多个打包文件。</p><h3 id="esm-处理" tabindex="-1">ESM 处理 <a class="header-anchor" href="#esm-处理" aria-label="Permalink to &quot;ESM 处理&quot;">​</a></h3><p>对于 ESM，即 ECMAScript 官方的模块系统，Webpack 同样提供了良好的支持。ESM 使用 <code>import</code> 和 <code>export</code> 关键字来分别导入和导出模块。</p><ul><li><strong>导入模块</strong>：使用 <code>import</code> 语句。</li><li><strong>导出模块</strong>：使用 <code>export</code> 关键字。</li></ul><p>例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// math.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { add } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./math&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 3</span></span></code></pre></div><p>Webpack 可以很好地理解这些 ESM 的语法，并将它们正确地解析为依赖关系。</p><h3 id="兼容性处理" tabindex="-1">兼容性处理 <a class="header-anchor" href="#兼容性处理" aria-label="Permalink to &quot;兼容性处理&quot;">​</a></h3><p>值得注意的是，Webpack 不仅支持单一类型的模块系统，而且可以在同一个项目中混合使用 CommonJS 和 ESM。这意味着你可以在一个文件中使用 <code>require</code>，同时在另一个文件中使用 <code>import</code>，Webpack 都能正确处理。</p><p>此外，Webpack 还支持动态导入（dynamic import），这是一种异步加载模块的方式，可以通过 <code>import()</code> 函数实现。这种方式不仅适用于 ESM，也可以与 CommonJS 模块一起使用，从而提供更灵活的代码分割和懒加载能力。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>无论是 CommonJS 还是 ESM，Webpack 都能有效地进行处理。它通过其内部的解析逻辑，将不同类型的模块请求转化为实际的文件依赖，并最终将整个应用打包成一个或多个文件。这使得开发者可以根据需要选择最合适的模块系统，或者在同一项目中结合使用两者，而无需担心兼容性问题。</p>`,70)]))}const c=i(e,[["render",h]]);export{E as __pageData,c as default};
