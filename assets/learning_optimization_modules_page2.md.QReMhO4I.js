import{_ as i,a as o,o as t,b0 as r}from"./chunks/framework.BBy0ZaTh.js";const c=JSON.parse('{"title":"前端首屏优化","description":"","frontmatter":{},"headers":[],"relativePath":"learning/optimization/modules/page2.md","filePath":"learning/optimization/modules/page2.md","lastUpdated":1752403471000}'),e={name:"learning/optimization/modules/page2.md"};function a(n,l,s,p,u,g){return t(),o("div",null,l[0]||(l[0]=[r('<h1 id="前端首屏优化" tabindex="-1">前端首屏优化 <a class="header-anchor" href="#前端首屏优化" aria-label="Permalink to &quot;前端首屏优化&quot;">​</a></h1><h3 id="一、资源加载优化" tabindex="-1">一、资源加载优化 <a class="header-anchor" href="#一、资源加载优化" aria-label="Permalink to &quot;一、资源加载优化&quot;">​</a></h3><ol><li><p><strong>优先加载关键资源</strong></p><ul><li><strong>CSS</strong>：将用于首屏渲染的CSS内联至HTML中，确保样式能立即应用。</li><li><strong>JS</strong>：对于非必要的JavaScript文件（如广告脚本、分析脚本），使用<code>async</code>或<code>defer</code>属性延迟加载。</li></ul></li><li><p><strong>图片优化</strong></p><ul><li>使用<strong>懒加载</strong>技术，仅当图片进入视口时才加载。</li><li>将图片格式转换为更高效的格式，如WebP。</li><li>使用占位图（placeholder）替代实际图片，直到图片完全加载。</li></ul></li><li><p><strong>字体优化</strong></p><ul><li>设置<code>font-display: swap;</code>，使得文本在自定义字体加载前可见。</li><li>考虑使用系统默认字体作为回退方案，避免空白文本闪烁。</li></ul></li><li><p><strong>使用CDN</strong></p><ul><li>静态资源通过CDN分发，利用地理位置优势加快资源加载速度。</li></ul></li><li><p><strong>HTTP/2 或 HTTP/3 升级</strong></p><ul><li>利用多路复用、头部压缩等特性减少延迟。</li></ul></li><li><p><strong>资源合并与压缩</strong></p><ul><li>合并多个CSS和JS文件以减少请求数量，并启用Gzip或Brotli压缩来减小传输体积。</li></ul></li><li><p><strong>内联关键CSS</strong></p><ul><li>将首屏所需的所有CSS直接嵌入HTML中，避免额外的HTTP请求</li></ul></li></ol><h3 id="二、构建流程优化" tabindex="-1">二、构建流程优化 <a class="header-anchor" href="#二、构建流程优化" aria-label="Permalink to &quot;二、构建流程优化&quot;">​</a></h3><ol><li><p><strong>代码分割</strong></p><ul><li>按需加载组件或模块，而不是一次性加载所有内容。</li><li>动态导入（Dynamic Imports）可以有效地实现按需加载。</li></ul></li><li><p><strong>Tree Shaking</strong></p><ul><li>移除未使用的代码部分，减小打包后的文件大小。</li></ul></li><li><p><strong>SSR (Server Side Rendering)</strong></p><ul><li>在服务器端完成页面初次渲染，发送给客户端的HTML已经包含了完整的内容结构，减少了浏览器解析和执行的时间。</li></ul></li><li><p><strong>Service Worker 缓存</strong></p><ul><li>实现离线访问和快速加载，特别是在重复访问时能够直接从缓存读取数据。</li></ul></li></ol><h3 id="三、渲染性能优化" tabindex="-1">三、渲染性能优化 <a class="header-anchor" href="#三、渲染性能优化" aria-label="Permalink to &quot;三、渲染性能优化&quot;">​</a></h3><ol><li><p><strong>骨架屏（Skeleton Screen）</strong></p><ul><li>在内容加载之前显示一个简单的UI框架，给用户即时反馈，改善等待体验。</li></ul></li><li><p><strong>避免阻塞渲染的CSS</strong></p><ul><li>确保CSS不会阻止页面渲染，可以通过媒体查询指定某些样式只在特定条件下加载。</li></ul></li><li><p><strong>减少重绘和回流</strong></p><ul><li>批量修改DOM元素样式，尽量使用类名切换代替直接操作样式属性。</li></ul></li><li><p><strong>动画优化</strong></p><ul><li>对于涉及视觉变化的动画，优先使用<code>transform</code>和<code>opacity</code>，因为它们可以被GPU加速，避免触发布局重排。</li></ul></li></ol><h3 id="四、监控与分析" tabindex="-1">四、监控与分析 <a class="header-anchor" href="#四、监控与分析" aria-label="Permalink to &quot;四、监控与分析&quot;">​</a></h3><ol><li><p><strong>性能监控工具</strong></p><ul><li>使用Lighthouse、WebPageTest等工具定期评估网站性能，并根据报告进行针对性优化。</li></ul></li><li><p><strong>前端埋点</strong></p><ul><li>收集用户行为数据，了解用户的交互模式，识别性能瓶颈。</li></ul></li><li><p><strong>持续优化</strong></p><ul><li>根据监控数据不断调整和优化网站性能，保持最佳状态。</li></ul></li></ol>',9)]))}const h=i(e,[["render",a]]);export{c as __pageData,h as default};
