import{_ as e,a,o,b0 as i}from"./chunks/framework.D10JOWeE.js";const p=JSON.parse('{"title":"✅ 前端缓存","description":"","frontmatter":{},"headers":[],"relativePath":"learning/optimization/modules/page3.md","filePath":"learning/optimization/modules/page3.md","lastUpdated":1752997743000}'),r={name:"learning/optimization/modules/page3.md"};function d(s,t,l,h,n,c){return o(),a("div",null,t[0]||(t[0]=[i(`<h1 id="✅-前端缓存" tabindex="-1">✅ 前端缓存 <a class="header-anchor" href="#✅-前端缓存" aria-label="Permalink to &quot;✅ 前端缓存&quot;">​</a></h1><h3 id="一、一句话总结" tabindex="-1">一、一句话总结 <a class="header-anchor" href="#一、一句话总结" aria-label="Permalink to &quot;一、一句话总结&quot;">​</a></h3><blockquote><p><strong>前端缓存是指浏览器通过存储资源（如 HTML、CSS、JS、图片等）来减少重复请求、加快页面加载速度的一种机制。合理使用缓存可以显著提升用户体验并降低服务器压力。</strong></p></blockquote><h3 id="二、前端缓存的分类" tabindex="-1">二、前端缓存的分类 <a class="header-anchor" href="#二、前端缓存的分类" aria-label="Permalink to &quot;二、前端缓存的分类&quot;">​</a></h3><h4 id="_1-http-缓存" tabindex="-1">1. <strong>HTTP 缓存</strong> <a class="header-anchor" href="#_1-http-缓存" aria-label="Permalink to &quot;1. **HTTP 缓存**&quot;">​</a></h4><p>这是最常见也是最重要的缓存方式，分为两种类型：</p><table tabindex="0"><thead><tr><th>类型</th><th>响应头字段</th><th>特点</th></tr></thead><tbody><tr><td><strong>强缓存</strong></td><td><code>Cache-Control</code> / <code>Expires</code></td><td>浏览器不发请求直接使用本地缓存，返回 200（from memory cache 或 disk cache）</td></tr><tr><td><strong>协商缓存</strong></td><td><code>Last-Modified/If-Modified-Since</code>、<code>ETag/If-None-Match</code></td><td>浏览器发送请求确认资源是否更新，未变则返回 304 Not Modified</td></tr></tbody></table><h5 id="✅-强缓存-vs-协商缓存区别" tabindex="-1">✅ 强缓存 vs 协商缓存区别： <a class="header-anchor" href="#✅-强缓存-vs-协商缓存区别" aria-label="Permalink to &quot;✅ 强缓存 vs 协商缓存区别：&quot;">​</a></h5><ul><li><strong>强缓存优先级更高</strong>，只有当它失效后才会走协商缓存。</li><li><code>ETag</code> 比 <code>Last-Modified</code> 更精确，能识别文件内容变化而非仅时间戳。</li></ul><h4 id="_2-本地存储类缓存" tabindex="-1">2. <strong>本地存储类缓存</strong> <a class="header-anchor" href="#_2-本地存储类缓存" aria-label="Permalink to &quot;2. **本地存储类缓存**&quot;">​</a></h4><p>这些属于客户端持久化缓存手段，常用于保存用户状态或接口数据。</p><table tabindex="0"><thead><tr><th>技术</th><th>容量</th><th>是否随请求发送</th><th>生命周期</th><th>适用场景</th></tr></thead><tbody><tr><td><code>localStorage</code></td><td>~5MB</td><td>否</td><td>永久，除非手动清除</td><td>存储用户配置、token 等</td></tr><tr><td><code>sessionStorage</code></td><td>~5MB</td><td>否</td><td>页面关闭即清除</td><td>临时会话数据</td></tr><tr><td><code>IndexedDB</code></td><td>几百 MB 到 GB</td><td>否</td><td>可控</td><td>大量结构化数据存储</td></tr><tr><td><code>Cookie</code></td><td>~4KB</td><td>是（每次请求都会携带）</td><td>可设置过期时间</td><td>身份认证、跨域通信</td></tr></tbody></table><h4 id="_3-service-worker-缓存" tabindex="-1">3. <strong>Service Worker 缓存</strong> <a class="header-anchor" href="#_3-service-worker-缓存" aria-label="Permalink to &quot;3. **Service Worker 缓存**&quot;">​</a></h4><ul><li>通过注册 Service Worker 实现更灵活的离线缓存策略。</li><li>支持拦截请求、自定义缓存逻辑，是 PWA（渐进式 Web 应用）的核心技术之一。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fetch&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">respondWith</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    caches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.request).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.request))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><hr><h3 id="三、如何选择合适的缓存策略" tabindex="-1">三、如何选择合适的缓存策略？ <a class="header-anchor" href="#三、如何选择合适的缓存策略" aria-label="Permalink to &quot;三、如何选择合适的缓存策略？&quot;">​</a></h3><table tabindex="0"><thead><tr><th>场景</th><th>推荐方案</th></tr></thead><tbody><tr><td>静态资源（JS/CSS/图片）</td><td>强缓存 + hash 文件名（如 main.a1b2c3.js）</td></tr><tr><td>用户登录信息</td><td><code>localStorage</code> 或 <code>Cookie + HttpOnly</code></td></tr><tr><td>表单草稿、临时数据</td><td><code>sessionStorage</code></td></tr><tr><td>接口数据缓存</td><td>使用 <code>localStorage</code> 或 <code>IndexedDB</code> 结合缓存过期策略</td></tr><tr><td>离线应用</td><td>Service Worker + Cache Storage</td></tr></tbody></table><hr><h3 id="四、缓存的优缺点" tabindex="-1">四、缓存的优缺点 <a class="header-anchor" href="#四、缓存的优缺点" aria-label="Permalink to &quot;四、缓存的优缺点&quot;">​</a></h3><table tabindex="0"><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>提升页面加载速度，改善用户体验</td><td>缓存过期可能导致用户看到旧内容</td></tr><tr><td>减少服务器请求压力</td><td>不合理的缓存策略可能带来安全风险（如 Cookie 被盗）</td></tr><tr><td>支持离线访问</td><td>占用本地存储空间</td></tr></tbody></table><hr><h3 id="五、实际开发中的优化建议" tabindex="-1">五、实际开发中的优化建议 <a class="header-anchor" href="#五、实际开发中的优化建议" aria-label="Permalink to &quot;五、实际开发中的优化建议&quot;">​</a></h3><ol><li><p><strong>静态资源加版本号或 Hash</strong></p><ul><li>如 <code>/main.js?v=1.0.1</code> 或 <code>/main.abcd1234.js</code></li><li>避免因强缓存导致更新无效</li></ul></li><li><p><strong>合理设置 <code>Cache-Control</code></strong></p><ul><li>对不常变动的资源设置较长的缓存时间（如 <code>max-age=31536000</code>）</li><li>对频繁更新资源设置较短或 no-cache</li></ul></li><li><p><strong>使用 Service Worker 实现渐进增强体验</strong></p><ul><li>支持离线访问、后台同步、消息推送等功能</li></ul></li><li><p><strong>避免滥用 Cookie</strong></p><ul><li>减少 Cookie 体积，防止影响请求性能</li><li>设置 <code>HttpOnly</code> 和 <code>Secure</code> 属性保障安全</li></ul></li></ol><hr><h3 id="六、总结" tabindex="-1">六、总结 <a class="header-anchor" href="#六、总结" aria-label="Permalink to &quot;六、总结&quot;">​</a></h3><blockquote><p>我可以用一句话总结： “<strong>前端缓存是一种以空间换时间的性能优化策略，掌握不同缓存机制的使用场景和限制条件，有助于我们在实际项目中做出更高效、更安全的设计决策。</strong>”</p></blockquote><p>无论是从用户体验还是从系统性能角度出发，合理利用缓存都是前端工程师必备的一项核心技能。</p><hr><h2 id="🧠-知识延伸" tabindex="-1">🧠 知识延伸 <a class="header-anchor" href="#🧠-知识延伸" aria-label="Permalink to &quot;🧠 知识延伸&quot;">​</a></h2><ul><li><code>Cache-Control: immutable</code> 的作用和优势（适用于永远不会变的内容）</li><li>CDN 缓存与浏览器缓存的区别和配合使用</li><li>如何清除强缓存（强制刷新、禁用缓存、修改 URL）</li><li>PWA 中 Service Worker 缓存策略设计</li><li>如何监控缓存命中率（Chrome DevTools Network 面板）</li></ul><h3 id="_1-cache-control-immutable-的作用和优势" tabindex="-1">1. <strong><code>Cache-Control: immutable</code> 的作用和优势</strong> <a class="header-anchor" href="#_1-cache-control-immutable-的作用和优势" aria-label="Permalink to &quot;1. **\`Cache-Control: immutable\` 的作用和优势**&quot;">​</a></h3><blockquote><p><strong>回答示例：</strong><code>Cache-Control: immutable</code> 表示资源一旦缓存后就永远不会改变，适用于像 CDN 上的静态资源（如带 hash 名的 JS/CSS 文件）。</p><p>相比普通的 <code>max-age=xxx</code>，它告诉浏览器完全不需要再去验证资源是否更新（跳过协商缓存），从而减少不必要的网络请求，提升性能。</p></blockquote><hr><h3 id="_2-cdn-缓存与浏览器缓存的区别和配合使用" tabindex="-1">2. <strong>CDN 缓存与浏览器缓存的区别和配合使用</strong> <a class="header-anchor" href="#_2-cdn-缓存与浏览器缓存的区别和配合使用" aria-label="Permalink to &quot;2. **CDN 缓存与浏览器缓存的区别和配合使用**&quot;">​</a></h3><blockquote><p><strong>回答示例：</strong></p><ul><li><strong>CDN 缓存</strong> 是部署在全球边缘节点上的服务器缓存，用于加速资源分发；</li><li><strong>浏览器缓存</strong> 是客户端本地的缓存机制，用于减少重复请求；</li><li>两者可以结合使用：静态资源通过 CDN 分发 + 浏览器设置强缓存，能显著提升加载速度并降低源站压力。</li></ul></blockquote><hr><h3 id="_3-如何清除强缓存" tabindex="-1">3. <strong>如何清除强缓存？</strong> <a class="header-anchor" href="#_3-如何清除强缓存" aria-label="Permalink to &quot;3. **如何清除强缓存？**&quot;">​</a></h3><blockquote><p><strong>回答示例：</strong> 强缓存一旦生效，浏览器就不会再请求服务器。要清除或绕过强缓存，常见方式有：</p><ul><li>用户端强制刷新页面（如 Windows 下按 <code>Ctrl + F5</code>）</li><li>禁用缓存（Chrome DevTools 中 Network 面板勾选 &quot;Disable cache&quot;）</li><li>修改资源 URL（如加版本号或 hash，例如 <code>/main.js?v=2.0</code> 或 <code>/main.a1b2c3.js</code>）</li></ul></blockquote><hr><h3 id="_4-pwa-中-service-worker-缓存策略设计" tabindex="-1">4. <strong>PWA 中 Service Worker 缓存策略设计</strong> <a class="header-anchor" href="#_4-pwa-中-service-worker-缓存策略设计" aria-label="Permalink to &quot;4. **PWA 中 Service Worker 缓存策略设计**&quot;">​</a></h3><blockquote><p><strong>回答示例：</strong> 在 PWA 应用中，Service Worker 是实现离线访问的核心。常见的缓存策略包括：</p><ul><li><strong>缓存优先（Cache First）</strong>：先读取缓存，失败后再请求网络</li><li><strong>网络优先（Network First）</strong>：优先请求网络，失败时使用缓存</li><li><strong>Stale-While-Revalidate</strong>：先返回缓存数据，同时后台更新缓存</li></ul><p>这些策略可以通过 <code>Workbox</code> 等库来简化实现。</p></blockquote><hr><h3 id="_5-如何监控缓存命中率" tabindex="-1">5. <strong>如何监控缓存命中率？</strong> <a class="header-anchor" href="#_5-如何监控缓存命中率" aria-label="Permalink to &quot;5. **如何监控缓存命中率？**&quot;">​</a></h3><blockquote><p><strong>回答示例：</strong> 可以通过 Chrome DevTools 的 <strong>Network 面板</strong> 观察每个资源的加载状态：</p><ul><li>显示 <code>(from memory cache)</code> 或 <code>(from disk cache)</code> 表示命中了强缓存；</li><li>显示 <code>(from network)</code> 并返回 304，则表示走的是协商缓存；</li><li>返回 200 并真正下载资源，说明未命中缓存。</li></ul><p>此外，也可以通过埋点上报统计缓存命中情况，优化缓存策略。</p></blockquote><h2 id="❓-其他相关" tabindex="-1">❓ 其他相关 <a class="header-anchor" href="#❓-其他相关" aria-label="Permalink to &quot;❓ 其他相关&quot;">​</a></h2><table tabindex="0"><thead><tr><th>问题</th><th>简要回答</th></tr></thead><tbody><tr><td>强缓存和协商缓存的区别？</td><td>强缓存不发请求直接使用缓存；协商缓存需要服务器确认资源是否更新</td></tr><tr><td>ETag 和 Last-Modified 哪个更好？</td><td>ETag 更精确，可以识别内容变化；Last-Modified 可能误判</td></tr><tr><td>localStorage 和 Cookie 有什么区别？</td><td>localStorage 容量大、不自动发送，适合存储非敏感数据；Cookie 自动随请求发送，适合身份验证</td></tr><tr><td>如何实现接口数据缓存？</td><td>可结合 localStorage 或 IndexedDB 存储响应结果，并设置过期时间</td></tr><tr><td>如何清除浏览器缓存？</td><td>修改 URL 参数、强制刷新（Ctrl+F5）、使用 <code>Cache-Control: no-cache</code></td></tr></tbody></table>`,47)]))}const g=e(r,[["render",d]]);export{p as __pageData,g as default};
