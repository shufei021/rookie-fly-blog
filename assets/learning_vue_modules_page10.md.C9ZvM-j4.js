import{_ as i,a,o as t,b0 as n}from"./chunks/framework.D10JOWeE.js";const E=JSON.parse('{"title":"watch vs watchEffect","description":"","frontmatter":{},"headers":[],"relativePath":"learning/vue/modules/page10.md","filePath":"learning/vue/modules/page10.md","lastUpdated":1752997743000}'),h={name:"learning/vue/modules/page10.md"};function e(l,s,p,k,c,r){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="watch-vs-watcheffect" tabindex="-1">watch vs watchEffect <a class="header-anchor" href="#watch-vs-watcheffect" aria-label="Permalink to &quot;watch vs watchEffect&quot;">​</a></h1><p>在Vue 3中，<code>watch</code>和<code>watchEffect</code>都是用于监听数据变化并执行相应的副作用（side effects），但它们之间存在一些关键差异。理解这些差异对于前端面试来说非常重要。</p><h3 id="watch" tabindex="-1">watch <a class="header-anchor" href="#watch" aria-label="Permalink to &quot;watch&quot;">​</a></h3><ul><li><strong>基本用法</strong>：<code>watch</code>需要明确指定要监听的数据源。它可以监听一个或多个响应式数据的变化。</li><li><strong>惰性执行</strong>：仅当被监听的数据发生变化时，回调函数才会被执行。这意味着初始渲染时不会自动触发回调。</li><li><strong>支持清除副作用</strong>：如果监听器的逻辑创建了可以清理的副作用（如定时器、事件监听器等），可以通过返回一个清理函数来实现。</li><li><strong>异步支持</strong>：可以直接在回调函数中使用异步操作，而无需额外的封装。</li></ul><p>示例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref, watch } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`count changed from \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">oldVal</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} to \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newVal</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="watcheffect" tabindex="-1">watchEffect <a class="header-anchor" href="#watcheffect" aria-label="Permalink to &quot;watchEffect&quot;">​</a></h3><ul><li><strong>自动追踪依赖</strong>：不需要手动指定监听的数据源，而是根据函数体内使用的响应式数据自动追踪依赖。一旦这些依赖发生改变，回调就会重新执行。</li><li><strong>立即执行</strong>：与<code>watch</code>不同的是，<code>watchEffect</code>会在初次运行时立即执行一次，以捕获当前状态，并且之后每当依赖项更新时都会再次执行。</li><li><strong>副作用清理</strong>：类似于<code>watch</code>，如果在<code>watchEffect</code>内部创建了副作用，也可以通过返回一个函数来定义如何清理这些副作用。</li><li><strong>同步执行</strong>：默认情况下，<code>watchEffect</code>是同步执行的，但如果需要处理异步逻辑，则需要自行管理异步代码。</li></ul><p>示例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref, watchEffect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watchEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`current count is: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="主要区别" tabindex="-1">主要区别 <a class="header-anchor" href="#主要区别" aria-label="Permalink to &quot;主要区别&quot;">​</a></h3><ul><li><strong>初始化执行</strong>：<code>watch</code>不会在首次创建时立即执行回调，而<code>watchEffect</code>会。</li><li><strong>依赖声明</strong>：<code>watch</code>需要明确指出要监听的数据，而<code>watchEffect</code>会自动收集依赖。</li><li><strong>使用场景</strong>：如果你需要更细粒度地控制何时以及为何种数据变化触发回调，<code>watch</code>可能是更好的选择。而当你想要自动追踪任何在回调中使用的响应式数据的变化时，<code>watchEffect</code>则更加方便。</li></ul><p>了解这两种监听机制的特点和适用场景，可以帮助你在实际开发中做出更好的决策，同时也能在面试中展示出对Vue 3深入的理解。</p>`,13)]))}const o=i(h,[["render",e]]);export{E as __pageData,o as default};
