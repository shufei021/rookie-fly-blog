import{_ as t,a as o,o as r,b0 as a}from"./chunks/framework.D10JOWeE.js";const p=JSON.parse('{"title":"vue的生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"learning/vue/modules/page2.md","filePath":"learning/vue/modules/page2.md","lastUpdated":1752997743000}'),d={name:"learning/vue/modules/page2.md"};function n(l,e,s,i,c,u){return r(),o("div",null,e[0]||(e[0]=[a('<h1 id="vue的生命周期" tabindex="-1">vue的生命周期 <a class="header-anchor" href="#vue的生命周期" aria-label="Permalink to &quot;vue的生命周期&quot;">​</a></h1><ul><li><code>beforeCreate</code>:<strong>这个钩子在实例初始化之后、数据观测 (data observer) 和 event/watcher 事件配置之前被调用</strong>,不过，在 Composition API 中，通常使用 setup() 函数来处理这一阶段的逻辑，因此这个钩子不常用。</li><li><code>created</code>：<strong>在实例创建完成后立即调用</strong>。在这个阶段，实例已经完成了数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。但是，挂载阶段还没开始，$el 属性目前不可见</li><li><code>beforeMount</code>：<strong>在挂载开始之前被调用</strong>：相关的 render 函数首次被调用。此时，虚拟 DOM 尚未渲染到真实 DOM 上</li><li><code>mounted</code>：<strong>在 el 被新创建的 vm.$el 替换，并挂载到实例上后调用</strong>。这时，组件已经被渲染到 DOM 中，可以访问 DOM 元素了。</li><li><code>beforeUpdate</code>：<em>在数据更新时，在虚拟 DOM 打补丁之前调用</em>*。此时，可以获取更新前的状态，适合用来进行一些清理工作。</li><li><code>updated</code>：<strong>在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用</strong>。此时，组件 DOM 已经更新，可以执行依赖于 DOM 的操作。然而，避免在此期间改变状态，因为这可能会导致无限的更新循环</li><li><code>beforeUnmount（在 Vue 2 中为 beforeDestroy）</code>：<strong>发生在实例销毁之前，在当前阶段实例完全可以被使用</strong>。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。</li><li><code>unmounted（在 Vue 2 中为 destroyed）</code>:<strong>卸载组件实例后调用</strong>。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。</li></ul><p><strong>activated 和 deactivated 是 Vue 中专门用于 &lt; keep-alive&gt; 缓存组件时的生命周期钩子</strong></p><ul><li><code>activated</code>：<strong>当组件被 &lt; keep-alive&gt; 缓存后，每次该组件被激活（显示）时调用</strong>。可以在这里执行组件重新展示时需要的逻辑，比如重新获取数据、恢复动画、计时器等</li><li><code>deactivated</code>：<strong>当组件被缓存后，离开当前视图（被切换出去）时调用</strong>。可以在这里进行一些资源释放操作，比如清除定时器、取消事件监听、停止动画等，防止内存泄漏。</li></ul>',4)]))}const v=t(d,[["render",n]]);export{p as __pageData,v as default};
