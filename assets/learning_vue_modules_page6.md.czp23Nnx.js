import{_ as l,a as i,o,b0 as a}from"./chunks/framework.D10JOWeE.js";const h=JSON.parse('{"title":"Vue 3 组件通信方式及其基本原理","description":"","frontmatter":{},"headers":[],"relativePath":"learning/vue/modules/page6.md","filePath":"learning/vue/modules/page6.md","lastUpdated":1753172304000}'),t={name:"learning/vue/modules/page6.md"};function r(u,e,d,n,s,c){return o(),i("div",null,e[0]||(e[0]=[a('<h1 id="vue-3-组件通信方式及其基本原理" tabindex="-1">Vue 3 组件通信方式及其基本原理 <a class="header-anchor" href="#vue-3-组件通信方式及其基本原理" aria-label="Permalink to &quot;Vue 3 组件通信方式及其基本原理&quot;">​</a></h1><h4 id="父子组件通信" tabindex="-1">父子组件通信 <a class="header-anchor" href="#父子组件通信" aria-label="Permalink to &quot;父子组件通信&quot;">​</a></h4><ul><li>Props 和 Events <ul><li><code>Props</code>：父组件可以通过属性绑定的方式将数据传递给子组件。子组件使用 <code>defineProps</code> 来接收父组件传来的数据</li><li><code>Events</code>：子组件可以通过触发自定义事件来通知父组件状态发生了变化，并且可以携带参数给父组件</li></ul></li><li><code>v-model</code> 双向绑定 <ul><li><code>v-model</code> 是一种简化的语法糖，用于实现父组件和子组件之间的双向数据绑定。它实际上是 <code>:modelValue</code> 和 <code>@update:modelValue</code> 的缩写形式</li></ul></li></ul><h4 id="跨层级组件通信" tabindex="-1">跨层级组件通信 <a class="header-anchor" href="#跨层级组件通信" aria-label="Permalink to &quot;跨层级组件通信&quot;">​</a></h4><ul><li>Provide / Inject <ul><li>Event Bus（mitt库） <ul><li>在 Vue 3 中，由于 $root 和 $event 已被移除，通常会使用第三方库如 <code>mitt</code> 创建一个轻量级的事件总线来实现兄弟组件间的通信</li></ul></li><li>共享父组件状态 <ul><li>当两个或更多的兄弟组件需要共享状态时，可以通过共同的父组件作为中介进行状态管理</li></ul></li></ul></li></ul><h4 id="高阶方案" tabindex="-1">高阶方案 <a class="header-anchor" href="#高阶方案" aria-label="Permalink to &quot;高阶方案&quot;">​</a></h4><ul><li>插槽（Slots） <ul><li>插槽提供了一种内容分发的API，允许父组件向子组件传递模板片段</li></ul></li><li>attrs和attrs和listeners（在Vue 3中已合并为 $attrs） <ul><li><code>$attrs</code>包含了所有未被声明为 props 的属性，可以用来透传到子组件</li></ul></li><li>Ref + DefineExpose <ul><li>父组件可以通过 ref 直接访问子组件实例或DOM元素，并调用子组件的方法</li></ul></li><li>Vuex 或 Pinia <ul><li>对于更复杂的状态管理需求，推荐使用 Vuex 或者 Pinia 这样的状态管理库来集中管理和维护应用的状态</li></ul></li></ul><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>每种通信方式都有其适用场景，选择哪种方式取决于具体的业务需求和组件结构。例如，在父子组件之间，通常首选 Props 和 Events；对于跨层级通信，Provide / Inject 更加合适；而对于非父子关系的组件间通信，则可能需要用到 Event Bus 或者 Vuex / Pinia。</p><h2 id="vue-组件通信方式" tabindex="-1">Vue 组件通信方式 <a class="header-anchor" href="#vue-组件通信方式" aria-label="Permalink to &quot;Vue 组件通信方式&quot;">​</a></h2><h3 id="_1-父子组件通信" tabindex="-1">1. 父子组件通信 <a class="header-anchor" href="#_1-父子组件通信" aria-label="Permalink to &quot;1. 父子组件通信&quot;">​</a></h3><ul><li><p><strong>Props + Events</strong></p><ul><li>父 → 子：通过 <code>props</code> 传递数据</li><li>子 → 父：通过 <code>$emit</code> 触发事件</li><li>原则：遵循单向数据流</li></ul></li><li><p><strong>v-model</strong></p><ul><li>语法糖：<code>modelValue</code> prop + <code>update:modelValue</code> 事件</li><li>Vue 3 支持多个 v-model</li></ul></li><li><p><strong>Ref</strong></p><ul><li>父组件通过 <code>ref</code> 访问子组件实例方法/数据</li></ul></li></ul><h3 id="_2-跨层级通信" tabindex="-1">2. 跨层级通信 <a class="header-anchor" href="#_2-跨层级通信" aria-label="Permalink to &quot;2. 跨层级通信&quot;">​</a></h3><ul><li><p><strong>Provide/Inject</strong></p><ul><li>祖先 → 后代：<code>provide</code> 提供数据，<code>inject</code> 注入</li><li>Vue 3 需手动保持响应式（提供 <code>ref</code>/<code>reactive</code>）</li></ul></li><li><p><strong>事件总线</strong></p><ul><li>Vue 2: 新建 Vue 实例作为 EventBus</li><li>Vue 3: 推荐使用 <a href="https://github.com/developit/mitt" target="_blank" rel="noreferrer">mitt</a> 库</li></ul></li></ul><h3 id="_3-全局状态管理" tabindex="-1">3. 全局状态管理 <a class="header-anchor" href="#_3-全局状态管理" aria-label="Permalink to &quot;3. 全局状态管理&quot;">​</a></h3><ul><li><p><strong>Pinia</strong> (推荐)</p><ul><li>Vue 3 官方推荐的状态管理库</li><li>支持 TypeScript 和 Composition API</li></ul></li><li><p><strong>Vuex</strong></p><ul><li>Vue 2 的标准方案</li><li>Vue 3 仍兼容但不再推荐</li></ul></li></ul><h3 id="_4-特殊场景方案" tabindex="-1">4. 特殊场景方案 <a class="header-anchor" href="#_4-特殊场景方案" aria-label="Permalink to &quot;4. 特殊场景方案&quot;">​</a></h3><ul><li><p><strong>共享父组件状态</strong></p><ul><li>通过 <code>$parent</code> 访问（不推荐，破坏封装性）</li><li>更好的方案：提升状态到父组件 + props 传递</li></ul></li><li><p><strong>本地存储通信</strong></p><ul><li>通过 <code>localStorage</code> + <code>storage</code> 事件实现跨标签页通信</li></ul></li></ul>',18)]))}const m=l(t,[["render",r]]);export{h as __pageData,m as default};
