import{_ as t,a as o,o as a,b0 as l}from"./chunks/framework.D10JOWeE.js";const m=JSON.parse('{"title":"Vue 的 computed 的实现原理","description":"","frontmatter":{},"headers":[],"relativePath":"learning/vue/modules/page9.md","filePath":"learning/vue/modules/page9.md","lastUpdated":1753172304000}'),r={name:"learning/vue/modules/page9.md"};function i(s,e,n,u,d,p){return a(),o("div",null,e[0]||(e[0]=[l('<h1 id="vue-的-computed-的实现原理" tabindex="-1">Vue 的 computed 的实现原理 <a class="header-anchor" href="#vue-的-computed-的实现原理" aria-label="Permalink to &quot;Vue 的 computed 的实现原理&quot;">​</a></h1><p>Vue 的 <code>computed</code> 属性实现的核心在于依赖追踪和响应式系统。简要来说，其实现原理包括以下几个关键点：</p><ul><li><ol><li><strong>依赖收集</strong>：当一个计算属性（computed property）被访问时，Vue 会自动追踪在这个过程中哪些响应式数据（reactive data）被访问了。这是通过 Vue 的响应式系统来完成的，该系统会在读取响应式数据时进行依赖收集。</li></ol></li><li><ol start="2"><li><strong>缓存机制</strong>：计算属性的结果会被缓存起来，并且只有在其依赖的数据发生变化时才会重新计算。这意味着如果相关依赖未发生改变，多次访问同一个计算属性将会立即返回缓存的结果，而不会重复执行计算逻辑。</li></ol></li><li><ol start="3"><li><strong>响应更新</strong>：一旦某个计算属性所依赖的数据发生了变化，Vue 就会知道需要重新计算这个计算属性的值，并更新相应的视图。这种更新是自动的，开发者不需要手动干预。</li></ol></li><li><ol start="4"><li><strong>惰性求值</strong>：计算属性采用惰性求值策略，即仅在访问计算属性时才执行计算逻辑，而不是在定义时就立即执行。这样可以避免不必要的计算，提高性能。</li></ol></li></ul><p>综上所述，Vue 的 <code>computed</code> 利用了依赖追踪、缓存机制以及响应式更新等特性，使得它能够高效地管理复杂状态逻辑，同时简化了代码的编写和维护工作。</p>',4)]))}const _=t(r,[["render",i]]);export{m as __pageData,_ as default};
