# 延迟加载js的方法


## async 和 defer 属性（推荐）

**async：异步加载，不阻塞渲染，加载完成后立即执行（无序）**

```html
<script src="script.js" async></script>
```

**defer：异步加载，延迟到HTML解析完成后执行（按顺序）**

```html
<script src="script.js" defer></script>
```

## 动态脚本注入

**通过JavaScript动态创建标签script**

```js
function loadScript(src) {
  const script = document.createElement('script');
  script.src = src;
  document.body.appendChild(script); // 添加到DOM后开始加载
}
// 按需调用
loadScript('path/to/script.js');
```

## 事件触发加载

**在特定用户行为（如点击、滚动）后加载：**






|方法	|是否阻塞渲染	|执行顺序	|适用场景|
|:-----------------|:-----------------|:-----------------|:-----------------|
|async	|❌ 非阻塞|	❌ 无序|	独立脚本（如分析代码）|
|defer|	❌ 非阻塞|	✅ 顺序|	依赖 DOM/其他脚本的代码|
|动态注入|	❌ 非阻塞|	可控|	精准控制加载时机|
|IntersectionObserver|	❌ 非阻塞|	可控	图片/组件懒加载|
|import()|	❌ 非阻塞|	✅ 顺序|	现代框架路由懒加载（React/Vue）|
<!-- 这个过程可分为`网络请求阶段`、`服务器处理阶段`、`浏览器解析渲染阶段`三大模块，涉及`DNS解析`、`TCP连接`、`HTTP协议`、`渲染管线等`核心技术点。下面我会分层展开说明。

网络请求阶段:

+ DNS查询:浏览器首先检查本地缓存（如Chrome的DNS缓存），若无则向ISP的DNS服务器递归查询，最终解析出IP地址。优化手段如dns-prefetch可提前预解析。
+ TCP连接:通过三次握手建立TCP连接，HTTPS还需TLS握手（如TLS 1.3的0-RTT优化）。HTTP/2的多路复用或HTTP/3的QUIC协议可解决队头阻塞。
+ HTTP请求:浏览器构造HTTP请求报文，包含方法（GET/POST）、头部（如Accept-Encoding: br支持Brotli压缩）、Cookie（注意SameSite安全属性）。

 服务器处理阶段:

 + 反向代理与负载均衡:请求可能先到达Nginx/CDN，通过负载均衡算法（如轮询）分发到后端服务器，期间可能经过WAF防火墙的安全检测。

 + 后台处理:服务器生成响应时，可能使用Cache-Control: max-age=3600强缓存，或ETag协商缓存。静态资源建议托管到Cookie-Free域名。

 浏览器解析与渲染:

 + 关键渲染路径:解析HTML生成DOM树，解析CSS生成CSSOM树，合并为渲染树后计算布局（Layout），最后分图层绘制（Paint）和合成（Composite）。< script>会阻塞解析，可通过async/defer优化。

 + 性能优化点：内联关键CSS、图片懒加载、content-visibility: auto跳过屏外渲染，都是常见优化手段。

 > 整个过程涉及网络、操作系统、浏览器引擎、前端性能优化等多领域知识。如果想进一步优化，可以从减少关键资源数（如SSR）、利用HTTP/3的QUIC协议、采用Islands架构等方面深入。实际工作中我会用Lighthouse分析各阶段耗时，针对性优化。 -->


<!-- :::details
+ DNS查询具体步骤？→ 展开本地缓存、递归/迭代查询。
+ 如何优化首屏时间？→ 关键资源预加载、SSR、代码分割。
+ 渲染阶段为什么需要图层？ → 解释GPU加速与合成机制。
::: -->



<!-- + 浏览器先判断是否为合法的url格式，不合法则在搜索引擎中搜索
+ 合法后，DNS解析会先判断缓存中是否有url的ip地址。
+ 缓存的查询顺序是：浏览器缓存 -> 操作系统缓存（本地的hosts文件） -> 路由器缓存 -> 本地的DNS服务器缓存
+ 在缓存中没有的情况，则向服务器发起请求查询ip地址。
+ 查询IP地址的顺序是：根域名服务器 -> 顶级域名服务器 -> 权威域名服务器。直到查找到返回，并将其存储在缓存中下次使用
+ TSP建立连接，也就是三次握手
+ 第一次握手，携带建立连接请求SYN=1和随机序列seq=x
+ 第二次握手，携带确定字段ACK=1、连接请求SYN=1、随机序列seq=y和ack为上一次握手的seq+1，就是x+1
+ 第三次握手，携带确定字段ACK=1、ack=y+1、seq=x+1
+ 如果是https，还有一个TLS四次握手
+ 第一次握手，客户端向服务端发送 支持的协议版本 + 支持的加密方法 + 生成的随机数
+ 第二次握手，服务端向客户端发送 证书 + 公钥 + 随机数
+ 第三次握手前，客户端会先验证证书有没有过期、域名对不对、是否可信机构颁发的。
+ 没有问题或者用户接受不受信的证书，浏览器会生成一个新的随机数
+ 第三次握手，将之前的三个随机数通过一定的算法生成会话秘钥，之后的加密解密都是用这个秘钥
+ 第四次握手，服务端收到回复，是用确定的加密方法进行解密，得到第三个随机数，使用同样的算法计算出会话秘钥
+ 建立连接之后，浏览器发送http请求
+ 请求报文由请求行、请求头、空行和请求体组成
+ 服务器解析请求报文，返回响应报文
+ 响应报文由响应行、响应头、空行和响应体组成，我们需要的html文件就在响应体中
+ 浏览器拿到html文件并开始解析，构建dom tree。遇到css文件，下载并构建CSSOM tree。等到两者都构建完成之后，一起构建Render tree。然后进行布局和绘制
+ 其中遇到了script标签，则停止构建dom tree，等下载完成之后才会继续构建dom tree
+ 当资源传输完毕之后，TSP关闭连接，进行四次挥手的操作，其中四次挥手的操作客户端和服务器都可以发起
+ 第一次挥手，携带断开连接的FIN=1、确定字段ACK=1、随机序列seq=u，ack=v
+ 第二次挥手，携带确定字段ACK=1、随机序列seq=v，ack=u+1
+ 第三次挥手，携带确定字段ACK=1、断开连接FIN=1、随机序列seq=w、ack=u+1
+ 第四次挥手，携带确定字段ACK=1，随机序列seq=u+1，ack=w+1
+ 等待2MSL后进入关闭状态
+ 断开连接，结束通讯 -->

