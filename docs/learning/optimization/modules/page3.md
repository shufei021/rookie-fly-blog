
# ✅ 前端缓存

### 一、一句话总结

> **前端缓存是指浏览器通过存储资源（如 HTML、CSS、JS、图片等）来减少重复请求、加快页面加载速度的一种机制。合理使用缓存可以显著提升用户体验并降低服务器压力。**


### 二、前端缓存的分类

#### 1. **HTTP 缓存**
这是最常见也是最重要的缓存方式，分为两种类型：

| 类型 | 响应头字段 | 特点 |
|------|-------------|------|
| **强缓存** | `Cache-Control` / `Expires` | 浏览器不发请求直接使用本地缓存，返回 200（from memory cache 或 disk cache） |
| **协商缓存** | `Last-Modified/If-Modified-Since`、`ETag/If-None-Match` | 浏览器发送请求确认资源是否更新，未变则返回 304 Not Modified |

##### ✅ 强缓存 vs 协商缓存区别：
- **强缓存优先级更高**，只有当它失效后才会走协商缓存。
- `ETag` 比 `Last-Modified` 更精确，能识别文件内容变化而非仅时间戳。

#### 2. **本地存储类缓存**
这些属于客户端持久化缓存手段，常用于保存用户状态或接口数据。

| 技术 | 容量 | 是否随请求发送 | 生命周期 | 适用场景 |
|------|------|------------------|-----------|------------|
| `localStorage` | ~5MB | 否 | 永久，除非手动清除 | 存储用户配置、token 等 |
| `sessionStorage` | ~5MB | 否 | 页面关闭即清除 | 临时会话数据 |
| `IndexedDB` | 几百 MB 到 GB | 否 | 可控 | 大量结构化数据存储 |
| `Cookie` | ~4KB | 是（每次请求都会携带） | 可设置过期时间 | 身份认证、跨域通信 |

#### 3. **Service Worker 缓存**
- 通过注册 Service Worker 实现更灵活的离线缓存策略。
- 支持拦截请求、自定义缓存逻辑，是 PWA（渐进式 Web 应用）的核心技术之一。

```js
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => response || fetch(event.request))
  );
});
```

---

### 三、如何选择合适的缓存策略？

| 场景 | 推荐方案 |
|------|----------|
| 静态资源（JS/CSS/图片） | 强缓存 + hash 文件名（如 main.a1b2c3.js） |
| 用户登录信息 | `localStorage` 或 `Cookie + HttpOnly` |
| 表单草稿、临时数据 | `sessionStorage` |
| 接口数据缓存 | 使用 `localStorage` 或 `IndexedDB` 结合缓存过期策略 |
| 离线应用 | Service Worker + Cache Storage |

---

### 四、缓存的优缺点

| 优点 | 缺点 |
|------|------|
| 提升页面加载速度，改善用户体验 | 缓存过期可能导致用户看到旧内容 |
| 减少服务器请求压力 | 不合理的缓存策略可能带来安全风险（如 Cookie 被盗） |
| 支持离线访问 | 占用本地存储空间 |

---

### 五、实际开发中的优化建议

1. **静态资源加版本号或 Hash**
   - 如 `/main.js?v=1.0.1` 或 `/main.abcd1234.js`
   - 避免因强缓存导致更新无效

2. **合理设置 `Cache-Control`**
   - 对不常变动的资源设置较长的缓存时间（如 `max-age=31536000`）
   - 对频繁更新资源设置较短或 no-cache

3. **使用 Service Worker 实现渐进增强体验**
   - 支持离线访问、后台同步、消息推送等功能

4. **避免滥用 Cookie**
   - 减少 Cookie 体积，防止影响请求性能
   - 设置 `HttpOnly` 和 `Secure` 属性保障安全

---

### 六、总结

> 我可以用一句话总结：
> “**前端缓存是一种以空间换时间的性能优化策略，掌握不同缓存机制的使用场景和限制条件，有助于我们在实际项目中做出更高效、更安全的设计决策。**”

无论是从用户体验还是从系统性能角度出发，合理利用缓存都是前端工程师必备的一项核心技能。

---

## 🧠 知识延伸

- `Cache-Control: immutable` 的作用和优势（适用于永远不会变的内容）
- CDN 缓存与浏览器缓存的区别和配合使用
- 如何清除强缓存（强制刷新、禁用缓存、修改 URL）
- PWA 中 Service Worker 缓存策略设计
- 如何监控缓存命中率（Chrome DevTools Network 面板）


### 1. **`Cache-Control: immutable` 的作用和优势**

> **回答示例：**
> `Cache-Control: immutable` 表示资源一旦缓存后就永远不会改变，适用于像 CDN 上的静态资源（如带 hash 名的 JS/CSS 文件）。
>
> 相比普通的 `max-age=xxx`，它告诉浏览器完全不需要再去验证资源是否更新（跳过协商缓存），从而减少不必要的网络请求，提升性能。

---

### 2. **CDN 缓存与浏览器缓存的区别和配合使用**

> **回答示例：**
> - **CDN 缓存** 是部署在全球边缘节点上的服务器缓存，用于加速资源分发；
> - **浏览器缓存** 是客户端本地的缓存机制，用于减少重复请求；
> - 两者可以结合使用：静态资源通过 CDN 分发 + 浏览器设置强缓存，能显著提升加载速度并降低源站压力。

---

### 3. **如何清除强缓存？**

> **回答示例：**
> 强缓存一旦生效，浏览器就不会再请求服务器。要清除或绕过强缓存，常见方式有：
> - 用户端强制刷新页面（如 Windows 下按 `Ctrl + F5`）
> - 禁用缓存（Chrome DevTools 中 Network 面板勾选 "Disable cache"）
> - 修改资源 URL（如加版本号或 hash，例如 `/main.js?v=2.0` 或 `/main.a1b2c3.js`）

---

### 4. **PWA 中 Service Worker 缓存策略设计**

> **回答示例：**
> 在 PWA 应用中，Service Worker 是实现离线访问的核心。常见的缓存策略包括：
> - **缓存优先（Cache First）**：先读取缓存，失败后再请求网络
> - **网络优先（Network First）**：优先请求网络，失败时使用缓存
> - **Stale-While-Revalidate**：先返回缓存数据，同时后台更新缓存
>
> 这些策略可以通过 `Workbox` 等库来简化实现。

---

### 5. **如何监控缓存命中率？**

> **回答示例：**
> 可以通过 Chrome DevTools 的 **Network 面板** 观察每个资源的加载状态：
> - 显示 `(from memory cache)` 或 `(from disk cache)` 表示命中了强缓存；
> - 显示 `(from network)` 并返回 304，则表示走的是协商缓存；
> - 返回 200 并真正下载资源，说明未命中缓存。
>
> 此外，也可以通过埋点上报统计缓存命中情况，优化缓存策略。




## ❓ 其他相关

| 问题 | 简要回答 |
|------|-----------|
| 强缓存和协商缓存的区别？ | 强缓存不发请求直接使用缓存；协商缓存需要服务器确认资源是否更新 |
| ETag 和 Last-Modified 哪个更好？ | ETag 更精确，可以识别内容变化；Last-Modified 可能误判 |
| localStorage 和 Cookie 有什么区别？ | localStorage 容量大、不自动发送，适合存储非敏感数据；Cookie 自动随请求发送，适合身份验证 |
| 如何实现接口数据缓存？ | 可结合 localStorage 或 IndexedDB 存储响应结果，并设置过期时间 |
| 如何清除浏览器缓存？ | 修改 URL 参数、强制刷新（Ctrl+F5）、使用 `Cache-Control: no-cache` |

