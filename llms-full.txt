---
url: /novel/overachiever/pages/page10.md
---
# 《卷道仙尊》第十章：三日死卷！神识技横空出世！

—

【任务倒计时：72小时】

夜，寒星如铁，风声如锥。

草棚之中，杨易跪坐石床，识海如潮，系统光幕如流云飞转。

> 【卷命灵识·神图编辑器已开启】
> 当前识力：24
> 每次失败消耗：3~5点
> 推荐进度：三日内完成“稳定级神识技”构建

“好，那我就卷一个出来。”

他嘴角微扬，取出系统界面里那张初稿——

> 《无限肝魂卷轮阵（未定型）》

这不是普通神识技，而是一个**复合型识力爆发机制**，类似精神上的“自我过载模式”！

—

## 第一日 · 极限构图

他闭上眼，进入系统【识图编辑】空间。

此处如万千星辰构成的沙盘，他需以“意识笔锋”在虚空中一笔笔勾勒神图。

一次失败，识力如水溃散。

他不停尝试。

第一次：图形崩溃。

第二次：纹路逆反，识海剧痛如刃。

第三次：强行推演导致灵识震荡，七窍流血！

杨易咬着牙，撑着地面，仍不肯停手。

“失败，就再来。”

“你们能凭天赋刻神通，我就拿时间、一笔一画卷出来！”

—

## 第二日 · 火线点阵

系统弹出辅助模板。

> 【检测神图逻辑已成型：92%】
> 【是否模拟实际战斗状态？】

他咬牙启动模拟！

识海中出现一尊虚拟敌人，全身笼罩在火焰般的识力盔甲中，无法穿透。

他催动自己尚未完全成型的识图，只听轰一声——

**失败！**

识力反噬，整片识海扭曲，他当场昏死五息。

醒来后，他第一句话：

“系统，继续模拟。”

—

## 第三日 · 破图成技

【倒计时：6:00:00】

【识力剩余：8】

他握拳，咬紧牙关，发出最后的推演指令：

> 【卷命神图定型——卷识裂息击】

> 技法描述：
> 以极限意志牵引识力，于识海中模拟“连锁爆破”，对敌识海造成连环击穿；
> 一次性爆发全部识力，换取 2 秒内的精神压制。

副作用：**大脑如被铁锤砸击，须静养一日。**

杨易低头看着血迹斑斑的草席，苦笑：

“代价合理。”

系统提示跳出：

✅【已完成自创神识技】
🎯【是否提交宗门认证？】

“提交。”

—

## 第三日黄昏 · 村口试演

灵山宗监察使已携灵纹镜到场，连林冰婉都站在一旁，面露忧色。

“他真的成功了？”

而此时，一道风雷掠起，杨易衣衫褴褛，脚步微虚，却神色笃定地走来。

“我要进行神识技展示。”

监察使冷声道：“你确定？若不成，将会被记录为‘逆修失败体’，终身不得踏入修行之门。”

“确定。”

监察使点头，掷出一道灵识木偶：

“这是宗门识海模拟体，等同炼气初期修士识防。”

“若你能击穿，我就写推荐信。”

—

## 杨易闭眼 · 手指探出

“神图启动。”

“卷识裂息击——开。”

轰！！！

只见识海之力化作千道金红裂纹，从他脑后瞬间扩散，如蜘蛛网般笼罩木偶识核！

【识压临界！】

【裂息爆破启动！】

只听“咔”地一声，那具木偶竟从精神中**断裂**！

灵纹镜前闪过极高的识力波动值：

**【识压值：78】——远超同阶段修士三倍！**

监察使眼睛猛地一缩！

—

## 沉默 · 再沉默

三息、五息、十息——

监察使终于深吸一口气，拿出灵山宗令牌，在其上刻下名字：

“杨易，准入。”

“灵山宗外门特殊候选者，身份编号：逆命一号。”

—

## 众人沸腾！

林冰婉走上前，嘴角罕见带起一丝弧度。

“你做到了。”

杨易缓缓倒下，满脸苍白，神情却是从未有过的畅快。

“只是……交付一个项目而已。”

—

## 系统弹出：

> 🎉 【恭喜宿主】
> 【正式步入宗门体系：灵山外门·特殊席位】
> 🎁 奖励开启：
>
> * 卷识技自定义工具包
> * 灵山宗地图·外门资源区开放
> * 功法融合引擎（可重构普通功法为“卷系功法”）
> * 开启副本线：**灵识战场模拟**

—

**——第十章·完**

---

---
url: /learning/browserNetwork/modules/page5.md
---
# ✅ 什么是 OPTIONS 预检请求？

### 一、一句话总结

> **OPTIONS 请求是浏览器在发送某些跨域请求之前，自动发起的一个“探路”请求，用于确认服务器是否允许该跨域请求，这就是 CORS 中的预检机制（Preflight）。**

### 二、什么时候会触发 OPTIONS 预检请求？

当请求满足以下任意条件时，就会触发预检请求：

| 条件 | 示例 |
|------|------|
| 使用了除 `GET`、`HEAD`、`POST` 以外的方法 | 如 `PUT`、`DELETE`、`PATCH` |
| 设置了自定义请求头 | 如 `Authorization`、`X-Requested-With` 等 |
| 设置了 `Content-Type` 不是以下三种之一 | `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain` |

> 📌 **注意：** 即使是一个简单的 POST 请求，只要设置了 `application/json` 的 Content-Type，也会触发预检。

***

### 三、OPTIONS 请求做了什么？

1. 浏览器向目标服务器发送一个 `OPTIONS` 请求。
2. 请求头中包含：
   * `Origin`：当前页面的源
   * `Access-Control-Request-Method`：实际要使用的 HTTP 方法
   * `Access-Control-Request-Headers`：实际要设置的请求头字段
3. 服务器根据这些信息决定是否允许请求，并返回相应的响应头：
   * `Access-Control-Allow-Origin`
   * `Access-Control-Allow-Methods`
   * `Access-Control-Allow-Headers`
4. 如果服务器允许，则浏览器继续发送真正的请求；否则，阻止请求并报错。

***

### 四、为什么需要 OPTIONS 请求？

这是为了防止恶意网站通过 JavaScript 发送一些敏感或破坏性的请求（如 `DELETE` 删除资源），从而保护服务器安全。

> 🔒 它是 CORS 安全机制的一部分，确保服务器明确同意接受特定类型的跨域请求。

***

### 五、举个例子说明

假设你从 `https://a.com` 向 `https://api.b.com/user/1` 发送了一个带 Token 的 PUT 请求：

```js
fetch('https://api.b.com/user/1', {
  method: 'PUT',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer token123'
  },
  body: JSON.stringify({ name: 'Alice' })
});
```

浏览器发现这是一个跨域请求，且使用了 `PUT` 方法和自定义 Header（`Authorization`），于是会先发送一个 OPTIONS 请求来“探路”。

***

### 六、后端如何配置支持 OPTIONS 请求？

服务端必须正确响应 OPTIONS 请求，返回如下关键头部：

```http
Access-Control-Allow-Origin: https://a.com
Access-Control-Allow-Methods: PUT, GET, POST, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
```

否则，浏览器将拒绝后续的实际请求，并提示类似错误：

```
Blocked by CORS policy: No 'Access-Control-Allow-Origin' header present.
```

***

### 七、常见问题与调试建议

#### ❓ 怎么判断是否触发了 OPTIONS？

* 打开 Chrome DevTools 的 Network 面板，查看是否有 `OPTIONS` 类型的请求。
* 如果看到 `preflight` 标记，说明确实触发了预检。

#### ❓ OPTIONS 请求失败怎么办？

* 检查后端是否正确处理了 OPTIONS 请求；
* 确保返回了正确的 CORS 响应头；
* 检查服务器是否允许对应的 `method` 和 `header`。

***

### 八、总结

> 我可以用一句话总结：
> “**OPTIONS 请求是浏览器在发送复杂跨域请求前的‘通行证’，它确保服务器愿意接受这个请求，是 CORS 安全机制的重要组成部分。**”

掌握 OPTIONS 预检请求的原理，有助于我们更好地理解和解决开发中的跨域问题，尤其是在前后端分离架构中，能够更高效地定位和修复接口通信异常。

当然可以！以下是针对你之前提到的 **“延伸加分项”** 和 **“面试官可能会追问的问题”** 的简要参考答案，适合在面试中简洁清晰地表达。

***

## 🧠 知识延伸

### 1. **OPTIONS 请求是幂等的，可以被缓存**

* 是的，OPTIONS 是 HTTP 幂等方法之一。
* 浏览器可以通过 `Access-Control-Max-Age` 头部缓存预检结果，避免重复发送 OPTIONS 请求，提升性能。

```http
Access-Control-Max-Age: 86400  # 表示缓存一天
```

### 2. **Node.js Express 中如何配置 OPTIONS 支持**

使用中间件设置响应头即可：

```js
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (req.method === 'OPTIONS') {
    return res.sendStatus(204); // 快速返回
  }

  next();
});
```

### 3. **Nginx 中如何设置跨域响应头**

在 Nginx 配置文件中添加以下头部：

```nginx
add_header 'Access-Control-Allow-Origin' '*';
add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS';
add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization';
```

### 4. **微服务中跨域配置统一网关处理的优势**

* 避免每个服务单独配置 CORS，降低维护成本；
* 统一安全策略、日志记录、限流等逻辑；
* 提升系统可扩展性和一致性。

***

## ❓ 深层次

| 问题 | 简要回答 |
|------|-----------|
| **1. OPTIONS 请求会携带 Cookie 吗？** | 不会。OPTIONS 请求本身不携带 Cookie，但后续实际请求是否带 Cookie 取决于 `withCredentials` 设置。 |
| **2. 如何避免频繁触发 OPTIONS 请求？** | 使用 `Access-Control-Max-Age` 缓存预检结果，减少重复请求。 |
| **3. OPTIONS 请求失败了怎么排查？** | 查看响应头是否包含正确的 CORS 相关字段；检查服务器是否正确处理 OPTIONS 方法；查看后端日志是否有错误。 |
| **4. CORS 中简单请求和非简单请求的区别？** | 简单请求不会触发 OPTIONS，如 GET/POST + 标准 Content-Type；非简单请求（如 PUT、DELETE、自定义 Header）会触发预检。 |
| **5. 如何在 Node.js 或 Nginx 中配置跨域？** | Node.js：设置响应头并处理 OPTIONS；Nginx：通过 `add_header` 添加 CORS 相关字段。 |

---

---
url: /learning/optimization/modules/page3.md
---
# ✅ 前端缓存

### 一、一句话总结

> **前端缓存是指浏览器通过存储资源（如 HTML、CSS、JS、图片等）来减少重复请求、加快页面加载速度的一种机制。合理使用缓存可以显著提升用户体验并降低服务器压力。**

### 二、前端缓存的分类

#### 1. **HTTP 缓存**

这是最常见也是最重要的缓存方式，分为两种类型：

| 类型 | 响应头字段 | 特点 |
|------|-------------|------|
| **强缓存** | `Cache-Control` / `Expires` | 浏览器不发请求直接使用本地缓存，返回 200（from memory cache 或 disk cache） |
| **协商缓存** | `Last-Modified/If-Modified-Since`、`ETag/If-None-Match` | 浏览器发送请求确认资源是否更新，未变则返回 304 Not Modified |

##### ✅ 强缓存 vs 协商缓存区别：

* **强缓存优先级更高**，只有当它失效后才会走协商缓存。
* `ETag` 比 `Last-Modified` 更精确，能识别文件内容变化而非仅时间戳。

#### 2. **本地存储类缓存**

这些属于客户端持久化缓存手段，常用于保存用户状态或接口数据。

| 技术 | 容量 | 是否随请求发送 | 生命周期 | 适用场景 |
|------|------|------------------|-----------|------------|
| `localStorage` | ~5MB | 否 | 永久，除非手动清除 | 存储用户配置、token 等 |
| `sessionStorage` | ~5MB | 否 | 页面关闭即清除 | 临时会话数据 |
| `IndexedDB` | 几百 MB 到 GB | 否 | 可控 | 大量结构化数据存储 |
| `Cookie` | ~4KB | 是（每次请求都会携带） | 可设置过期时间 | 身份认证、跨域通信 |

#### 3. **Service Worker 缓存**

* 通过注册 Service Worker 实现更灵活的离线缓存策略。
* 支持拦截请求、自定义缓存逻辑，是 PWA（渐进式 Web 应用）的核心技术之一。

```js
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => response || fetch(event.request))
  );
});
```

***

### 三、如何选择合适的缓存策略？

| 场景 | 推荐方案 |
|------|----------|
| 静态资源（JS/CSS/图片） | 强缓存 + hash 文件名（如 main.a1b2c3.js） |
| 用户登录信息 | `localStorage` 或 `Cookie + HttpOnly` |
| 表单草稿、临时数据 | `sessionStorage` |
| 接口数据缓存 | 使用 `localStorage` 或 `IndexedDB` 结合缓存过期策略 |
| 离线应用 | Service Worker + Cache Storage |

***

### 四、缓存的优缺点

| 优点 | 缺点 |
|------|------|
| 提升页面加载速度，改善用户体验 | 缓存过期可能导致用户看到旧内容 |
| 减少服务器请求压力 | 不合理的缓存策略可能带来安全风险（如 Cookie 被盗） |
| 支持离线访问 | 占用本地存储空间 |

***

### 五、实际开发中的优化建议

1. **静态资源加版本号或 Hash**
   * 如 `/main.js?v=1.0.1` 或 `/main.abcd1234.js`
   * 避免因强缓存导致更新无效

2. **合理设置 `Cache-Control`**
   * 对不常变动的资源设置较长的缓存时间（如 `max-age=31536000`）
   * 对频繁更新资源设置较短或 no-cache

3. **使用 Service Worker 实现渐进增强体验**
   * 支持离线访问、后台同步、消息推送等功能

4. **避免滥用 Cookie**
   * 减少 Cookie 体积，防止影响请求性能
   * 设置 `HttpOnly` 和 `Secure` 属性保障安全

***

### 六、总结

> 我可以用一句话总结：
> “**前端缓存是一种以空间换时间的性能优化策略，掌握不同缓存机制的使用场景和限制条件，有助于我们在实际项目中做出更高效、更安全的设计决策。**”

无论是从用户体验还是从系统性能角度出发，合理利用缓存都是前端工程师必备的一项核心技能。

***

## 🧠 知识延伸

* `Cache-Control: immutable` 的作用和优势（适用于永远不会变的内容）
* CDN 缓存与浏览器缓存的区别和配合使用
* 如何清除强缓存（强制刷新、禁用缓存、修改 URL）
* PWA 中 Service Worker 缓存策略设计
* 如何监控缓存命中率（Chrome DevTools Network 面板）

### 1. **`Cache-Control: immutable` 的作用和优势**

> **回答示例：**
> `Cache-Control: immutable` 表示资源一旦缓存后就永远不会改变，适用于像 CDN 上的静态资源（如带 hash 名的 JS/CSS 文件）。
>
> 相比普通的 `max-age=xxx`，它告诉浏览器完全不需要再去验证资源是否更新（跳过协商缓存），从而减少不必要的网络请求，提升性能。

***

### 2. **CDN 缓存与浏览器缓存的区别和配合使用**

> **回答示例：**
>
> * **CDN 缓存** 是部署在全球边缘节点上的服务器缓存，用于加速资源分发；
> * **浏览器缓存** 是客户端本地的缓存机制，用于减少重复请求；
> * 两者可以结合使用：静态资源通过 CDN 分发 + 浏览器设置强缓存，能显著提升加载速度并降低源站压力。

***

### 3. **如何清除强缓存？**

> **回答示例：**
> 强缓存一旦生效，浏览器就不会再请求服务器。要清除或绕过强缓存，常见方式有：
>
> * 用户端强制刷新页面（如 Windows 下按 `Ctrl + F5`）
> * 禁用缓存（Chrome DevTools 中 Network 面板勾选 "Disable cache"）
> * 修改资源 URL（如加版本号或 hash，例如 `/main.js?v=2.0` 或 `/main.a1b2c3.js`）

***

### 4. **PWA 中 Service Worker 缓存策略设计**

> **回答示例：**
> 在 PWA 应用中，Service Worker 是实现离线访问的核心。常见的缓存策略包括：
>
> * **缓存优先（Cache First）**：先读取缓存，失败后再请求网络
> * **网络优先（Network First）**：优先请求网络，失败时使用缓存
> * **Stale-While-Revalidate**：先返回缓存数据，同时后台更新缓存
>
> 这些策略可以通过 `Workbox` 等库来简化实现。

***

### 5. **如何监控缓存命中率？**

> **回答示例：**
> 可以通过 Chrome DevTools 的 **Network 面板** 观察每个资源的加载状态：
>
> * 显示 `(from memory cache)` 或 `(from disk cache)` 表示命中了强缓存；
> * 显示 `(from network)` 并返回 304，则表示走的是协商缓存；
> * 返回 200 并真正下载资源，说明未命中缓存。
>
> 此外，也可以通过埋点上报统计缓存命中情况，优化缓存策略。

## ❓ 其他相关

| 问题 | 简要回答 |
|------|-----------|
| 强缓存和协商缓存的区别？ | 强缓存不发请求直接使用缓存；协商缓存需要服务器确认资源是否更新 |
| ETag 和 Last-Modified 哪个更好？ | ETag 更精确，可以识别内容变化；Last-Modified 可能误判 |
| localStorage 和 Cookie 有什么区别？ | localStorage 容量大、不自动发送，适合存储非敏感数据；Cookie 自动随请求发送，适合身份验证 |
| 如何实现接口数据缓存？ | 可结合 localStorage 或 IndexedDB 存储响应结果，并设置过期时间 |
| 如何清除浏览器缓存？ | 修改 URL 参数、强制刷新（Ctrl+F5）、使用 `Cache-Control: no-cache` |

---

---
url: /learning/core/modules/page3.md
---
# 🎯 JavaScript 中 原型 和 原型链 的理解

✅ 回答思路：

> 从“`什么是原型`”、“`对象如何查找属性`”、“`构造函数与原型的关系`”、“`原型链的作用`”以及“`继承实现的基础`”这几个方面来回答这个问题。

### 一、什么是原型（Prototype）？

JavaScript 是一门基于**原型的语言（prototype-based language）**，而不是像 Java 或 C++ 那样基于类（class-based）的语言。

* 每个函数都有一个 `prototype` 属性，它是一个对象。
* 这个对象是通过该函数创建的实例的原型（即所有实例共享这个原型上的属性和方法）。

```javascript
function Person(name) {
  this.name = name;
}

// 给原型添加方法
Person.prototype.sayHello = function() {
  console.log('Hello, I am ' + this.name);
};

const p1 = new Person('Alice');
p1.sayHello(); // Hello, I am Alice
```

***

### 二、什么是原型链（Prototype Chain）？

当访问一个对象的属性或方法时，如果该对象本身没有这个属性，JavaScript 引擎会去它的**原型对象**中查找；如果原型也没有，则继续向上查找，直到找到 `Object.prototype`，最终为 `null` —— 这就是**原型链**。

#### 🔁 查找顺序如下：

```
实例对象 → 构造函数的 prototype 对象 → Object.prototype → null
```

#### 示例说明：

```javascript
function Animal() {}
Animal.prototype.eat = function() {
  console.log('Eating...');
};

function Dog() {}
Dog.prototype = Object.create(Animal.prototype); // 设置原型链
Dog.prototype.bark = function() {
  console.log('Woof!');
};

const dog = new Dog();
dog.eat();  // Eating...
dog.bark(); // Woof!
```

在这个例子中，`Dog` 的原型继承自 `Animal` 的原型，从而实现了继承机制。

***

### 三、构造函数、实例、原型之间的关系

可以用一句话概括这三者的关系：

> **每一个构造函数都有一个 prototype 属性指向它的原型对象；每个实例都有一个内部属性 \[\[Prototype]]（可通过 **proto** 访问），指向构造函数的原型对象。**

```text
构造函数
   |
   | prototype
   ↓
原型对象 <--- 实例.__proto__
   ↑
[[Prototype]]
   |
实例对象
```

***

### 四、原型链的作用

1. **实现继承**：子类可以继承父类的方法和属性。
2. **共享数据**：多个实例共享原型上的方法，节省内存。
3. **属性查找机制**：JavaScript 就是通过原型链来查找对象属性的。

***

### 五、原型链的终点：Object.prototype

所有对象的原型链最终都会到达 `Object.prototype`，它是原型链的顶端。

```javascript
console.log(Object.prototype); // {constructor: ƒ, __defineGetter__: ƒ, ...}
console.log(Object.prototype.__proto__); // null
```

***

### 六、常见的误区 & 注意事项

| 问题 | 解释 |
|------|------|
| `__proto__` 与 `prototype` 的区别？ | `prototype` 是函数才有的属性；`__proto__` 是对象实例的属性，指向其构造函数的 `prototype` |
| 所有函数都有 prototype 吗？ | 是的，包括箭头函数（但不能作为构造函数使用） |
| 原型链能无限延伸吗？ | 不是，最终会到 `null` 结束 |

***

### ✅ 总结

> 在 JavaScript 中，每个对象都有一个原型（`__proto__`），对象在访问属性或方法时，会沿着原型链逐级查找，直到找到或者查找到 `null` 为止。原型链是 JavaScript 实现继承的核心机制。构造函数通过 `prototype` 属性将方法共享给其实例，而实例通过原型链访问这些方法和属性。

### 💡 扩展

| 内容 | 说明 |
|------|------|
| `__proto__` vs `prototype` | `prototype` 是函数才有的属性；`__proto__` 是对象实例的属性，指向其构造函数的 `prototype` |
| 原型继承 vs 类继承 | JS 是原型继承语言，没有真正的类；ES6 的 `class` 是语法糖 |
| 使用 `Object.create()` | 更灵活地创建对象并指定原型，避免构造函数副作用 |
| 原型污染 | 不要轻易修改 `Object.prototype`，可能带来安全风险和性能问题 |

---

---
url: /learning/browserNetwork/modules/page3.md
---
# 🎯跨域及 JSONP

### 一、什么是跨域？

> **一句话总结：**
> 跨域（Cross-Origin）是浏览器的一种同源策略（Same-origin Policy）限制，当请求的协议、域名或端口与当前页面不一致时，就会触发跨域限制。

#### ✅ 同源三要素：

只有当以下三个部分完全相同，才被认为是“同源”：

| 属性 | 示例 |
|------|------|
| 协议（Protocol） | `http` vs `https` |
| 域名（Host） | `www.example.com` vs `api.example.com` |
| 端口（Port） | `8080` vs `3000` |

> 比如从 `http://a.com` 请求 `http://b.com/data` 就会跨域。

***

### 二、为什么会有跨域限制？

> **一句话总结：**
> 跨域是为了防止恶意网站通过脚本访问其他网站的资源，保护用户数据安全，是浏览器的安全机制。

比如：如果浏览器不限制跨域，攻击者可以通过 `<script>` 或 AJAX 请求任意网站接口，获取用户的敏感信息（如 Cookie），造成 CSRF 攻击等安全问题。

***

### 三、常见的跨域场景和解决方案

| 方案 | 说明 | 适用场景 |
|------|------|----------|
| JSONP | 利用 `<script>` 标签不受跨域限制的特点 | GET 请求、兼容老浏览器 |
| CORS | 浏览器原生支持的跨域方案，需要后端配合设置响应头 | 现代浏览器推荐方案 |
| 代理服务器 | 前端请求同源后端，由后端转发请求目标服务 | 所有跨域场景通用 |
| WebSocket | 不受同源策略限制 | 实时通信场景 |
| postMessage | 跨文档通信 API，用于 iframe 或 window 间通信 | 多窗口/iframe 通信 |

***

### 四、JSONP 的原理和使用方式

> **一句话总结：**
> JSONP 是一种利用 `<script>` 标签没有跨域限制的特性，实现跨域请求的“伪异步”技术。

#### ✅ 原理：

1. 客户端定义一个回调函数，例如 `function handleResponse(data) { ... }`
2. 动态创建 `<script src="http://api.example.com/data?callback=handleResponse">`
3. 服务端接收到请求后，将数据包装成 `handleResponse({...})` 返回
4. 浏览器执行返回的 JS 脚本，调用回调函数处理数据

#### ✅ 示例代码：

```html
<script>
  function handleResponse(data) {
    console.log('接收到跨域数据:', data);
  }
</script>

<script src="http://api.example.com/data?callback=handleResponse"></script>
```

#### ✅ 优点：

* 兼容性好，适用于 IE6+ 等老旧浏览器
* 不依赖现代浏览器特性

#### ❌ 缺点：

* 只能发送 `GET` 请求
* 安全性差，容易引发 XSS 攻击
* 错误处理困难（无法监听错误状态）

***

### 五、JSONP 与 CORS 的区别

| 对比项 | JSONP | CORS |
|--------|-------|------|
| 请求类型 | 仅支持 GET | 支持所有 HTTP 方法 |
| 安全性 | 较低 | 更高（可控制来源、方法、头部） |
| 是否需要后端配合 | 是 | 是 |
| 是否支持自定义 headers | 否 | 是 |
| 是否支持 cookie | 否 | 是（需设置 `withCredentials`） |
| 兼容性 | 好（IE6+） | 现代浏览器支持良好 |

***

### 六、实际开发中的选择建议

| 场景 | 推荐方案 |
|------|-----------|
| 新项目、现代浏览器环境 | 使用 CORS |
| 老旧系统、需要兼容 IE | 使用 JSONP |
| 无法修改后端配置 | 使用代理服务器 |
| 实时通信需求 | 使用 WebSocket |
| 多窗口通信 | 使用 `postMessage` |

***

### 七、总结归纳（适合结尾）

> 我可以用一句话总结跨域和 JSONP：
> “**跨域是浏览器为了安全而施加的限制，JSONP 是早期解决跨域问题的一种变通手段，但已被更安全灵活的 CORS 所取代。**”

掌握这些知识不仅有助于理解前后端交互机制，还能在调试接口、部署项目时快速定位和解决问题。

## 🌟 知识延伸

### 1. **JSONP 的本质不是 JSON 格式**

* JSONP 全称是 “JSON with Padding”，它并不是真正的 JSON 数据格式。
* 它的本质是一个 JavaScript 函数调用，数据是作为参数传入函数执行的。
* 示例返回内容：
  ```js
  handleResponse({ "name": "Alice", "age": 25 });
  ```
* 这个结构不是一个纯粹的 JSON 字符串，而是一个 JS 表达式。

### 2. **CORS 是 W3C 标准，分为简单请求与非简单请求**

* **简单请求（Simple Request）**：满足以下条件：
  * 请求方法是 `GET`、`HEAD`、`POST`
  * 请求头只包含 `Accept`、`Content-Type`（只能是 `application/x-www-form-urlencoded`、`multipart/form-data` 或 `text/plain`）、`Origin`
* **非简单请求**：如使用了 `PUT`、`DELETE` 方法，或设置了自定义 Header，则会触发 **预检请求（preflight request）**，即浏览器先发送一个 `OPTIONS` 请求询问服务器是否允许跨域操作。

### 3. **使用 `fetch` 和 `XMLHttpRequest` 设置 CORS 相关参数**

#### 使用 `fetch` 发送带凭据的请求：

```js
fetch('https://api.example.com/data', {
  method: 'GET',
  mode: 'cors', // 默认值
  credentials: 'include' // 包含 Cookie
});
```

#### 使用 `XMLHttpRequest` 设置 CORS：

```js
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data');
xhr.withCredentials = true; // 允许携带 Cookie
xhr.send();
```

### 4. **如何在 Nginx / Node.js 中配置代理解决跨域？**

#### Nginx 配置示例：

```nginx
location /api/ {
    proxy_pass https://backend.example.com/;
    add_header 'Access-Control-Allow-Origin' '*';
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS';
}
```

#### Node.js Express 配置示例：

```js
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  next();
});
```

***

## ❓ 延申问题

### 1. **JSONP 是怎么工作的？为什么它能绕过跨域？**

> 答案：
> JSONP 利用了 `<script>` 标签不受同源策略限制的特点。浏览器允许页面加载外部 JS 资源，即使它们来自不同域名。通过动态创建 `<script>` 标签，并将回调函数名作为 URL 参数传递给服务端，服务端返回的是一段函数调用代码，从而实现跨域通信。

### 2. **JSONP 有哪些安全隐患？**

> 答案：
>
> * **XSS 攻击风险**：如果攻击者控制了目标接口，可以在响应中注入恶意脚本。
> * **无法防御 CSRF**：因为 JSONP 是 GET 请求，容易被伪造请求。
> * **无法监听错误**：无法判断请求失败的原因，如超时、404、500 错误等。

### 3. **CORS 的预检请求是什么？什么时候会触发？**

> 答案：
>
> * 预检请求是浏览器自动发起的一个 `OPTIONS` 请求，用于确认服务器是否允许当前跨域请求。
> * 触发时机包括：

* 使用了除 `GET`、`HEAD`、`POST` 以外的方法（如 `PUT`、`DELETE`）
* 设置了自定义请求头（如 `Authorization`、`X-Requested-With`）
* 设置了 `Content-Type` 为非标准类型（如 `application/json`）

### 4. **如果服务端没开启 CORS，前端还能怎么解决跨域？**

> 答案：
>
> * 使用 JSONP（仅限 GET 请求）
> * 通过后端代理（最常用方案）
> * 使用 Chrome 插件或本地代理临时绕过（仅开发环境）
> * 使用 Webpack DevServer 配置 proxy 解决开发阶段跨域
> * 使用浏览器启动参数禁用安全策略（不推荐）

### 5. **JSONP 和 Ajax 请求的区别？**

| 对比点 | JSONP | Ajax |
|--------|-------|------|
| 是否受跨域限制 | 否（利用 `<script>`） | 是（默认受限制） |
| 支持的请求方式 | 仅 GET | 所有 HTTP 方法 |
| 可否设置 Headers | 否 | 是 |
| 可否处理错误 | 否（无法捕获错误状态） | 是（可监听 error、status） |
| 安全性 | 较低 | 更高（配合 CORS） |

---

---
url: /learning/layoutStyle/modules/page2.md
---
# BFC

在前端开发中，BFC（Block Formatting Context，块级格式化上下文）是一个非常重要的概念，尤其是在布局和解决一些常见的CSS问题时。理解BFC有助于更精确地控制页面布局、避免元素重叠或覆盖等问题。

### 什么是BFC？

BFC是Web页面中的一种渲染区域，它是一块独立的渲染区域，其中的元素按照一定的规则进行布局，且与外部元素隔离。创建一个新的BFC可以确保内部元素的布局不会影响到外部元素，反之亦然。

### 如何创建BFC？

以下几种方式都可以创建一个BFC：

1. **根元素** (`<html>`)
2. **浮动元素** (`float` 不为 `none`)
3. **绝对定位元素** (`position` 值为 `absolute` 或 `fixed`)
4. **行内块元素** (`display: inline-block`)
5. **表格单元格** (`display: table-cell`，HTML表格单元格默认值）
6. **overflow 值不为 visible 的块元素** （如 `overflow: auto`, `overflow: scroll`, `overflow: hidden`）
7. **弹性盒子和网格布局** (`display: flex` 或 `display: grid` 的直接子元素）

### BFC的作用

1. **阻止外边距折叠**：在同一个BFC中的两个相邻块级盒子的垂直外边距会发生折叠（合并），但不同BFC之间则不会发生这种情况。

2. **包含浮动元素**：如果一个元素包含了浮动元素而没有足够的空间来包裹这些浮动元素，就会出现高度塌陷的问题。给这个元素创建一个新的BFC可以有效防止这个问题，因为它会自动扩展以包含其内部的浮动元素。

3. **防止元素重叠**：对于相邻的具有不同BFC的元素来说，它们之间的布局互不影响，这可以用来解决一些特定情况下的布局冲突，例如清除浮动或者处理多栏布局时元素间的相互作用。

### 实际应用案例

* **解决高度塌陷问题**：当一个父元素只包含浮动元素时，它的高度会塌陷。通过触发父元素的BFC（例如设置 `overflow: hidden`），可以让父元素正确包裹住其内部的所有浮动元素。

  ```css
  .clearfix {
    overflow: hidden;
  }
  ```

* **阻止外边距折叠**：当你不希望某些元素之间的外边距发生折叠时，可以通过创建新的BFC来实现这一点。

### 总结

掌握BFC的概念和如何创建BFC对于解决实际项目中的布局问题至关重要。它不仅可以帮助你更好地理解和调试现有布局，还能让你设计出更加健壮、灵活的页面结构。在面试中提到BFC时，除了解释它的基本概念之外，结合具体的场景和案例说明其用途将会是一个加分项。

---

---
url: /learning/core/modules/page6.md
---
# CommonJS 与模块化

## 🧠 一、什么是模块化？

模块化是一种将代码划分为独立、可复用部分的编程范式。它的目的是：

* **解耦**：减少模块之间的依赖
* **可维护性**：便于调试和更新
* **复用性**：可以在多个项目中重复使用

JavaScript 原生并不支持模块化，直到 ES6 才正式引入模块标准（ES Module）。

***

## 📦 二、CommonJS 是什么？

**CommonJS** 是一种模块化规范，最初是为了解决 Node.js 中的模块问题而提出的。

### 特点：

* 使用 `require()` 同步加载模块
* 使用 `module.exports` 和 `exports` 导出模块
* 主要用于服务端（Node.js）

### 示例：

```javascript
// math.js
exports.add = function(a, b) {
  return a + b;
};

// 或者
module.exports = {
  add: function(a, b) { return a + b; }
};

// app.js
const math = require('./math');
console.log(math.add(1, 2)); // 3
```

### 优点：

* 简单易懂，语法清晰
* Node.js 的默认模块系统

### 缺点：

* **同步加载**，不适合浏览器环境
* 不利于异步加载或按需加载

***

## 🌐 三、ES Module（ESM）

ES6 引入了官方模块系统 —— **ECMAScript Module（ESM）**

### 特点：

* 使用 `import` / `export` 语法
* 支持异步加载
* 静态分析能力强，适合 Tree Shaking

### 示例：

```javascript
// math.js
export function add(a, b) {
  return a + b;
}

// app.js
import { add } from './math.js';
console.log(add(1, 2));
```

### 优点：

* 官方标准，未来主流
* 支持异步加载
* 可以做静态优化（如 Tree Shaking）

### 缺点：

* 浏览器兼容性早期较差（现已广泛支持）
* 不能直接在旧版 Node.js 中使用（需要配置 type="module"）

***

## 🔁 四、CommonJS 与 ESM 的区别

| 特性 | CommonJS | ESM |
|------|----------|-----|
| 加载方式 | 同步 | 异步 |
| 语法 | `require()` / `module.exports` | `import` / `export` |
| 运行环境 | Node.js | 浏览器 & Node.js |
| 是否可动态导入 | ✅ | ❌（但可通过 `import()` 动态加载） |
| 是否支持 Tree Shaking | ❌ | ✅ |

***

## 🚀 五、模块化的发展历史简述

1. **无模块时代**：全局变量污染严重
2. **IIFE（立即执行函数）**：解决命名冲突
3. **AMD（Asynchronous Module Definition）**：适用于浏览器，如 RequireJS
4. **CMD（Common Module Definition）**：SeaJS 提出，类似 AMD
5. **CommonJS**：Node.js 默认模块系统
6. **ES Module（ES6）**：现代 JS 标准模块系统

***

## 💡 六、实际应用中的选择建议

| 场景 | 推荐模块系统 |
|------|----------------|
| Node.js 项目（旧版本） | CommonJS |
| Node.js 项目（v14+） | ESM（推荐） |
| Web 项目（现代框架如 Vue/React） | ESM |
| 需要做 Tree Shaking | ESM |
| 需要动态导入模块 | `import()`（ESM 的动态导入）|

***

## 🧪 七、常见面试题总结

### 1. 说说你对模块化的理解？

> 模块化是将一个复杂的系统拆分成多个独立的小单元，每个模块只关注自己的功能，提高可维护性和复用性。

### 2. CommonJS 和 ESM 有什么区别？

> 见上表对比。

### 3. 为什么 Node.js 最初使用 CommonJS 而不是 ESM？

> 因为 ES6 出现较晚，在那之前 Node.js 已经采用 CommonJS。而且服务器端更适合同步加载模块。

### 4. 如何在 Node.js 中使用 ESM？

> 在 `package.json` 中设置 `"type": "module"`，并使用 `.mjs` 扩展名或配合构建工具。

### 5. import 和 require 的本质区别是什么？

> `require` 是运行时加载，`import` 是编译时加载，可以进行静态分析。

***

## 📌 总结一句话：

> **CommonJS 是 Node.js 的模块规范，强调同步加载；ES Module 是 JS 官方标准模块系统，强调异步加载和静态分析。随着技术发展，ES Module 正在逐步取代 CommonJS 成为主流。**

## Webpack 如何处理 CommonJS 和 ESM 模块

Webpack 是一个非常强大的模块打包工具，能够处理多种模块系统，包括 CommonJS 和 ECMAScript Modules (ESM)。下面我将解释 Webpack 如何处理这两种模块系统。

### CommonJS 处理

在使用 CommonJS 模块时，你可以通过 `require` 来导入模块，并使用 `module.exports` 或 `exports` 导出模块。Webpack 原生支持 CommonJS 规范，可以无缝地解析和打包这类模块。

* **导入模块**：使用 `require()` 函数来引入其他模块。
* **导出模块**：使用 `module.exports` 或者 `exports` 对象来定义模块的输出。

例如：

```javascript
// math.js
module.exports = {
  add: function(a, b) { return a + b; }
};

// app.js
const math = require('./math');
console.log(math.add(1, 2)); // 输出 3
```

当 Webpack 遇到上述代码时，它会自动解析 `require` 调用，并将其转换为适当的依赖关系，最终生成一个或多个打包文件。

### ESM 处理

对于 ESM，即 ECMAScript 官方的模块系统，Webpack 同样提供了良好的支持。ESM 使用 `import` 和 `export` 关键字来分别导入和导出模块。

* **导入模块**：使用 `import` 语句。
* **导出模块**：使用 `export` 关键字。

例如：

```javascript
// math.js
export function add(a, b) {
  return a + b;
}

// app.js
import { add } from './math';
console.log(add(1, 2)); // 输出 3
```

Webpack 可以很好地理解这些 ESM 的语法，并将它们正确地解析为依赖关系。

### 兼容性处理

值得注意的是，Webpack 不仅支持单一类型的模块系统，而且可以在同一个项目中混合使用 CommonJS 和 ESM。这意味着你可以在一个文件中使用 `require`，同时在另一个文件中使用 `import`，Webpack 都能正确处理。

此外，Webpack 还支持动态导入（dynamic import），这是一种异步加载模块的方式，可以通过 `import()` 函数实现。这种方式不仅适用于 ESM，也可以与 CommonJS 模块一起使用，从而提供更灵活的代码分割和懒加载能力。

### 总结

无论是 CommonJS 还是 ESM，Webpack 都能有效地进行处理。它通过其内部的解析逻辑，将不同类型的模块请求转化为实际的文件依赖，并最终将整个应用打包成一个或多个文件。这使得开发者可以根据需要选择最合适的模块系统，或者在同一项目中结合使用两者，而无需担心兼容性问题。

---

---
url: /englishCorner/page.md
---
# English corner

***

---

---
url: /Interview/old/pages/page7.md
---
# ES6 新特性

**ES6（ECMAScript 2015）引入了许多新特性，使得JavaScript编程更加便捷和强大。大约15个特性**

## let/const

**`let` / `const`**：`let`允许你声明一个块级作用域的变量，解决了使用`var`时存在的变量提升问题。`const`用于声明常量，一旦赋值就不能再改变。

## 箭头函数

**箭头函数**：提供了一种更简洁的函数书写方式，如`const func = (arg) => arg * 2;`。它还改变了`this`的绑定规则，通常在回调函数中特别有用。

## 模板字符串

**模板字符串**：使用反引号(\`\`)定义的字符串，可以嵌入变量或表达式`${expression}`，方便动态生成字符串内容。

## 解构赋值

**解构赋值**：可以从数组或对象中提取数据并赋值给变量，例如`let {a, b} = {a: 1, b: 2};`。

## 默认参数

**默认参数**：允许为函数的参数设置默认值，如果调用时未传递对应的参数，则使用默认值，如`function(a=1){}`。

## rest 参数

**rest 参数**：使用`...`前缀的参数可以将不确定数量的参数表示为数组，如`function(...args){}`。

## 扩展运算符

**扩展运算符**：与rest参数类似，但用于解构数组或对象，或者是在函数调用时展开数组或对象，如`Math.max(...[1, 2, 3])`。

## class 类

**类**：提供了基于原型的面向对象编程的语法糖，使创建类和继承变得更加直观和简单。

## 模块化

**模块化**：支持原生的模块导入导出功能，通过`import`和`export`关键字实现代码的分割和复用。

## Promise

**`Promise`**：用于处理异步操作的对象，代表了一个异步操作的最终完成（或失败）及其结果值。

## Symbol

**`Symbol`**：一种基本数据类型，通常用来创建对象的唯一属性键。

## Set/Map

**`Set` / `Map`**：`Set`是值的集合，且每个值都是唯一的；`Map`是一个键值对的集合，键可以是任意类型。

## 迭代器与生成器

**迭代器与生成器**：迭代器是一种特殊对象，遵循特定协议以供循环遍历；生成器则允许定义一个返回迭代器对象的函数。

## Proxy/Reflect

**`Proxy` / `Reflect`**：`Proxy`用于创建一个对象的代理，从而拦截并重新定义基本操作（如属性查找、赋值等）。`Reflect`提供了一些静态方法来执行原本由操作符完成的操作（如`.deleteProperty`）。

## async/await

**`async`/`await`**：提供了一种更清晰的方式来处理异步代码，使得异步代码看起来像是同步代码一样易于理解。`async`函数返回一个`Promise`，而`await`等待这个`Promise`解决。

---

---
url: /learning/core/modules/page1.md
---
# ES6 特性

> ES6（ECMAScript 2015）是 JavaScript 的一次重大更新，引入了许多新特性，提升了代码的可读性、可维护性和开发效率。以下是 ES6 中一些重要的新特性总结：

### 一、变量声明 let/const

#### 1. `let` 和 `const`

* **块级作用域**：与 `var` 不同，`let` 和 `const` 声明的变量只在当前代码块内有效。
* **不存在变量提升**：必须先声明再使用。
* **`const` 声明常量**：值不能被重新赋值（如果是对象/数组，内容可以变）。

```javascript
{
  let a = 10;
  const b = 20;
}
console.log(a); // ReferenceError
```

***

### 二、箭头函数

#### 2. `=>` 箭头函数

* 更简洁的函数写法。
* **不绑定自己的 `this`**，继承外层作用域的 `this`。

```javascript
const add = (a, b) => a + b;
const greet = name => `Hello, ${name}`;
```

***

### 三、模板字符串

#### 3. 反引号 `` ` ``

* 支持多行字符串和变量插值。

```javascript
const name = "Alice";
console.log(`Hello, ${name}`); // Hello, Alice
```

***

### 四、解构赋值

#### 4. 数组和对象解构

* 快速从数组或对象中提取数据。

```javascript
const [a, b] = [1, 2];
const { name, age } = { name: 'Tom', age: 25 };
```

***

### 五、默认参数

#### 5. 函数参数默认值

* 如果没有传参或为 `undefined`，则使用默认值。

```javascript
function greet(name = 'Guest') {
  console.log(`Hello, ${name}`);
}
greet(); // Hello, Guest
```

***

### 六、展开运算符/剩余参数

#### 6. `...` 展开运算符（Spread）和剩余参数（Rest）

* 展开数组或对象：`[...arr]`
* 收集多个参数到一个数组中：`function foo(...args)`

```javascript
const arr = [1, 2, 3];
const newArr = [...arr, 4]; // [1, 2, 3, 4]

function sum(...nums) {
  return nums.reduce((acc, num) => acc + num);
}
sum(1, 2, 3); // 6
```

***

### 七、类（Class）

#### 7. 类语法糖

* 提供更清晰的面向对象编程方式。

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }

  sayHello() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

const p = new Person('Bob');
p.sayHello();
```

***

### 八、模块化 import/export

#### 8. `import` / `export`

* 实现模块的导入导出。

```javascript
// math.js
export const PI = 3.14;

// main.js
import { PI } from './math.js';
console.log(PI);
```

***

### 九、Promise 对象

#### 9. 异步处理机制

* 替代传统的回调函数，解决“回调地狱”。

```javascript
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

***

### 十、新数据结构 Map/Set

#### 10. `Map` 和 `Set`

* `Map`：键值对集合，支持任意类型作为键。
* `Set`：类似数组，但成员唯一。

```javascript
const map = new Map();
map.set('key', 'value');

const set = new Set([1, 2, 2, 3]); // Set {1, 2, 3}
```

***

### 十一、其他常用特性

#### 11. `Symbol` 类型

* 表示独一无二的值，常用于对象属性名防止冲突。

```javascript
const id = Symbol('id');
const obj = {
  [id]: 123
};
```

#### 12. `Proxy` 和 `Reflect`

* 用于拦截并定义对象的基本操作（如属性查找、赋值等）。

```javascript
const handler = {
  get(target, prop) {
    return prop in target ? target[prop] : 'Not found';
  }
};

const proxy = new Proxy({ a: 1 }, handler);
console.log(proxy.b); // Not found
```

### 十二、Proxy 与 Reflect

#### 一、Proxy（代理）

##### ✅ 作用：

`Proxy` 对象用于创建一个对象的代理，从而实现对该对象的某些操作进行拦截和自定义处理。

##### ✅ 基本语法：

```javascript
const proxy = new Proxy(target, handler);
```

* `target`：要包装的目标对象。
* `handler`：一个对象，其属性是一个个“陷阱函数”，用于拦截并自定义目标对象的操作。

##### ✅ 示例：

```javascript
const person = {
  name: 'Alice',
  age: 25
};

const handler = {
  get(target, prop) {
    if (prop in target) {
      return Reflect.get(...arguments);
    } else {
      return `Property "${prop}" does not exist.`;
    }
  },
  set(target, prop, value) {
    if (prop === 'age' && typeof value !== 'number') {
      throw new TypeError('Age must be a number');
    }
    return Reflect.set(...arguments);
  }
};

const proxyPerson = new Proxy(person, handler);

console.log(proxyPerson.name); // Alice
console.log(proxyPerson.gender); // Property "gender" does not exist.

proxyPerson.age = 'thirty'; // 报错：Age must be a number
```

##### ✅ 常见拦截操作（traps）：

| 拦截方法 | 用途 |
|----------|------|
| `get(target, propKey, receiver)` | 拦截读取属性 |
| `set(target, propKey, value, receiver)` | 拦截设置属性值 |
| `has(target, propKey)` | 拦截 `in` 运算符 |
| `deleteProperty(target, propKey)` | 拦截 `delete` 操作 |
| `apply(target, thisArg, args)` | 拦截函数调用 |
| `construct(target, args)` | 拦截 `new` 操作符 |

##### ✅ 应用场景：

1. **数据校验**
2. **日志记录 / 调试**
3. **虚拟属性**
4. **响应式系统（Vue.js 使用了类似机制）**
5. **权限控制**

***

#### 二、Reflect（反射）

##### ✅ 作用：

`Reflect` 是一个内置对象，提供了一组与对象操作相对应的方法，很多是与 `Proxy traps` 一一对应的。它通常用于在 `Proxy` 内部调用默认行为。

##### ✅ 特点：

* 方法名与 `Proxy` trap 一致，便于配合使用。
* 返回值更统一，避免了传统操作中的一些不一致性。
* 更符合面向对象的设计思想。

##### ✅ 常用方法：

| 方法 | 作用 |
|------|------|
| `Reflect.get(target, propKey[, receiver])` | 获取属性值 |
| `Reflect.set(target, propKey, value[, receiver])` | 设置属性值 |
| `Reflect.has(target, propKey)` | 判断属性是否存在（相当于 `propKey in target`） |
| `Reflect.deleteProperty(target, propKey)` | 删除属性（相当于 `delete target[propKey]`） |
| `Reflect.construct(target, argumentsList)` | 创建实例（相当于 `new target(...args)`） |
| `Reflect.apply(target, thisArgument, argumentsList)` | 调用函数（相当于 `target.apply(thisArg, args)`） |

##### ✅ 示例：

```javascript
const obj = { foo: 1 };

console.log(Reflect.get(obj, 'foo')); // 1
Reflect.set(obj, 'bar', 2);
console.log(obj.bar); // 2

console.log('foo' in obj);          // true
console.log(Reflect.has(obj, 'foo')) // true

Reflect.deleteProperty(obj, 'bar');
console.log(obj.bar); // undefined
```

***

#### 三、Proxy + Reflect 配合使用的优势

两者结合使用，可以让代理逻辑更清晰、代码更简洁。

##### ✅ 示例：自动记录访问属性的日志

```javascript
const product = {
  price: 100,
  stock: 50
};

const loggedProduct = new Proxy(product, {
  get(target, prop) {
    console.log(`Accessing property: ${prop}`);
    return Reflect.get(...arguments);
  },
  set(target, prop, value) {
    console.log(`Setting property: ${prop} to ${value}`);
    return Reflect.set(...arguments);
  }
});

console.log(loggedProduct.price); // Accessing property: price → 100
loggedProduct.stock = 40;         // Setting property: stock to 40
```

***

#### 四、扩展

> **ES6 中的 Proxy 和 Reflect 是什么？有什么用？**

> “ES6 引入了 `Proxy` 和 `Reflect` 两个新特性，用于更细粒度地控制对象的行为。\
> `Proxy` 可以理解为对象的‘代理’，允许我们拦截并自定义对象的各种操作，比如属性读写、函数调用等。\
> `Reflect` 是一组静态方法，用来以函数方式执行一些原本是语言内部操作的行为，比如获取或设置属性。\
> 它们经常一起使用，`Reflect` 提供默认行为，而 `Proxy` 可以在此基础上添加额外逻辑。\
> 这些特性非常适合做数据验证、日志记录、虚拟属性、甚至构建响应式框架（如 Vue.js 就借鉴了类似的机制）。”

***

#### 总结对比表：

| 特性       | 说明 |
|------------|------|
| `Proxy`    | 拦截对象操作，实现自定义行为 |
| `Reflect`  | 提供标准化的对象操作方法，常配合 Proxy 使用 |
| 典型应用   | 数据校验、日志记录、响应式编程、元编程等 |
| 注意事项   | 不适合代理数组的索引变化，性能略低，需谨慎使用 |

#### 总结

| 特性 | 用途 |
|------|------|
| `let` / `const` | 更安全的变量声明 |
| 箭头函数 | 更简洁的函数表达式 |
| 模板字符串 | 字符串拼接更方便 |
| 解构赋值 | 提取数据更高效 |
| 默认参数 | 函数参数更灵活 |
| 展开/剩余运算符 | 处理数组和参数更优雅 |
| 类 | 面向对象更清晰 |
| 模块化 | 代码组织更规范 |
| Promise | 异步流程更可控 |
| Map/Set/Symbol | 数据结构更强大 |

---

---
url: /Interview/css/pages/page1.md
---
# flex

> `Flex` 是 `Flexible Box` 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 `Flex` 布局。行内元素也可以使用 `Flex` 布局。`display: inline-flex;`

## 容器属性

### flex-direction 主轴方向

* `flex-direction：`属性决定主轴的方向（即项目的排列方向）
  ::: tip flex-direction属性的4个值
* row（默认值）：主轴为水平方向，起点在左端。
* row-reverse：主轴为水平方向，起点在右端。
* column：主轴为垂直方向，起点在上沿。
* column-reverse：主轴为垂直方向，起点在下沿。
  :::

### flex-wrap 如何换行

* `flex-wrap：`默认情况下，项目都排在一条线（又称"轴线"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行

::: tip flex-wrap属性的3个值

* nowrap （默认值）：不换行。
* wrap：换行，第一行在上方。
* wrap-reverse：换行，第一行在下方。
  :::

### flex-flow 前两个简写

* `flex-flow：` `flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`
* `justify-content：`项目在主轴上的对齐方式
* `align-items：`项目在交叉轴上如何对齐
* `align-content：`多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用

## 项目属性

* `order：`项目的排列顺序。数值越小，排列越靠前，默认为0
* `flex-grow：`项目的放大比例，默认为0，即如果存在剩余空间，也不放大
* `flex-shrink：`项目的缩小比例，默认为1，即如果空间不足，该项目将缩小
* `flex-basis：`在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小
* `flex：` `flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为0 1 auto。后两个属性可选
* `align-self：`允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`

---

---
url: /learning/layoutStyle/modules/page1.md
---
# flex

在前端开发中，`flex`（弹性盒子布局，Flexbox）是一种现代的、高效的 CSS 布局模型，特别适合用于一维布局（即行或列）。它简化了在不同屏幕尺寸和设备上对齐、分布和排列元素的方式，是响应式设计的重要工具。

***

### 一、Flex 布局的基本概念

Flex 布局由 **容器（flex container）** 和 **项目（flex items）** 组成：

* **Flex 容器（Flex Container）**：通过设置 `display: flex` 或 `display: inline-flex` 的元素。
* **Flex 项目（Flex Items）**：容器的直接子元素。

```css
.container {
  display: flex;
}
```

***

### 二、Flex 容器的主要属性

#### 1. `flex-direction`

定义主轴方向（即项目的排列方向）

```css
flex-direction: row | row-reverse | column | column-reverse;
```

* `row`（默认）：从左到右水平排列
* `row-reverse`：从右到左
* `column`：从上到下垂直排列
* `column-reverse`：从下到上

***

#### 2. `flex-wrap`

定义项目是否换行

```css
flex-wrap: nowrap | wrap | wrap-reverse;
```

* `nowrap`（默认）：不换行
* `wrap`：换行
* `wrap-reverse`：换行但方向相反

***

#### 3. `justify-content`

定义主轴上的对齐方式

```css
justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;
```

* `flex-start`（默认）：左对齐
* `center`：居中
* `space-between`：两端对齐，项目之间间距相等
* `space-around`：项目周围间距相等

***

#### 4. `align-items`

定义交叉轴上的对齐方式（适用于所有项目）

```css
align-items: stretch | flex-start | flex-end | center | baseline;
```

* `stretch`（默认）：拉伸填满容器
* `center`：居中
* `flex-start`：顶部对齐
* `flex-end`：底部对齐

***

#### 5. `align-content`

多行项目在交叉轴上的对齐方式（仅在换行时生效）

```css
align-content: stretch | flex-start | flex-end | center | space-between | space-around;
```

***

### 三、Flex 项目的主要属性

#### 1. `order`

定义项目的排列顺序，默认是 0，数值越小越靠前

```css
order: <integer>;
```

***

#### 2. `flex-grow`

定义项目的放大比例，默认为 0（不放大）

```css
flex-grow: 1; /* 项目将填满剩余空间 */
```

***

#### 3. `flex-shrink`

定义项目的缩小比例，默认为 1（空间不足时会缩小）

```css
flex-shrink: 0; /* 不缩小 */
```

***

#### 4. `flex-basis`

定义在分配多余空间之前，项目占据的主轴空间

```css
flex-basis: auto | <length>;
```

* `auto`：根据 width/height 属性决定大小
* 可以设置固定值如 `200px`

***

#### 5. `flex`（推荐使用简写）

```css
flex: <flex-grow> <flex-shrink> <flex-basis>;
```

常用简写：

* `flex: 1` → `flex: 1 1 0%`
* `flex: auto` → `flex: 1 1 auto`
* `flex: none` → `flex: 0 0 auto`

***

### 四、常见应用场景（面试常问）

| 场景 | 解法 |
|------|------|
| 水平垂直居中 | `display: flex; justify-content: center; align-items: center` |
| 等宽等高布局 | 使用 `flex: 1` 或 `flex-grow: 1` |
| 响应式导航栏 | 使用 `flex-wrap: wrap` 配合媒体查询 |
| 自适应间距 | 使用 `gap` 属性（CSS Grid 也支持） |
| 左右结构（如页眉页脚） | 使用 `justify-content: space-between` |

***

### 五、Flex 与 Grid 的区别（扩展）

| 特性 | Flexbox | CSS Grid |
|------|---------|----------|
| 布局维度 | 一维（行或列） | 二维（行和列） |
| 适合场景 | 项目排列、对齐 | 复杂页面布局 |
| 控制粒度 | 项目级控制 | 区域级控制 |
| 兼容性 | 较好 | 现代浏览器支持良好 |

***

### 六、面试题示例

#### 问题 1：如何实现一个水平垂直居中的 div？

```css
.container {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

***

#### 问题 2：flex: 1 是什么意思？

等价于 `flex: 1 1 0%`，表示项目将等比例放大以填满容器，不缩小。

***

#### 问题 3：flex-wrap 是干什么的？

控制项目是否换行。默认不换行（`nowrap`），设置为 `wrap` 时会根据容器大小自动换行。

***

### 七、注意事项

* Flex 布局只对直接子元素生效（不嵌套）
* 不适用于复杂的二维布局，建议用 CSS Grid
* `flex` 属性不能用于 `display: inline` 元素
* 使用 `gap` 属性时注意兼容性（IE 不支持）

---

---
url: /Interview/h5/page.md
---
# H5

## 移动端适配

* `rem` + 动态html的font-size

* 问题一：针对不同的屏幕，设置html不同的font-size

* 问题二：将原来要设置的尺寸，转化成rem单位

```bash
npm i lib-flexible
```

```js
// main.js
import 'lib-flexible'
```

```bash
postcss-px-to-rem -D
```

````

安装 `postcss-pxtorem` 插件

```bash
npm i postcss-pxtorem
````

项目文件配置

```js
// postcss.config.js
module.exports = {
  plugins: {
    'postcss-pxtorem': {
      rootValue: 37.5,
      propList: ['*']
      // selectorBlackList: ['van-'] // rem 只转换业务的 不转换vant ui的样式
    }
  }
}
```

::: details {open}

```js
{
    rootValue: 37.5, // (数字 | 函数) 表示根元素字体大小或根据input参数返回根元素字体大小
    unitPrecision: 5, // （数字）允许 REM 单位增长的十进制数。
    propList: ['font', 'font-size', 'line-height', 'letter-spacing'], // （数组）可以从 px 变为 rem 的属性。
    selectorBlackList: [], // （数组）要忽略并保留为 px 的选择器。
    replace: true, // （布尔值）替换包含 rems 的规则而不是添加后备。
    mediaQuery: false, // （布尔值）允许在媒体查询中转换 px。
    minPixelValue: 0, // （数字）设置要替换的最小像素值。
    exclude: /node_modules/i // （字符串、正则表达式、函数）忽略并保留为 px 的文件路径。
}
```

```js
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      viewportWidth: 375,  // 视口的宽度，对应的是我们设计稿的宽度
      viewportHeight: 667, // 视口的高度，对应的是我们设计稿的高度 (可选)
      unitPrecision: 5,    // 指定`px`转换为视窗单位值的小数位数
                           //（很多时候无法整除）
      viewportUnit: 'vw',  // 指定需要转换成的视窗单位，建议使用vw
      selectorBlackList: ['.ignore', '.hairlines'], // 指定不转换为视窗单位的类，
                           // 可以自定义，可以无限添加，建议定义一至两个通用的类名
      minPixelValue: 1,    // 小于或等于`1px`不转换为视窗单位
      mediaQuery: false    // 允许在媒体查询中转换`px`
    }
  }
}
```

:::

根节点 的字体大小来适配

```js
// screenRatioByDesign 设计图 rem16 / 9
(function init(screenRatioByDesign = 16 / 9) {
    // 文档的根元素
  let docEle = document.documentElement
  function setHtmlFontSize() {
    // 1. 计算当前屏幕宽高比
    var screenRatio = docEle.clientWidth / docEle.clientHeight;
    // 2. 动态计算字体大小
    var fontSize = (
        screenRatio > screenRatioByDesign
        ? (screenRatioByDesign / screenRatio) // 宽屏场景：按比例缩小
        : 1 // 窄屏场景：不缩放
    ) * docEle.clientWidth / 10; // 基准值 = 屏幕宽度的1/10
    // 3. 设置根元素字体大小
    docEle.style.fontSize = fontSize.toFixed(3) + "px";
  }
  setHtmlFontSize()
  window.addEventListener('resize', setHtmlFontSize)
})()
```

---

---
url: /learning/browserNetwork/modules/page4.md
---
# HTTP/1.1 和 HTTP/2 的区别

HTTP/1.1 和 HTTP/2 之间的差异反映了Web性能优化和协议效率的显著进步。以下是两者的主要区别：

### 1. **多路复用（Multiplexing）**

* **HTTP/1.1**：每个TCP连接只能处理一个请求/响应对，这导致了“队头阻塞”问题，即如果某个请求被延迟，则后续所有请求都必须等待。
* **HTTP/2**：支持在同一TCP连接上同时发起多个请求和响应，通过帧（frame）的形式进行数据传输，从而有效解决了队头阻塞的问题，提高了资源加载速度。

### 2. **头部压缩（Header Compression）**

* **HTTP/1.1**：每次请求和响应都会携带完整的HTTP头部信息，即使这些信息在多次请求中是重复不变的，造成了不必要的网络开销。
* **HTTP/2**：使用HPACK算法对HTTP头部进行压缩，减少了传输的数据量，尤其对于频繁交互的客户端来说，能显著降低延迟。

### 3. **服务器推送（Server Push）**

* **HTTP/1.1**：服务器只能被动响应客户端请求。
* **HTTP/2**：允许服务器主动向客户端推送资源，例如当用户请求页面时，服务器可以预先发送页面中引用的图片、CSS等资源，进一步减少页面加载时间。

### 4. **二进制分帧层（Binary Protocol）**

* **HTTP/1.1**：基于文本的协议，解析起来相对复杂且容易出错。
* **HTTP/2**：采用了二进制格式来封装数据，使得协议更加紧凑高效，并且更易于解析和处理。

### 5. **增强的安全性**

虽然不是强制性的，但大多数实现HTTP/2的服务端都要求使用HTTPS。这是因为HTTP/2的设计初衷之一就是要提供比HTTP/1.1更高的安全性。

### 6. **流量控制与优先级**

* **HTTP/2** 引入了更精细的流量控制机制以及资源加载优先级设定，允许浏览器更好地管理资源加载顺序和速率，以优化用户体验。

### 总结

HTTP/2相较于HTTP/1.1，在性能上有显著提升，主要体现在减少延迟、提高吞吐量以及改善整体用户体验方面。它通过引入新的特性如多路复用、头部压缩、服务器推送等，克服了HTTP/1.1中存在的许多限制。随着越来越多的网站和服务迁移到HTTP/2，互联网的整体性能得到了极大的改善。

## HTTP/2有哪些缺点或不足

尽管HTTP/2带来了许多改进，使得网页加载速度更快、效率更高，但它并非没有缺点或不足。以下是HTTP/2的一些主要缺点和面临的挑战：

### 1. **依赖于HTTPS**

* 尽管这不是严格意义上的“缺点”，但大多数浏览器只支持通过TLS（通常使用HTTPS）来实现HTTP/2，这意味着需要额外的配置工作以及可能增加的服务器成本。对于一些资源有限的小型网站或服务来说，这可能是一个负担。

### 2. **头部压缩的安全性问题**

* HTTP/2使用的HPACK算法虽然有效地压缩了HTTP头部，但也引入了新的攻击面，如CRIME和BREACH攻击。虽然这些攻击主要是针对早期版本的压缩技术，但它们强调了在实施任何类型的压缩时都需要谨慎处理潜在的安全风险。

### 3. **多路复用导致的队头阻塞问题依然存在**

* 虽然HTTP/2解决了HTTP/1.1中的线程级队头阻塞问题，但在单个TCP连接内部，如果某一个帧丢失或者延迟，仍然可能导致所谓的“队头阻塞”现象，因为TCP本身是有序传输的。这种情况下，即使其他数据帧已经到达，也必须等待丢失的数据帧重传之后才能继续处理。

### 4. **复杂度增加**

* 相比HTTP/1.1，HTTP/2增加了协议的复杂性，包括二进制分帧、流控制等特性，这对开发者和网络管理员提出了更高的要求。同时，这也意味着在故障排查和性能调优方面可能会遇到更多挑战。

### 5. **对老旧系统的兼容性**

* 并非所有现有的Web服务器、代理服务器以及客户端都能很好地支持HTTP/2。特别是在企业环境中，由于遗留系统和软件的存在，全面升级到HTTP/2可能需要较大的投入。

### 6. **资源密集型操作的限制**

* 在某些场景下，比如上传大文件或是进行长时间的WebSocket通信，HTTP/2的表现可能不如预期，尤其是在高延迟网络条件下，其多路复用的优势可能无法充分发挥。

## HTTP/3是如何解决HTTP/2的缺点

HTTP/3 是互联网协议演进的重要一步，它基于 QUIC 协议而非传统的 TCP，旨在解决 HTTP/2 中存在的一些关键问题。以下是 HTTP/3 如何针对性地解决 HTTP/2 缺点的具体方式：

### 1. **解决了队头阻塞问题**

* **HTTP/2 的问题**：虽然 HTTP/2 实现了多路复用，允许在同一个 TCP 连接上同时处理多个请求和响应，但如果一个数据包丢失（即发生丢包），所有其他的数据流都会被阻塞，直到丢失的数据包被重新传输，这就是所谓的“队头阻塞”。

* **HTTP/3 的解决方案**：HTTP/3 基于 UDP 的 QUIC 协议构建，每个数据流独立运行，这意味着即使某个流中的数据包丢失了，也不会影响其他流的正常传输。因此，HTTP/3 能够有效避免因单个数据包丢失而导致的整体阻塞问题。

### 2. **增强了安全性**

* **HTTP/2 的情况**：虽然 HTTP/2 支持通过 TLS 加密通信，但其实施依赖于服务器端的选择，且并非强制要求使用 HTTPS。

* **HTTP/3 的改进**：QUIC 协议默认集成了加密机制，确保了每次连接的安全性，无需额外配置即可获得强大的加密保护。这不仅简化了安全设置，还提高了整体网络通信的安全性。

### 3. **改善了连接建立速度**

* **HTTP/2 的挑战**：TCP 和 TLS 握手过程相对耗时，尤其是在首次访问新站点时，需要完成三次握手以及可能的 TLS 握手，增加了延迟。

* **HTTP/3 的优化**：QUIC 在设计时就考虑到了快速建立连接的需求，它可以在一次往返时间内完成握手，并支持会话恢复功能，大大减少了后续连接的时间开销。

### 4. **更好的移动环境适应性**

* **HTTP/2 的局限性**：由于 TCP 的特性，在移动网络等不稳定的环境中切换网络（如从Wi-Fi切换到移动数据）会导致现有的TCP连接中断，需要重新建立连接。

* **HTTP/3 的优势**：QUIC 具备内置的连接迁移能力，能够识别用户在网络间的切换而不中断当前的会话，从而提供更加流畅的用户体验。

### 5. **减少复杂度**

* **HTTP/2 的情况**：HTTP/2 引入了许多新的概念和技术，如帧、流控制等，增加了实现和调试的难度。

* **HTTP/3 的简化**：尽管 HTTP/3 在底层采用了不同的传输层协议（QUIC），但它保持了与 HTTP/2 类似的高层次API接口，使得开发者可以更容易地迁移到 HTTP/3，而不需要对应用程序进行重大修改。

通过上述改进，HTTP/3 不仅解决了 HTTP/2 中存在的技术瓶颈，还进一步提升了Web性能和安全性，特别是在不稳定网络条件下提供了更为可靠的传输保障。随着越来越多的服务提供商开始支持 HTTP/3，我们预计将会看到更加快速、稳定和安全的在线体验。

## QUIC 协议的具体工作原理

QUIC（Quick UDP Internet Connections）是一种由Google开发并被IETF标准化的传输层网络协议，旨在提供更快、更安全的连接体验。它基于UDP而非TCP，并集成了TLS加密，解决了传统TCP+TLS组合中的若干问题。下面是QUIC协议的具体工作原理概述：

### 1. **建立连接**

* **0-RTT 连接恢复**：QUIC的一个重要特性是能够在第一次数据交换时就发送应用数据，这被称为0-RTT（零往返时间）。这是通过使用前一次会话中保存的TLS会话票据来实现的，使得客户端可以在首次握手时就发送请求，而不需要等待完整的握手过程完成。

* **1-RTT 新建连接**：如果之前没有与服务器建立过连接，则需要进行1-RTT的新建连接过程，包括密钥协商等步骤。

### 2. **多路复用**

* QUIC允许在单个连接上同时处理多个独立的数据流，每个流都是相互独立的，这意味着即使某个流出现了丢包也不会影响其他流的数据传输。这种机制有效地避免了HTTP/2中存在的队头阻塞问题。

### 3. **内置加密**

* QUIC将加密作为协议的一部分，默认情况下所有数据都经过加密处理。这不仅提高了安全性，还简化了部署，因为不再需要单独配置TLS。

* 它使用TLS 1.3版本或更高版本来进行加密，确保了强大的安全性。

### 4. **流量控制和拥塞控制**

* **流量控制**：类似于TCP的滑动窗口机制，但应用于每个独立的流以及整个连接级别，以防止接收方被过量的数据淹没。

* **拥塞控制**：QUIC实现了比TCP更加灵活的拥塞控制算法，能够根据网络状况动态调整发送速率，减少重传次数，提高传输效率。

### 5. **连接迁移**

* 当用户在网络间切换（例如从Wi-Fi切换到移动数据）时，传统的TCP连接会被中断。然而，在QUIC中，由于每个连接都有一个唯一的连接ID，而不是依赖于IP地址和端口号，因此可以无缝地继续之前的对话而不丢失任何数据。

### 6. **错误检测与纠正**

* 虽然QUIC运行在不可靠的UDP之上，但它自身实现了类似TCP的确认机制，确保数据包被正确接收。此外，它还支持选择性确认（SACK），允许更精确地指示哪些段已成功接收。

### 总结

QUIC通过整合加密、优化连接建立流程、改进多路复用能力以及提供更好的错误处理和恢复机制，显著提升了互联网通信的性能和可靠性。随着越来越多的服务商开始支持QUIC，我们可以期待看到更加快速、稳定且安全的在线服务体验。特别是对于移动设备用户而言，QUIC提供的连接稳定性尤为重要。

---

---
url: /Interview/js/pages/page5.md
---
# HTTP1 和 HTTP2 的区别

## 🌟 前言

> “HTTP/2 是对 HTTP/1.x 协议的重大升级，主要目标是提升网页加载速度、减少延迟、提高安全性。它基于 Google 的 SPDY 协议发展而来。”

## 📊 分点对比：清晰易懂

|特性|	HTTP/1.1|	HTTP/2|
|--------:|--------:|--------:|
|传输格式	|明文（文本）|	二进制|
|多路复用|	不支持，需多个连接|	支持，单连接并发请求|
|头部压缩|	无压缩|	使用 HPACK 压缩|
|服务器推送	|不支持	|支持 Server Push|
|请求优先级|	不支持|	支持设置优先级|
|必须加密|	否	|推荐使用 TLS（通常加密）|

## 🔍 深入讲解每个关键点

**1. 二进制分帧层（Binary Framing Layer）**

* HTTP/1.1 是基于文本解析的，效率低。
* HTTP/2 将所有通信数据划分为更小的帧（frame），并封装成流（stream），实现高效的数据交换。

**2. 多路复用（Multiplexing）**

* HTTP/1.1 每个请求/响应需要单独的 TCP 连接或阻塞式串行传输。
* HTTP/2 可以在一个连接中发送多个请求和响应，避免“队头阻塞”，显著降低延迟。

**3. 头部压缩（HPACK）**

* HTTP/1.1 每次请求都重复发送大量相同的头部信息（如 Cookie、User-Agent）。
* HTTP/2 使用 HPACK 算法压缩头部，减少冗余数据传输。

**4. 服务器推送（Server Push）**

* HTTP/2 允许服务器主动将资源推送给客户端，提前缓存，加快页面渲染速度。

**5. 请求优先级（Stream Prioritization）**

* 客户端可以指定哪些请求更重要，服务器据此调整响应顺序，优化用户体验

## 💡 结合实际场景举例说明优势

**比如打开一个包含多个图片、CSS、JS 文件的网页：**

* HTTP/1.1 需要建立多个连接或排队请求，容易造成延迟；
* HTTP/2 可以在一个连接中同时加载所有资源，并通过服务器推送预加载关键资源，使页面加载更快。

---

---
url: /Interview/js/page.md
---
# JavaScript

## 1.js基本数据类型有哪些及它们的区别

::: details {open}

* 基本数据类型：`Undefined、Null、Boolean、Number、String、Symbol、BigInt`

* 引入数据类型：`Object`

* 其中 `Symbol` 和 `BigInt` 是 `ES6` 中新增的数据类型：

  * `Symbol` 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。
  * `BigInt` 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 `BigInt` 可以安全地存储和操作大整数，即使这个数已经超出了 `Number` 能够表示的安全整数范围。
    :::

## 2. 数据类型检测的方式有哪些

::: details {open}

* `typeof`
* `instanceof`
* `Object.prototype.toString.call`
* `Array.isArray`
* `=== null / === undefined`
* `Number.isNaN()`
  :::

## 3. 判断数组的方式有哪些

::: details {open}

* `obj.__proto__ === Array.prototype`
* `Array.isArrray(obj)`
* `Object.prototype.toString.call`
* `obj instanceof Array`
* `Array.prototype.isPrototypeOf`
  :::

## 4.请简述JavaScript中的this

::: details {open}
this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

* 第一种是`函数调用模式`，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
* 第二种是`方法调用模式`，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
* 第三种是`构造器调用模式`，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
* 第四种是 `apply 、 call 和 bind 调用模式`，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。
:::

## 5. let、const、var的区别

::: details {open}

* `块级作用域`： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：
  * 内层变量可能覆盖外层变量
  * 用来计数的循环变量泄露为全局变量
* `变量提升`： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。
* `给全局添加属性`： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。
* `重复声明`： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。
* `暂时性死区`： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。
* `初始值设置`： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
* `指针指向`： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

:::

### 6.原型和原型链

::: details {open}
在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 `prototype` 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 `prototype` 属性对应的值，在 `ES5` 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 `Object.getPrototypeOf()` 方法，可以通过这个方法来获取对象的原型。

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 `Object.prototype` 所以这就是新建的对象为什么能够使用 `toString()` 等方法的原因。
特点： `JavaScript` 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。
:::

## 7. 对闭包的理解

::: details {open}
`闭包是指有权访问另一个函数作用域中变量的函数`，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

**闭包有两个常用的用途**

* 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
* 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

PS: 闭包容易引起内存泄漏，谨慎使用
:::

## 8. 浏览器的垃圾回收机制

::: details {open}
**垃圾回收**：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

**回收机制**：

* Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
* JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。
* 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

#### （2）垃圾回收的方式

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。

**1）标记清除**

* 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
* 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

**2）引用计数**

* 另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。
* 这种方法会引起**循环引用**的问题：例如：`obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。

:::

## 9. 哪些情况会导致内存泄漏

> 前端内存泄漏指的是 JavaScript 中已分配的内存，由于代码逻辑或引用关系的问题，不再需要却无法被垃圾回收机制回收的情况。随着时间推移，泄漏的内存不断累积，会导致页面性能下降、卡顿、崩溃，甚至影响整个浏览器或设备的稳定性

::: details {open}

* 未清理的定时器 (Timers) 和回调 (Callbacks)
* 未移除的事件监听器 (Event Listeners)
* 闭包 (Closures) 引用
* 游离的 DOM 引用 (Dangling DOM References)
* 全局变量 (Global Variables)
* console.log 持有引用
* 第三方库管理不当，如echarts 提供了销毁方法
* 未关闭的连接和订阅 (WebSockets, Observables, Event Emitters)
* 缓存管理不当
  :::

## 10. ES6有哪些新特性

::: details {open}

* `箭头函数`
* `解构赋值`
* `模板字符串`
* `promise`
* `symbol` Symbol是ES6中引入的一种新的基本数据类型,用于表示一个独一无二的值,不能与其他数据类型进行运算
* 新的变量声明方式-`let`和`const`
* 模块化-es6新增了`模块化`，根据功能封装模块，通过`import导入`，然后通过`export导出`也可以使用`export default导出`
* `for…of` 循环,用于遍历可迭代对象(如数组、Map 和 Set)中的元素
* `扩展运算符`:使用 `...` 可以将数组或对象展开成多个参数,或者将多个参数合并成一个数组
* `展开运算符:`在ES6中用`...`来表示展开运算符,它可以将数组或者对象进行展开
* `Map 和 Set`，引入了两种新的数据结构，分别用于存储键值对和唯一值
* `Proxy`，允许在对象和函数调用等操作前后添加自定义的行为
* 类（`Class`），引入了面向对象编程中类的概念
* `默认参数`（Default Parameter），在定义函数时可以给参数设置默认值
  :::

## 11. 延迟加载js的方法

async 和 defer 属性（推荐）

**async：异步加载，不阻塞渲染，加载完成后立即执行（无序）**

```html
<script src="script.js" async></script>
```

**defer：异步加载，延迟到HTML解析完成后执行（按顺序）**

```html
<script src="script.js" defer></script>
```

|方法	|是否阻塞渲染	|执行顺序	|适用场景|
|:-----------------|:-----------------|:-----------------|:-----------------|
|async	|❌ 非阻塞|	❌ 无序|	独立脚本（如分析代码）|
|defer|	❌ 非阻塞|	✅ 顺序|	依赖 DOM/其他脚本的代码|
|动态注入|	❌ 非阻塞|	可控|	精准控制加载时机|
|IntersectionObserver|	❌ 非阻塞|	可控	图片/组件懒加载|
|import()|	❌ 非阻塞|	✅ 顺序|	现代框架路由懒加载（React/Vue）|

## 12. ES6 的箭头函数 (=>) 和 ES5 的普通函数 (function) 区别

|特性|	箭头函数 (=>)|	ES5 普通函数 (function)|
|:-----------------|:-----------------|:-----------------|
|语法|	更简洁（可省略 return、{}、()）|	标准语法 (function() {})|
|this 绑定	|继承自外层作用域（词法作用域）|	动态绑定（取决于调用方式）|
|构造函数	|❌ 不可用作构造函数（new 会报错）|	✅ 可用作构造函数|
|arguments 对象|	❌ 不存在|	✅ 存在|
|prototype 属性|	❌ 不存在|	✅ 存在|
|方法定义|	适合无独立 this 需求的场景|	适合需要动态 this 的方法|

## 13.前端性能优化

* 路由懒加载

> SPA 项目，一个路由对应一个页面，如果不做处理，项目打包后，会把所有页面打包成一个文件，当用户打开首页时，会一次性加载所有的资源，造成首页加载很慢，降低用户体验

* 组件懒加载
* 骨架屏
* 长列表虚拟滚动
* 图片优化
  * 图片懒加载
  * 字体图标
  * 转base64

## 14.前端资源加载方式

> async、defer 是 script 标签的专属属性，对于网页中的其他资源，可以通过 link 的 preload、prefetch 属性来预加载
> 如今现代框架已经将 preload、prefetch 添加到打包流程中了，通过灵活的配置，去使用这些预加载功能，同时我们也可以审时度势地向 script 标签添加 async、defer 属性去处理资源，这样可以显著提升性能

---

---
url: /learning/core/page.md
---
# JavaScript 核心

* ES6 新特性 (语言特性)

* 箭头函数 vs 普通函数 (ES6特性详解)

* 原型和原型链 (核心概念)

* 函数柯里化 (函数式编程技巧)

* 事件轮询 (函数式编程技巧)

* CommonJS 与 模块化 (模块化规范 - 通常指CommonJS与ES Module的区别)

* TypeScript (静态类型语言 - 指其核心概念、优势、类型系统等)

---

---
url: /Interview/js/pages/page9.md
---
# js宏任务和微任务

* js是单线程的语言

* js代码执行流程是：同步执行完了，才会走到事件轮询，进入到事件轮询：请求、事件、宏任务

* 事件轮询中包含：宏任务、微任务

**宏任务**： script （主代码块）、setTimeout 、setInterval 、setImmediate 、I/O 、UI rendering
**微任务**：process.nextTick（Nodejs） 、Promise 、Object.observe 、MutationObserver

---

---
url: /learning/vue/modules/page8.md
---
# keep-alive的实现原理和常用属性

`<keep-alive>` 是 Vue.js 中的一个抽象组件，它用于缓存动态组件实例，从而避免重复渲染和销毁过程，提高用户体验和性能。下面是 `<keep-alive>` 的一些常用属性及其简要说明：

#### 常用属性

1. **include**：字符串或正则表达式。只有名称匹配的组件会被缓存。
2. **exclude**：字符串或正则表达式。任何名称匹配的组件都不会被缓存。
3. **max**：数字。定义缓存组中可以保存的最大组件实例数量。

示例：

```vue
<keep-alive :include="['a', 'b']" :exclude="['c']" :max="10">
  <component :is="currentView"></component>
</keep-alive>
```

在这个例子中，仅当 `currentView` 是组件 `a` 或 `b` 时，它们才会被缓存，并且缓存的组件总数不会超过 10 个。

#### 实现原理

`<keep-alive>` 组件的工作原理主要依赖于 Vue 的生命周期钩子以及内部的状态管理机制。以下是其大致工作流程：

1. 当一个组件被包裹在 `<keep-alive>` 标签内并且开始渲染时，Vue 会检查该组件是否符合 `include` 和 `exclude` 规则（如果设置了的话）。符合条件的组件将进入缓存逻辑处理。

2. 如果组件已经被缓存过，则 `<keep-alive>` 不会重新创建一个新的实例，而是直接从缓存中取出并激活这个组件实例。这通过调用组件的 `deactivated` 生命周期钩子来暂停组件，而再次进入可视状态时调用 `activated` 钩子来恢复组件。

3. 对于新的组件或者不在缓存中的组件，Vue 将正常地挂载这些组件。一旦这些组件离开可视区域，它们的状态（包括 DOM 结构、组件实例等）会被存储在一个 LRU (Least Recently Used) 缓存中。

4. 如果设置了 `max` 属性，当达到最大缓存限制时，最近最少使用的组件实例将会被移除以腾出空间给新的组件实例。

通过这种方式，`<keep-alive>` 能够有效地管理组件的状态和生命周期，提升应用性能，特别是在需要频繁切换显示不同视图的情况下非常有用。

---

---
url: /Interview/vue/pages/page11.md
---
# keep-alive的常用属性有哪些及实现原理

keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。

常用的两个属性include/exclude，允许组件有条件的进行缓存。

两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。

keep-alive的中还运用了LRU(Least Recently Used)算法。

---

---
url: /Interview/vue/pages/page12.md
---
# nextTick 的作用是什么？他的实现原理是什么

在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用

* Promise
* MutationObserver
* setImmediate
* 如果以上都不行则采用setTimeout

定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列

---

---
url: /learning/vue/modules/page13.md
---
# nextTick 的作用是什么？他的实现原理是什么

`nextTick` 是一个在多个前端框架（如 Vue.js）中使用的方法，主要用于在下次 DOM 更新循环结束之后执行延迟回调。它的主要作用是在数据变化后等待 DOM 更新完成，然后执行指定的回调函数。

### 作用

当你修改了某些数据时，Vue 不能立即更新 DOM 以反映这些更改。它会在当前事件循环“tick”结束之后、新的渲染发生之前，将所有待处理的 DOM 更新刷新。使用 `nextTick` 可让你在 DOM 更新完成后执行代码。

例如，如果你需要在状态更新后立即操作新渲染的 DOM 元素，可以使用 `nextTick` 来确保 DOM 已经更新：

```javascript
// 修改数据
this.message = 'changed';

// 在 DOM 更新后执行
this.$nextTick(function() {
  // 操作更新后的 DOM
});
```

### 实现原理

`nextTick` 的实现依赖于环境。在浏览器环境中，它会尝试使用以下几种方式来安排回调函数的执行，按优先级顺序如下：

1. **Promise**：如果环境支持 Promise，则使用 Promise.resolve().then(callback) 安排回调。
2. **MutationObserver**：对于不支持 Promise 但支持 MutationObserver 的旧版浏览器，Vue 使用 MutationObserver 来调度微任务。
3. **setImmediate**：这是一个仅在 IE 中可用的方法，用于安排宏任务。
4. **setTimeout**：作为最后的选择，使用 setTimeout(callback, 0) 来安排回调。

通过这种方式，`nextTick` 能够尽可能地利用现代浏览器提供的高效异步执行机制，保证回调函数在当前调用栈清空且 DOM 渲染完毕之后尽快执行。这种机制使得 `nextTick` 成为一种非常有效的方式，可以在数据变更导致的 DOM 更新完成后进行后续操作。

---

---
url: /Interview/pc/page.md
---
# PC端

---

---
url: /Interview/react/page.md
---
# react 高频面试题

---

---
url: /Interview/vue/pages/page24.md
---
# ref 的作用是什么

ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：

如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素
如果用在子组件上，引用就指向组件实例

所以常见的使用场景有：

1.基本用法，本页面获取 DOM 元素
2.获取子组件中的 data
3.调用子组件中的方法

---

---
url: /learning/category/modules/page3.md
---
# TypeScript

关于 **TypeScript** 的问题通常会涉及基础概念、类型系统、与 JavaScript 的区别、实际应用等方面。

## 🧠 一、基础概念

### 1. 什么是 TypeScript？它和 JavaScript 有什么区别？

**答：**

* **TypeScript** 是由微软开发的开源编程语言，是 JavaScript 的超集，添加了可选的静态类型和面向对象等特性。
* **区别：**
  * TypeScript 支持类型检查（编译时），JavaScript 是动态类型。
  * TypeScript 支持接口（interface）、泛型、装饰器等高级语法。
  * TypeScript 需要通过编译转译成 JavaScript 才能在浏览器或 Node.js 中运行。

***

### 2. TypeScript 的核心优势是什么？

**答：**

* **类型安全**：可以在编译阶段发现潜在错误。
* **代码可维护性增强**：类型注解让代码更清晰。
* **支持最新的 ECMAScript 特性**，并通过 `target` 编译为旧版 JS。
* **更好的 IDE 支持**：如自动补全、重构、跳转定义等。
* **适用于大型项目**：类型系统帮助团队协作。

***

## 🔤 二、类型系统

### 3. 常见的 TypeScript 类型有哪些？

**答：**

* 原始类型：`number`, `string`, `boolean`, `null`, `undefined`, `symbol`
* 数组类型：`number[]` 或 `Array<number>`
* 元组类型：`[string, number]`
* 枚举类型：`enum`
* 任意类型：`any`（不推荐）
* 未知类型：`unknown`
* void：函数没有返回值
* never：永远不会返回的函数
* object：非原始类型的对象
* 联合类型：`string | number`
* 交叉类型：`T & U`

***

### 4. `any` 和 `unknown` 的区别？

**答：**

* `any`：完全跳过类型检查，可以赋值给任何变量，也可以调用其方法，但失去了类型保护。
* `unknown`：必须进行类型检查后才能操作，更安全。

```ts
let value: any = "hello";
value(); // 合法，但可能出错

let val: unknown = "hello";
val(); // ❌ 报错，不能直接调用
```

***

### 5. 什么是联合类型和类型守卫？

**答：**

* 联合类型使用 `|` 表示一个值可能是多个类型之一。
* 类型守卫用于在运行时判断具体类型。

```ts
function printId(id: number | string) {
  if (typeof id === 'string') {
    console.log(id.toUpperCase()); // 只有 string 类型才允许调用
  } else {
    console.log(id);
  }
}
```

***

## 📦 三、接口与类

### 6. `interface` 和 `type` 的区别？

**答：**
| 特性             | interface                     | type                          |
|------------------|-------------------------------|-------------------------------|
| 是否可合并       | ✅ 可以声明合并               | ❌ 不可以                      |
| 支持联合/交叉类型 | ❌                            | ✅                           |
| 支持映射类型     | ❌                            | ✅                           |
| 支持基本类型别名 | ❌                            | ✅ 如 `type ID = string;`     |

> 推荐优先使用 `interface`，除非需要用到 `type` 的高级功能。

***

### 7. TypeScript 中的访问修饰符有哪些？

**答：**

* `public`：默认，公共属性，可在外部访问。
* `private`：私有属性，只能在类内部访问。
* `protected`：受保护属性，可在类和子类中访问。
* `readonly`：只读属性，只能在声明或构造函数中赋值。

***

## 🔄 四、泛型与高级类型

### 8. 泛型是什么？举例说明它的用途。

**答：**

* 泛型允许我们编写可重用且类型安全的组件，延迟指定类型直到使用时。

```ts
function identity<T>(arg: T): T {
  return arg;
}

const result1 = identity<string>("hello");
const result2 = identity<number>(123);
```

***

### 9. 什么是条件类型（Conditional Types）？

**答：**

* 条件类型允许根据某个类型是否满足某种条件来决定另一个类型。

```ts
type IsString<T> = T extends string ? true : false;

type A = IsString<"hello">; // true
type B = IsString<123>;     // false
```

***

### 10. Partial、Required、Readonly 等内置类型的作用？

**答：**

* `Partial<T>`：将所有属性变为可选。
* `Required<T>`：将所有属性变为必填。
* `Readonly<T>`：将所有属性设为只读。
* `Pick<T, K>`：从 T 中选取一组属性 K。
* `Omit<T, K>`：从 T 中排除一组属性 K。
* `Record<K, T>`：创建一个键类型为 K，值类型为 T 的对象。

```ts
type User = { name: string; age: number };

type OptionalUser = Partial<User>;
// => { name?: string; age?: number }
```

***

## ⚙️ 五、其他常见问题

### 11. 如何配置 TypeScript 项目？常用配置项有哪些？

**答：**

* 创建 `tsconfig.json` 文件。
* 常用配置：
  * `"target"`：编译目标版本（如 `"ES2020"`）
  * `"module"`：模块系统（如 `"ESNext"`）
  * `"strict"`：开启严格模式
  * `"outDir"`：输出目录
  * `"rootDir"`：源文件目录
  * `"esModuleInterop"`：启用 ES 模块互操作
  * `"skipLibCheck"`：跳过库类型检查

***

### 12. 在 React 项目中如何使用 TypeScript？

**答：**

* 使用 `.tsx` 文件扩展名。
* 定义组件 props 的类型。
* 使用泛型定义 state 类型。
* 利用类型推断和类型注解提高安全性。

```tsx
interface Props {
  title: string;
  count?: number;
}

const MyComponent: React.FC<Props> = ({ title, count = 0 }) => {
  return (
    <div>
      <h1>{title}</h1>
      <p>Count: {count}</p>
    </div>
  );
};
```

***

## ✅ 总结建议

| 类型 | 建议 |
|------|------|
| 类型注解 | 明确写出类型，避免 `any` |
| 严格模式 | 开启 `strict`，防止潜在 bug |
| 工具使用 | 配合 VS Code + ESLint + Prettier 提升体验 |
| 实战练习 | 多写类型体操题（Type Challenges） |

好的！我们继续模拟一场 **TypeScript 面试**，这次是完整的问答形式。我扮演面试官，你扮演应聘者。

***

## 🧑‍💼 面试官：你好，欢迎来参加我们的前端开发岗位面试。我是今天的面试官张工。

### 问题 1：请简单介绍一下你对 TypeScript 的理解，它解决了 JavaScript 的哪些痛点？

***

### 👨‍💻 应聘者（你）回答：

TypeScript 是 JavaScript 的超集，它在 JavaScript 的基础上增加了静态类型系统和面向对象等高级特性。TypeScript 最终会被编译成普通的 JavaScript 代码，可以在任何支持 JavaScript 的环境中运行。

它主要解决了以下几个 JavaScript 的痛点：

1. **类型不安全**：JavaScript 是动态类型语言，变量类型在运行时才确定，容易引发意料之外的错误。而 TypeScript 在编译阶段就能检测出类型错误。
2. **可维护性差**：大型项目中，没有类型注解会让代码难以理解和维护。TypeScript 的类型系统提升了代码的可读性和可维护性。
3. **缺乏良好的 IDE 支持**：TypeScript 提供了更好的自动补全、重构、跳转定义等功能，提升开发效率。
4. **团队协作困难**：明确的类型定义有助于多人协作，减少沟通成本。

***

### 🧑‍💼 面试官反馈：

嗯，你的回答很全面，对 TypeScript 的核心优势把握得不错。那我再问一个进阶点的问题：

***

### 问题 2：`any` 和 `unknown` 类型有什么区别？什么时候应该使用它们？

***

### 👨‍💻 应聘者（你）回答：

`any` 和 `unknown` 都表示未知类型，但它们的安全级别不同：

* `any` 表示完全跳过类型检查，可以赋值给任意类型，也可以调用它的方法或属性，这会失去类型保护，不推荐使用。
* `unknown` 表示该类型未知，但在使用前必须进行类型检查或类型收窄，否则不能直接操作，这样更安全。

例如：

```ts
let value: any = "hello";
value(); // 合法，但可能出错

let val: unknown = "hello";
val(); // ❌ 报错，不能直接调用
```

使用场景：

* `any` 一般用于迁移旧项目或临时绕过类型检查（不推荐）。
* `unknown` 更适合处理不确定类型的值，比如用户输入、API 返回等，在使用前做类型守卫判断。

***

### 🧑‍💼 面试官反馈：

很好！你不仅说出了两者的区别，还给出了使用建议，说明你在实际项目中有一定的经验。

接下来考考你关于接口和类的理解：

***

### 问题 3：`interface` 和 `type` 有什么区别？你会在什么场景下选择其中一个？

***

### 👨‍💻 应聘者（你）回答：

`interface` 和 `type` 都可以用来定义对象的结构，但它们有一些关键差异：

| 特性             | interface                     | type                          |
|------------------|-------------------------------|-------------------------------|
| 是否可合并       | ✅ 可以声明合并               | ❌ 不可以                      |
| 支持联合/交叉类型 | ❌                            | ✅                           |
| 支持映射类型     | ❌                            | ✅                           |
| 支持基本类型别名 | ❌                            | ✅ 如 `type ID = string;`     |

使用建议：

* 如果只是定义对象结构，优先使用 `interface`，因为它支持声明合并，更适合扩展。
* 如果需要定义联合类型、交叉类型、映射类型或基本类型别名，就使用 `type`。

***

### 🧑‍💼 面试官反馈：

非常棒！你能结合使用场景给出建议，说明你对 TypeScript 的掌握已经超越了表面知识。

最后一个问题，考察一下泛型的理解：

***

### 问题 4：什么是泛型？能举个例子说明它的用途吗？

***

### 👨‍💻 应聘者（你）回答：

泛型是一种允许我们在定义函数、类或接口时，延迟指定具体类型的方式。它让我们写出既能保持类型安全又能复用的代码。

比如下面这个通用的 `identity` 函数：

```ts
function identity<T>(arg: T): T {
  return arg;
}

const str = identity<string>("hello"); // 返回 string
const num = identity<number>(123);     // 返回 number
```

在这个例子中，`T` 就是一个泛型参数，它会在调用时被替换成具体的类型，从而保证类型安全。

另一个常见的泛型使用场景是在组件或工具库中，例如 React 中定义组件 props 类型时，常常会配合泛型来提高灵活性。

***

### 🧑‍💼 面试官反馈：

非常好！你不仅解释清楚了泛型的概念，还举了一个清晰的例子，并提到了实际应用场景，加分项！

***

## ✅ 面试总结：

| 考察点           | 评分（满分5分） | 评价 |
|------------------|----------------|------|
| 基础概念理解     | 5              | 对 TypeScript 核心机制有清晰认识 |
| 类型系统掌握     | 5              | 区分 `any` 和 `unknown` 很到位 |
| 接口与类型定义   | 5              | 能区分 `interface` 和 `type` 并合理使用 |
| 泛型应用         | 5              | 能举例说明泛型并联系实际开发场景 |

🎉 **综合评价：表现优秀，具备扎实的 TypeScript 基础和实际应用能力。**
当然可以！自定义类型守卫（Custom Type Guard）是 TypeScript 中非常有用的一个特性，它允许我们在运行时检查某个值的类型，并帮助 TypeScript 更精确地推断该值的实际类型。通过自定义类型守卫，我们可以避免手动进行类型断言，使代码更加安全和清晰。

下面我将通过一个例子来说明如何使用自定义类型守卫。

### 示例场景

假设我们有一个函数 `printInfo`，它接收一个参数 `info`，这个参数可能是字符串、数字或包含 `name` 属性的对象之一。我们的目标是根据不同的类型打印不同的信息。

### 实现步骤

1. **定义类型**：首先定义可能的类型。
2. **创建类型守卫函数**：然后为每种类型创建类型守卫函数。
3. **在主函数中使用类型守卫**：最后，在主函数中使用这些类型守卫来区分不同类型并执行相应的逻辑。

```typescript
// 定义可能的类型
type Info = string | number | { name: string };

// 类型守卫函数 - 检查是否为字符串
function isString(value: any): value is string {
  return typeof value === 'string';
}

// 类型守卫函数 - 检查是否为数字
function isNumber(value: any): value is number {
  return typeof value === 'number';
}

// 类型守卫函数 - 检查是否为对象且包含name属性
function isNameObject(value: any): value is { name: string } {
  return typeof value === 'object' && value !== null && 'name' in value;
}

// 主函数
function printInfo(info: Info) {
  if (isString(info)) {
    console.log(`The info is a string: ${info}`);
  } else if (isNumber(info)) {
    console.log(`The info is a number: ${info}`);
  } else if (isNameObject(info)) {
    console.log(`The info object has a name property: ${info.name}`);
  }
}

// 测试
printInfo("Hello, TypeScript!");
printInfo(123);
printInfo({ name: "TypeScript" });
```

### 解释

* 在上述代码中，我们定义了三种类型守卫函数：`isString`, `isNumber`, 和 `isNameObject`。
* 这些函数都遵循一种模式，它们接受一个任意类型的参数，并返回一个布尔值，表示传入的参数是否符合预期的类型。
* 特别注意的是，每个类型守卫函数都使用了特殊的返回类型注解（如 `value is string`），这告诉 TypeScript 当函数返回 `true` 时，参数 `value` 的类型应该是括号中的那个类型。
* 在 `printInfo` 函数中，我们利用这些类型守卫来判断 `info` 参数的具体类型，并据此执行不同的操作。

这种方法不仅提高了代码的可读性和维护性，还能确保类型安全，减少潜在的错误。希望这个例子对你理解自定义类型守卫有所帮助！如果有任何问题或需要进一步解释，请告诉我。

当然可以！让我们通过另一个示例来进一步探讨类型守卫的使用。这次，我们将构建一个稍微复杂一点的例子，涉及到处理不同类型的用户输入，并根据输入类型执行不同的操作。

### 示例场景

假设我们正在开发一个应用，该应用需要处理用户的输入，这些输入可能是字符串、数字或包含特定属性的对象（例如用户信息）。我们的目标是根据不同类型的输入执行不同的逻辑。

### 实现步骤

1. **定义类型**：首先定义可能的输入类型。
2. **创建类型守卫函数**：然后为每种类型创建类型守卫函数。
3. **在主函数中使用类型守卫**：最后，在主函数中使用这些类型守卫来区分不同类型并执行相应的逻辑。

```typescript
// 定义可能的输入类型
type UserInput = string | number | { id: number; username: string };

// 类型守卫 - 检查是否为字符串
function isString(value: any): value is string {
  return typeof value === 'string';
}

// 类型守卫 - 检查是否为数字
function isNumber(value: any): value is number {
  return typeof value === 'number';
}

// 类型守卫 - 检查是否为对象且包含id和username属性
function isUserObject(value: any): value is { id: number; username: string } {
  return typeof value === 'object' && value !== null && 'id' in value && 'username' in value;
}

// 主函数
function processUserInput(input: UserInput) {
  if (isString(input)) {
    console.log(`Received a string input: ${input}`);
  } else if (isNumber(input)) {
    console.log(`Received a numeric input: ${input}`);
  } else if (isUserObject(input)) {
    console.log(`Received an object input with ID ${input.id} and username ${input.username}`);
  } else {
    console.error('Unknown input type');
  }
}

// 测试
processUserInput("Hello, World!"); // 字符串输入
processUserInput(12345);            // 数字输入
processUserInput({ id: 67890, username: "john_doe" }); // 对象输入
```

### 解释

* 在这个例子中，我们定义了三种可能的输入类型：`string`, `number`, 和 `{ id: number; username: string }`。
* 我们为每种类型实现了类型守卫函数，分别是 `isString`, `isNumber`, 和 `isUserObject`。每个函数都接受任意类型的参数，并返回一个布尔值，表示传入的参数是否符合预期的类型。
* 特别注意的是，类型守卫函数使用了特殊的返回类型注解（如 `value is string`），这告诉 TypeScript 当函数返回 `true` 时，参数 `value` 的类型应该是括号中的那个类型。
* 在 `processUserInput` 函数中，我们利用这些类型守卫来检查 `input` 参数的具体类型，并据此执行不同的操作。

通过这种方式，我们可以确保程序能够正确地处理各种类型的输入，同时保持代码的清晰和易于维护性。此外，这也提高了代码的安全性，减少了运行时错误的可能性。希望这个例子能帮助你更好地理解如何在实际项目中使用类型守卫！如果有任何问题或需要进一步的解释，请随时告诉我。

### 类型守卫 vs. 类型断言

在 TypeScript 中，类型守卫（Type Guard）和类型断言（Type Assertion）都是用于处理类型不确定的情况，但它们的工作机制和使用场景有所不同。

#### **类型守卫（Type Guard）**

* **定义**：类型守卫是一种特殊的函数或结构，它能够在运行时检查某个值的类型，并告知 TypeScript 编译器该值的具体类型。
* **工作原理**：通过返回布尔值来判断一个值是否属于特定类型。当条件为真时，TypeScript 会将该值视为指定类型。
* **常见实现方式**：
  * 使用 `typeof`、`instanceof` 关键字。
  * 自定义类型守卫函数，返回类型谓词如 `value is Type`。
* **优点**：增强代码安全性，避免手动强制转换可能带来的错误。
* **示例**：
  ```typescript
  function isString(value: any): value is string {
    return typeof value === 'string';
  }

  function processData(input: unknown) {
    if (isString(input)) {
      console.log(`Processing a string: ${input}`);
    }
  }
  ```

#### **类型断言（Type Assertion）**

* **定义**：类型断言允许开发者手动告诉编译器某个值的实际类型，跳过编译器的类型检查。
* **工作原理**：通过 `<Type>value` 或 `value as Type` 的语法形式直接指定值的类型。
* **应用场景**：当你比编译器更了解某个值的确切类型时使用。
* **缺点**：如果断言不准确，可能会导致运行时错误，因此需要谨慎使用。
* **示例**：
  ```typescript
  const someValue: unknown = "This is a string";
  const strLength: number = (someValue as string).length;
  ```

### 实际应用场景：表单验证中的类型守卫

假设我们正在开发一个用户注册页面，其中包含一个表单，用户可以输入用户名、邮箱地址和年龄。我们需要对这些输入进行验证，并根据不同的输入类型执行相应的操作。

```typescript
type UserInput = { username?: string; email?: string; age?: number };

// 类型守卫 - 检查是否存在且为非空字符串
function isNonEmptyString(value: any): value is string {
  return typeof value === 'string' && value.trim().length > 0;
}

// 类型守卫 - 检查是否存在且为有效的数字
function isValidNumber(value: any): value is number {
  return typeof value === 'number' && !isNaN(value);
}

// 表单验证函数
function validateUserInput(input: UserInput) {
  let errors: string[] = [];

  if (!isNonEmptyString(input.username)) {
    errors.push("Username must be a non-empty string.");
  }

  if (!isNonEmptyString(input.email)) {
    errors.push("Email must be a non-empty string.");
  } else if (!/\S+@\S+\.\S+/.test(input.email)) {
    errors.push("Invalid email format.");
  }

  if (!isValidNumber(input.age)) {
    errors.push("Age must be a valid number.");
  } else if (input.age < 18) {
    errors.push("You must be at least 18 years old.");
  }

  if (errors.length === 0) {
    console.log("Registration successful!");
  } else {
    console.error("Errors occurred:", errors);
  }
}

// 测试
validateUserInput({
  username: "john_doe",
  email: "john@example.com",
  age: 25
});
```

在这个例子中，我们使用了自定义类型守卫来确保每个字段都符合预期的格式和类型。这不仅提高了代码的安全性，还使得逻辑更加清晰易读。相比直接使用类型断言，类型守卫更能保证数据的有效性和准确性，减少潜在的运行时错误。

**能否举例说明类型守卫在函数重载中的应用？**

当然可以！类型守卫不仅可以在简单的条件判断中使用，还可以在函数重载（Function Overloading）中发挥重要作用。通过结合类型守卫和函数重载，我们可以根据传入参数的不同类型执行不同的逻辑，同时保持良好的类型安全性和代码可读性。

### 示例场景

假设我们需要编写一个函数 `processData`，它能够处理两种类型的输入：一种是普通的字符串，另一种是一个包含数据和处理方式的对象。对于字符串输入，我们直接返回其大写形式；对于对象输入，则根据指定的处理方式（如转为大写或小写）来处理数据。

### 实现步骤

1. **定义类型**：首先定义可能的输入类型。
2. **创建函数重载声明**：然后为每种类型的输入创建函数重载声明。
3. **实现主函数**：在主函数中使用类型守卫来区分不同类型并执行相应的操作。

```typescript
// 定义可能的输入类型
type ProcessInput = string | { data: string; action: 'uppercase' | 'lowercase' };

// 函数重载声明
function processData(input: string): string;
function processData(input: { data: string; action: 'uppercase' }): string;
function processData(input: { data: string; action: 'lowercase' }): string;

// 主函数实现
function processData(input: ProcessInput): string {
  if (typeof input === 'string') {
    // 类型守卫 - 确保input是字符串
    return input.toUpperCase();
  } else if ('action' in input && input.action === 'uppercase') {
    // 类型守卫 - 确保input是一个特定的对象且action为'uppercase'
    return input.data.toUpperCase();
  } else if ('action' in input && input.action === 'lowercase') {
    // 类型守卫 - 确保input是一个特定的对象且action为'lowercase'
    return input.data.toLowerCase();
  } else {
    throw new Error('Invalid input type');
  }
}

// 测试
console.log(processData("hello")); // 输出: HELLO
console.log(processData({ data: "world", action: 'uppercase' })); // 输出: WORLD
console.log(processData({ data: "TypeScript", action: 'lowercase' })); // 输出: typescript
```

### 解释

* 在上述例子中，我们首先定义了可能的输入类型 `ProcessInput`，它可以是字符串或包含 `data` 和 `action` 属性的对象。
* 接着，我们使用了函数重载声明来明确 `processData` 函数可以根据不同类型的输入返回不同的结果。
* 在主函数 `processData` 的实现中，我们利用类型守卫来区分输入的具体类型：
  * 使用 `typeof input === 'string'` 来检查输入是否为字符串，并对字符串进行大写转换。
  * 使用 `'action' in input && input.action === 'uppercase'` 来检查输入是否为带有 `action` 为 `'uppercase'` 的对象，并对对象中的 `data` 字段进行大写转换。
  * 同样地，处理 `action` 为 `'lowercase'` 的情况。

这种方式不仅提高了代码的灵活性和可维护性，还能确保在编译阶段就能发现潜在的类型错误。此外，通过结合类型守卫和函数重载，使得函数的行为更加直观和易于理解，增强了代码的安全性和可读性。

类型守卫不仅在简单的条件判断中非常有用，在接口实现时也可以发挥重要作用。特别是在处理多态行为（即基于对象的不同类型执行不同的操作）时，类型守卫可以帮助我们确定对象的具体类型，并根据其类型执行相应的逻辑。

### 示例场景

假设我们正在开发一个应用，其中包含不同类型的用户（比如普通用户和管理员）。我们需要定义一个通用的 `User` 接口，然后根据不同类型的用户实现特定的行为。例如，普通用户只能查看信息，而管理员可以修改信息。

### 实现步骤

1. **定义接口**：首先定义一个通用的 `User` 接口以及两个具体的用户类型接口。
2. **创建类型守卫函数**：为每种具体类型的用户创建类型守卫函数。
3. **在方法中使用类型守卫**：在需要区分用户类型的方法中使用这些类型守卫来执行不同的操作。

```typescript
// 定义通用的 User 接口
interface User {
  name: string;
}

// 定义普通用户接口
interface RegularUser extends User {
  role: 'regular';
}

// 定义管理员接口
interface AdminUser extends User {
  role: 'admin';
  canModify: boolean;
}

// 类型守卫 - 检查是否为普通用户
function isRegularUser(user: User): user is RegularUser {
  return (user as RegularUser).role === 'regular';
}

// 类型守卫 - 检查是否为管理员
function isAdminUser(user: User): user is AdminUser {
  return (user as AdminUser).role === 'admin';
}

// 定义一个处理用户行为的类
class UserManager {
  performAction(user: User) {
    if (isRegularUser(user)) {
      console.log(`${user.name} is a regular user and can only view information.`);
    } else if (isAdminUser(user)) {
      if (user.canModify) {
        console.log(`${user.name} is an admin and can modify information.`);
      } else {
        console.log(`${user.name} is an admin but cannot modify information at this time.`);
      }
    } else {
      console.error('Unknown user type');
    }
  }
}

// 测试
const regularUser: RegularUser = { name: "Alice", role: "regular" };
const adminUser: AdminUser = { name: "Bob", role: "admin", canModify: true };

const userManager = new UserManager();
userManager.performAction(regularUser); // 输出: Alice is a regular user and can only view information.
userManager.performAction(adminUser);   // 输出: Bob is an admin and can modify information.
```

### 解释

* 在这个例子中，我们首先定义了一个通用的 `User` 接口，以及两个扩展自 `User` 的具体类型接口：`RegularUser` 和 `AdminUser`。
* 然后，我们为每个具体类型实现了类型守卫函数 `isRegularUser` 和 `isAdminUser`。这些函数接收一个 `User` 类型的对象，并通过检查 `role` 属性来确定对象的具体类型。
* 在 `UserManager` 类的 `performAction` 方法中，我们使用这些类型守卫来区分传入用户的类型，并根据用户的类型执行不同的操作：
  * 如果是普通用户，则输出该用户只能查看信息的消息。
  * 如果是管理员，则进一步检查 `canModify` 属性以决定管理员是否有权限修改信息。

这种方式使得代码可以根据对象的实际类型动态地执行不同的逻辑，同时保持了良好的类型安全性和代码可读性。类型守卫在这里起到了关键作用，它帮助我们在运行时准确地区分不同类型，并相应地调整程序的行为。

---

---
url: /learning/engineering/modules/page4.md
---
# TypeScript

关于 **TypeScript** 的问题通常会涉及基础概念、类型系统、与 JavaScript 的区别、实际应用等方面。

## 🧠 一、基础概念

### 1. 什么是 TypeScript？它和 JavaScript 有什么区别？

**答：**

* **TypeScript** 是由微软开发的开源编程语言，是 JavaScript 的超集，添加了可选的静态类型和面向对象等特性。
* **区别：**
  * TypeScript 支持类型检查（编译时），JavaScript 是动态类型。
  * TypeScript 支持接口（interface）、泛型、装饰器等高级语法。
  * TypeScript 需要通过编译转译成 JavaScript 才能在浏览器或 Node.js 中运行。

***

### 2. TypeScript 的核心优势是什么？

**答：**

* **类型安全**：可以在编译阶段发现潜在错误。
* **代码可维护性增强**：类型注解让代码更清晰。
* **支持最新的 ECMAScript 特性**，并通过 `target` 编译为旧版 JS。
* **更好的 IDE 支持**：如自动补全、重构、跳转定义等。
* **适用于大型项目**：类型系统帮助团队协作。

***

## 🔤 二、类型系统

### 3. 常见的 TypeScript 类型有哪些？

**答：**

* 原始类型：`number`, `string`, `boolean`, `null`, `undefined`, `symbol`
* 数组类型：`number[]` 或 `Array<number>`
* 元组类型：`[string, number]`
* 枚举类型：`enum`
* 任意类型：`any`（不推荐）
* 未知类型：`unknown`
* void：函数没有返回值
* never：永远不会返回的函数
* object：非原始类型的对象
* 联合类型：`string | number`
* 交叉类型：`T & U`

***

### 4. `any` 和 `unknown` 的区别？

**答：**

* `any`：完全跳过类型检查，可以赋值给任何变量，也可以调用其方法，但失去了类型保护。
* `unknown`：必须进行类型检查后才能操作，更安全。

```ts
let value: any = "hello";
value(); // 合法，但可能出错

let val: unknown = "hello";
val(); // ❌ 报错，不能直接调用
```

***

### 5. 什么是联合类型和类型守卫？

**答：**

* 联合类型使用 `|` 表示一个值可能是多个类型之一。
* 类型守卫用于在运行时判断具体类型。

```ts
function printId(id: number | string) {
  if (typeof id === 'string') {
    console.log(id.toUpperCase()); // 只有 string 类型才允许调用
  } else {
    console.log(id);
  }
}
```

***

## 📦 三、接口与类

### 6. `interface` 和 `type` 的区别？

**答：**
| 特性             | interface                     | type                          |
|------------------|-------------------------------|-------------------------------|
| 是否可合并       | ✅ 可以声明合并               | ❌ 不可以                      |
| 支持联合/交叉类型 | ❌                            | ✅                           |
| 支持映射类型     | ❌                            | ✅                           |
| 支持基本类型别名 | ❌                            | ✅ 如 `type ID = string;`     |

> 推荐优先使用 `interface`，除非需要用到 `type` 的高级功能。

***

### 7. TypeScript 中的访问修饰符有哪些？

**答：**

* `public`：默认，公共属性，可在外部访问。
* `private`：私有属性，只能在类内部访问。
* `protected`：受保护属性，可在类和子类中访问。
* `readonly`：只读属性，只能在声明或构造函数中赋值。

***

## 🔄 四、泛型与高级类型

### 8. 泛型是什么？举例说明它的用途。

**答：**

* 泛型允许我们编写可重用且类型安全的组件，延迟指定类型直到使用时。

```ts
function identity<T>(arg: T): T {
  return arg;
}

const result1 = identity<string>("hello");
const result2 = identity<number>(123);
```

***

### 9. 什么是条件类型（Conditional Types）？

**答：**

* 条件类型允许根据某个类型是否满足某种条件来决定另一个类型。

```ts
type IsString<T> = T extends string ? true : false;

type A = IsString<"hello">; // true
type B = IsString<123>;     // false
```

***

### 10. Partial、Required、Readonly 等内置类型的作用？

**答：**

* `Partial<T>`：将所有属性变为可选。
* `Required<T>`：将所有属性变为必填。
* `Readonly<T>`：将所有属性设为只读。
* `Pick<T, K>`：从 T 中选取一组属性 K。
* `Omit<T, K>`：从 T 中排除一组属性 K。
* `Record<K, T>`：创建一个键类型为 K，值类型为 T 的对象。

```ts
type User = { name: string; age: number };

type OptionalUser = Partial<User>;
// => { name?: string; age?: number }
```

***

## ⚙️ 五、其他常见问题

### 11. 如何配置 TypeScript 项目？常用配置项有哪些？

**答：**

* 创建 `tsconfig.json` 文件。
* 常用配置：
  * `"target"`：编译目标版本（如 `"ES2020"`）
  * `"module"`：模块系统（如 `"ESNext"`）
  * `"strict"`：开启严格模式
  * `"outDir"`：输出目录
  * `"rootDir"`：源文件目录
  * `"esModuleInterop"`：启用 ES 模块互操作
  * `"skipLibCheck"`：跳过库类型检查

***

### 12. 在 React 项目中如何使用 TypeScript？

**答：**

* 使用 `.tsx` 文件扩展名。
* 定义组件 props 的类型。
* 使用泛型定义 state 类型。
* 利用类型推断和类型注解提高安全性。

```tsx
interface Props {
  title: string;
  count?: number;
}

const MyComponent: React.FC<Props> = ({ title, count = 0 }) => {
  return (
    <div>
      <h1>{title}</h1>
      <p>Count: {count}</p>
    </div>
  );
};
```

***

## ✅ 总结建议

| 类型 | 建议 |
|------|------|
| 类型注解 | 明确写出类型，避免 `any` |
| 严格模式 | 开启 `strict`，防止潜在 bug |
| 工具使用 | 配合 VS Code + ESLint + Prettier 提升体验 |
| 实战练习 | 多写类型体操题（Type Challenges） |

好的！我们继续模拟一场 **TypeScript 面试**，这次是完整的问答形式。我扮演面试官，你扮演应聘者。

***

## 🧑‍💼 面试官：你好，欢迎来参加我们的前端开发岗位面试。我是今天的面试官张工。

### 问题 1：请简单介绍一下你对 TypeScript 的理解，它解决了 JavaScript 的哪些痛点？

***

### 👨‍💻 应聘者（你）回答：

TypeScript 是 JavaScript 的超集，它在 JavaScript 的基础上增加了静态类型系统和面向对象等高级特性。TypeScript 最终会被编译成普通的 JavaScript 代码，可以在任何支持 JavaScript 的环境中运行。

它主要解决了以下几个 JavaScript 的痛点：

1. **类型不安全**：JavaScript 是动态类型语言，变量类型在运行时才确定，容易引发意料之外的错误。而 TypeScript 在编译阶段就能检测出类型错误。
2. **可维护性差**：大型项目中，没有类型注解会让代码难以理解和维护。TypeScript 的类型系统提升了代码的可读性和可维护性。
3. **缺乏良好的 IDE 支持**：TypeScript 提供了更好的自动补全、重构、跳转定义等功能，提升开发效率。
4. **团队协作困难**：明确的类型定义有助于多人协作，减少沟通成本。

***

### 🧑‍💼 面试官反馈：

嗯，你的回答很全面，对 TypeScript 的核心优势把握得不错。那我再问一个进阶点的问题：

***

### 问题 2：`any` 和 `unknown` 类型有什么区别？什么时候应该使用它们？

***

### 👨‍💻 应聘者（你）回答：

`any` 和 `unknown` 都表示未知类型，但它们的安全级别不同：

* `any` 表示完全跳过类型检查，可以赋值给任意类型，也可以调用它的方法或属性，这会失去类型保护，不推荐使用。
* `unknown` 表示该类型未知，但在使用前必须进行类型检查或类型收窄，否则不能直接操作，这样更安全。

例如：

```ts
let value: any = "hello";
value(); // 合法，但可能出错

let val: unknown = "hello";
val(); // ❌ 报错，不能直接调用
```

使用场景：

* `any` 一般用于迁移旧项目或临时绕过类型检查（不推荐）。
* `unknown` 更适合处理不确定类型的值，比如用户输入、API 返回等，在使用前做类型守卫判断。

***

### 🧑‍💼 面试官反馈：

很好！你不仅说出了两者的区别，还给出了使用建议，说明你在实际项目中有一定的经验。

接下来考考你关于接口和类的理解：

***

### 问题 3：`interface` 和 `type` 有什么区别？你会在什么场景下选择其中一个？

***

### 👨‍💻 应聘者（你）回答：

`interface` 和 `type` 都可以用来定义对象的结构，但它们有一些关键差异：

| 特性             | interface                     | type                          |
|------------------|-------------------------------|-------------------------------|
| 是否可合并       | ✅ 可以声明合并               | ❌ 不可以                      |
| 支持联合/交叉类型 | ❌                            | ✅                           |
| 支持映射类型     | ❌                            | ✅                           |
| 支持基本类型别名 | ❌                            | ✅ 如 `type ID = string;`     |

使用建议：

* 如果只是定义对象结构，优先使用 `interface`，因为它支持声明合并，更适合扩展。
* 如果需要定义联合类型、交叉类型、映射类型或基本类型别名，就使用 `type`。

***

### 🧑‍💼 面试官反馈：

非常棒！你能结合使用场景给出建议，说明你对 TypeScript 的掌握已经超越了表面知识。

最后一个问题，考察一下泛型的理解：

***

### 问题 4：什么是泛型？能举个例子说明它的用途吗？

***

### 👨‍💻 应聘者（你）回答：

泛型是一种允许我们在定义函数、类或接口时，延迟指定具体类型的方式。它让我们写出既能保持类型安全又能复用的代码。

比如下面这个通用的 `identity` 函数：

```ts
function identity<T>(arg: T): T {
  return arg;
}

const str = identity<string>("hello"); // 返回 string
const num = identity<number>(123);     // 返回 number
```

在这个例子中，`T` 就是一个泛型参数，它会在调用时被替换成具体的类型，从而保证类型安全。

另一个常见的泛型使用场景是在组件或工具库中，例如 React 中定义组件 props 类型时，常常会配合泛型来提高灵活性。

***

### 🧑‍💼 面试官反馈：

非常好！你不仅解释清楚了泛型的概念，还举了一个清晰的例子，并提到了实际应用场景，加分项！

***

## ✅ 面试总结：

| 考察点           | 评分（满分5分） | 评价 |
|------------------|----------------|------|
| 基础概念理解     | 5              | 对 TypeScript 核心机制有清晰认识 |
| 类型系统掌握     | 5              | 区分 `any` 和 `unknown` 很到位 |
| 接口与类型定义   | 5              | 能区分 `interface` 和 `type` 并合理使用 |
| 泛型应用         | 5              | 能举例说明泛型并联系实际开发场景 |

🎉 **综合评价：表现优秀，具备扎实的 TypeScript 基础和实际应用能力。**
当然可以！自定义类型守卫（Custom Type Guard）是 TypeScript 中非常有用的一个特性，它允许我们在运行时检查某个值的类型，并帮助 TypeScript 更精确地推断该值的实际类型。通过自定义类型守卫，我们可以避免手动进行类型断言，使代码更加安全和清晰。

下面我将通过一个例子来说明如何使用自定义类型守卫。

### 示例场景

假设我们有一个函数 `printInfo`，它接收一个参数 `info`，这个参数可能是字符串、数字或包含 `name` 属性的对象之一。我们的目标是根据不同的类型打印不同的信息。

### 实现步骤

1. **定义类型**：首先定义可能的类型。
2. **创建类型守卫函数**：然后为每种类型创建类型守卫函数。
3. **在主函数中使用类型守卫**：最后，在主函数中使用这些类型守卫来区分不同类型并执行相应的逻辑。

```typescript
// 定义可能的类型
type Info = string | number | { name: string };

// 类型守卫函数 - 检查是否为字符串
function isString(value: any): value is string {
  return typeof value === 'string';
}

// 类型守卫函数 - 检查是否为数字
function isNumber(value: any): value is number {
  return typeof value === 'number';
}

// 类型守卫函数 - 检查是否为对象且包含name属性
function isNameObject(value: any): value is { name: string } {
  return typeof value === 'object' && value !== null && 'name' in value;
}

// 主函数
function printInfo(info: Info) {
  if (isString(info)) {
    console.log(`The info is a string: ${info}`);
  } else if (isNumber(info)) {
    console.log(`The info is a number: ${info}`);
  } else if (isNameObject(info)) {
    console.log(`The info object has a name property: ${info.name}`);
  }
}

// 测试
printInfo("Hello, TypeScript!");
printInfo(123);
printInfo({ name: "TypeScript" });
```

### 解释

* 在上述代码中，我们定义了三种类型守卫函数：`isString`, `isNumber`, 和 `isNameObject`。
* 这些函数都遵循一种模式，它们接受一个任意类型的参数，并返回一个布尔值，表示传入的参数是否符合预期的类型。
* 特别注意的是，每个类型守卫函数都使用了特殊的返回类型注解（如 `value is string`），这告诉 TypeScript 当函数返回 `true` 时，参数 `value` 的类型应该是括号中的那个类型。
* 在 `printInfo` 函数中，我们利用这些类型守卫来判断 `info` 参数的具体类型，并据此执行不同的操作。

这种方法不仅提高了代码的可读性和维护性，还能确保类型安全，减少潜在的错误。希望这个例子对你理解自定义类型守卫有所帮助！如果有任何问题或需要进一步解释，请告诉我。

当然可以！让我们通过另一个示例来进一步探讨类型守卫的使用。这次，我们将构建一个稍微复杂一点的例子，涉及到处理不同类型的用户输入，并根据输入类型执行不同的操作。

### 示例场景

假设我们正在开发一个应用，该应用需要处理用户的输入，这些输入可能是字符串、数字或包含特定属性的对象（例如用户信息）。我们的目标是根据不同类型的输入执行不同的逻辑。

### 实现步骤

1. **定义类型**：首先定义可能的输入类型。
2. **创建类型守卫函数**：然后为每种类型创建类型守卫函数。
3. **在主函数中使用类型守卫**：最后，在主函数中使用这些类型守卫来区分不同类型并执行相应的逻辑。

```typescript
// 定义可能的输入类型
type UserInput = string | number | { id: number; username: string };

// 类型守卫 - 检查是否为字符串
function isString(value: any): value is string {
  return typeof value === 'string';
}

// 类型守卫 - 检查是否为数字
function isNumber(value: any): value is number {
  return typeof value === 'number';
}

// 类型守卫 - 检查是否为对象且包含id和username属性
function isUserObject(value: any): value is { id: number; username: string } {
  return typeof value === 'object' && value !== null && 'id' in value && 'username' in value;
}

// 主函数
function processUserInput(input: UserInput) {
  if (isString(input)) {
    console.log(`Received a string input: ${input}`);
  } else if (isNumber(input)) {
    console.log(`Received a numeric input: ${input}`);
  } else if (isUserObject(input)) {
    console.log(`Received an object input with ID ${input.id} and username ${input.username}`);
  } else {
    console.error('Unknown input type');
  }
}

// 测试
processUserInput("Hello, World!"); // 字符串输入
processUserInput(12345);            // 数字输入
processUserInput({ id: 67890, username: "john_doe" }); // 对象输入
```

### 解释

* 在这个例子中，我们定义了三种可能的输入类型：`string`, `number`, 和 `{ id: number; username: string }`。
* 我们为每种类型实现了类型守卫函数，分别是 `isString`, `isNumber`, 和 `isUserObject`。每个函数都接受任意类型的参数，并返回一个布尔值，表示传入的参数是否符合预期的类型。
* 特别注意的是，类型守卫函数使用了特殊的返回类型注解（如 `value is string`），这告诉 TypeScript 当函数返回 `true` 时，参数 `value` 的类型应该是括号中的那个类型。
* 在 `processUserInput` 函数中，我们利用这些类型守卫来检查 `input` 参数的具体类型，并据此执行不同的操作。

通过这种方式，我们可以确保程序能够正确地处理各种类型的输入，同时保持代码的清晰和易于维护性。此外，这也提高了代码的安全性，减少了运行时错误的可能性。希望这个例子能帮助你更好地理解如何在实际项目中使用类型守卫！如果有任何问题或需要进一步的解释，请随时告诉我。

### 类型守卫 vs. 类型断言

在 TypeScript 中，类型守卫（Type Guard）和类型断言（Type Assertion）都是用于处理类型不确定的情况，但它们的工作机制和使用场景有所不同。

#### **类型守卫（Type Guard）**

* **定义**：类型守卫是一种特殊的函数或结构，它能够在运行时检查某个值的类型，并告知 TypeScript 编译器该值的具体类型。
* **工作原理**：通过返回布尔值来判断一个值是否属于特定类型。当条件为真时，TypeScript 会将该值视为指定类型。
* **常见实现方式**：
  * 使用 `typeof`、`instanceof` 关键字。
  * 自定义类型守卫函数，返回类型谓词如 `value is Type`。
* **优点**：增强代码安全性，避免手动强制转换可能带来的错误。
* **示例**：
  ```typescript
  function isString(value: any): value is string {
    return typeof value === 'string';
  }

  function processData(input: unknown) {
    if (isString(input)) {
      console.log(`Processing a string: ${input}`);
    }
  }
  ```

#### **类型断言（Type Assertion）**

* **定义**：类型断言允许开发者手动告诉编译器某个值的实际类型，跳过编译器的类型检查。
* **工作原理**：通过 `<Type>value` 或 `value as Type` 的语法形式直接指定值的类型。
* **应用场景**：当你比编译器更了解某个值的确切类型时使用。
* **缺点**：如果断言不准确，可能会导致运行时错误，因此需要谨慎使用。
* **示例**：
  ```typescript
  const someValue: unknown = "This is a string";
  const strLength: number = (someValue as string).length;
  ```

### 实际应用场景：表单验证中的类型守卫

假设我们正在开发一个用户注册页面，其中包含一个表单，用户可以输入用户名、邮箱地址和年龄。我们需要对这些输入进行验证，并根据不同的输入类型执行相应的操作。

```typescript
type UserInput = { username?: string; email?: string; age?: number };

// 类型守卫 - 检查是否存在且为非空字符串
function isNonEmptyString(value: any): value is string {
  return typeof value === 'string' && value.trim().length > 0;
}

// 类型守卫 - 检查是否存在且为有效的数字
function isValidNumber(value: any): value is number {
  return typeof value === 'number' && !isNaN(value);
}

// 表单验证函数
function validateUserInput(input: UserInput) {
  let errors: string[] = [];

  if (!isNonEmptyString(input.username)) {
    errors.push("Username must be a non-empty string.");
  }

  if (!isNonEmptyString(input.email)) {
    errors.push("Email must be a non-empty string.");
  } else if (!/\S+@\S+\.\S+/.test(input.email)) {
    errors.push("Invalid email format.");
  }

  if (!isValidNumber(input.age)) {
    errors.push("Age must be a valid number.");
  } else if (input.age < 18) {
    errors.push("You must be at least 18 years old.");
  }

  if (errors.length === 0) {
    console.log("Registration successful!");
  } else {
    console.error("Errors occurred:", errors);
  }
}

// 测试
validateUserInput({
  username: "john_doe",
  email: "john@example.com",
  age: 25
});
```

在这个例子中，我们使用了自定义类型守卫来确保每个字段都符合预期的格式和类型。这不仅提高了代码的安全性，还使得逻辑更加清晰易读。相比直接使用类型断言，类型守卫更能保证数据的有效性和准确性，减少潜在的运行时错误。

**能否举例说明类型守卫在函数重载中的应用？**

当然可以！类型守卫不仅可以在简单的条件判断中使用，还可以在函数重载（Function Overloading）中发挥重要作用。通过结合类型守卫和函数重载，我们可以根据传入参数的不同类型执行不同的逻辑，同时保持良好的类型安全性和代码可读性。

### 示例场景

假设我们需要编写一个函数 `processData`，它能够处理两种类型的输入：一种是普通的字符串，另一种是一个包含数据和处理方式的对象。对于字符串输入，我们直接返回其大写形式；对于对象输入，则根据指定的处理方式（如转为大写或小写）来处理数据。

### 实现步骤

1. **定义类型**：首先定义可能的输入类型。
2. **创建函数重载声明**：然后为每种类型的输入创建函数重载声明。
3. **实现主函数**：在主函数中使用类型守卫来区分不同类型并执行相应的操作。

```typescript
// 定义可能的输入类型
type ProcessInput = string | { data: string; action: 'uppercase' | 'lowercase' };

// 函数重载声明
function processData(input: string): string;
function processData(input: { data: string; action: 'uppercase' }): string;
function processData(input: { data: string; action: 'lowercase' }): string;

// 主函数实现
function processData(input: ProcessInput): string {
  if (typeof input === 'string') {
    // 类型守卫 - 确保input是字符串
    return input.toUpperCase();
  } else if ('action' in input && input.action === 'uppercase') {
    // 类型守卫 - 确保input是一个特定的对象且action为'uppercase'
    return input.data.toUpperCase();
  } else if ('action' in input && input.action === 'lowercase') {
    // 类型守卫 - 确保input是一个特定的对象且action为'lowercase'
    return input.data.toLowerCase();
  } else {
    throw new Error('Invalid input type');
  }
}

// 测试
console.log(processData("hello")); // 输出: HELLO
console.log(processData({ data: "world", action: 'uppercase' })); // 输出: WORLD
console.log(processData({ data: "TypeScript", action: 'lowercase' })); // 输出: typescript
```

### 解释

* 在上述例子中，我们首先定义了可能的输入类型 `ProcessInput`，它可以是字符串或包含 `data` 和 `action` 属性的对象。
* 接着，我们使用了函数重载声明来明确 `processData` 函数可以根据不同类型的输入返回不同的结果。
* 在主函数 `processData` 的实现中，我们利用类型守卫来区分输入的具体类型：
  * 使用 `typeof input === 'string'` 来检查输入是否为字符串，并对字符串进行大写转换。
  * 使用 `'action' in input && input.action === 'uppercase'` 来检查输入是否为带有 `action` 为 `'uppercase'` 的对象，并对对象中的 `data` 字段进行大写转换。
  * 同样地，处理 `action` 为 `'lowercase'` 的情况。

这种方式不仅提高了代码的灵活性和可维护性，还能确保在编译阶段就能发现潜在的类型错误。此外，通过结合类型守卫和函数重载，使得函数的行为更加直观和易于理解，增强了代码的安全性和可读性。

类型守卫不仅在简单的条件判断中非常有用，在接口实现时也可以发挥重要作用。特别是在处理多态行为（即基于对象的不同类型执行不同的操作）时，类型守卫可以帮助我们确定对象的具体类型，并根据其类型执行相应的逻辑。

### 示例场景

假设我们正在开发一个应用，其中包含不同类型的用户（比如普通用户和管理员）。我们需要定义一个通用的 `User` 接口，然后根据不同类型的用户实现特定的行为。例如，普通用户只能查看信息，而管理员可以修改信息。

### 实现步骤

1. **定义接口**：首先定义一个通用的 `User` 接口以及两个具体的用户类型接口。
2. **创建类型守卫函数**：为每种具体类型的用户创建类型守卫函数。
3. **在方法中使用类型守卫**：在需要区分用户类型的方法中使用这些类型守卫来执行不同的操作。

```typescript
// 定义通用的 User 接口
interface User {
  name: string;
}

// 定义普通用户接口
interface RegularUser extends User {
  role: 'regular';
}

// 定义管理员接口
interface AdminUser extends User {
  role: 'admin';
  canModify: boolean;
}

// 类型守卫 - 检查是否为普通用户
function isRegularUser(user: User): user is RegularUser {
  return (user as RegularUser).role === 'regular';
}

// 类型守卫 - 检查是否为管理员
function isAdminUser(user: User): user is AdminUser {
  return (user as AdminUser).role === 'admin';
}

// 定义一个处理用户行为的类
class UserManager {
  performAction(user: User) {
    if (isRegularUser(user)) {
      console.log(`${user.name} is a regular user and can only view information.`);
    } else if (isAdminUser(user)) {
      if (user.canModify) {
        console.log(`${user.name} is an admin and can modify information.`);
      } else {
        console.log(`${user.name} is an admin but cannot modify information at this time.`);
      }
    } else {
      console.error('Unknown user type');
    }
  }
}

// 测试
const regularUser: RegularUser = { name: "Alice", role: "regular" };
const adminUser: AdminUser = { name: "Bob", role: "admin", canModify: true };

const userManager = new UserManager();
userManager.performAction(regularUser); // 输出: Alice is a regular user and can only view information.
userManager.performAction(adminUser);   // 输出: Bob is an admin and can modify information.
```

### 解释

* 在这个例子中，我们首先定义了一个通用的 `User` 接口，以及两个扩展自 `User` 的具体类型接口：`RegularUser` 和 `AdminUser`。
* 然后，我们为每个具体类型实现了类型守卫函数 `isRegularUser` 和 `isAdminUser`。这些函数接收一个 `User` 类型的对象，并通过检查 `role` 属性来确定对象的具体类型。
* 在 `UserManager` 类的 `performAction` 方法中，我们使用这些类型守卫来区分传入用户的类型，并根据用户的类型执行不同的操作：
  * 如果是普通用户，则输出该用户只能查看信息的消息。
  * 如果是管理员，则进一步检查 `canModify` 属性以决定管理员是否有权限修改信息。

这种方式使得代码可以根据对象的实际类型动态地执行不同的逻辑，同时保持了良好的类型安全性和代码可读性。类型守卫在这里起到了关键作用，它帮助我们在运行时准确地区分不同类型，并相应地调整程序的行为。

---

---
url: /learning/category/modules/page4.md
---
# uniapp

## 全局文件

这里主要是两个文件：pages.json管理页面路由、和manifest.json管理应用配置。

### pages.json

pages.json 文件是进行全局配置，包括`页面文件路径`、`样式`、`原生导航栏`等内容

以下是官网给出的配置示例：

::: details

```js
{
  "pages": [
    {
      "path": "pages/component/index",
      "style": {
        "navigationBarTitleText": "组件"
      }
    },
    {
      "path": "pages/API/index",
      "style": {
        "navigationBarTitleText": "接口"
      }
    },
    {
      "path": "pages/component/view/index",
      "style": {
        "navigationBarTitleText": "view"
      }
    }
  ],
  "condition": {
    //模式配置，仅开发期间生效
    "current": 0, //当前激活的模式（list 的索引项）
    "list": [
      {
        "name": "test", //模式名称
        "path": "pages/component/view/index" //启动页面，必选
      }
    ]
  },
  "globalStyle": {
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "演示",
    "navigationBarBackgroundColor": "#F8F8F8",
    "backgroundColor": "#F8F8F8",
    "usingComponents": {
      "collapse-tree-item": "/components/collapse-tree-item"
    },
    "renderingMode": "seperated", // 仅微信小程序，webrtc 无法正常时尝试强制关闭同层渲染
    "pageOrientation": "portrait", //横屏配置，全局屏幕旋转设置(仅 APP/微信/QQ小程序)，支持 auto / portrait / landscape
    "rpxCalcMaxDeviceWidth": 960,
    "rpxCalcBaseDeviceWidth": 375,
    "rpxCalcIncludeWidth": 750
  },
  "tabBar": {
    "color": "#7A7E83",
    "selectedColor": "#3cc51f",
    "borderStyle": "black",
    "backgroundColor": "#ffffff",
    "height": "50px",
    "fontSize": "10px",
    "iconWidth": "24px",
    "spacing": "3px",
    "iconfontSrc": "static/iconfont.ttf", // app tabbar 字体.ttf文件路径 app 3.4.4+
    "list": [
      {
        "pagePath": "pages/component/index",
        "iconPath": "static/image/icon_component.png",
        "selectedIconPath": "static/image/icon_component_HL.png",
        "text": "组件",
        "iconfont": {
          // 优先级高于 iconPath，该属性依赖 tabbar 根节点的 iconfontSrc
          "text": "\ue102",
          "selectedText": "\ue103",
          "fontSize": "17px",
          "color": "#000000",
          "selectedColor": "#0000ff"
        }
      },
      {
        "pagePath": "pages/API/index",
        "iconPath": "static/image/icon_API.png",
        "selectedIconPath": "static/image/icon_API_HL.png",
        "text": "接口"
      }
    ],
    "midButton": {
      "width": "80px",
      "height": "50px",
      "text": "文字",
      "iconPath": "static/image/midButton_iconPath.png",
      "iconWidth": "24px",
      "backgroundImage": "static/image/midButton_backgroundImage.png"
    }
  },
  "easycom": {
    "autoscan": true, //是否自动扫描组件
    "custom": {
      //自定义扫描规则
      "^uni-(.*)": "@/components/uni-$1.vue"
    }
  },
  "topWindow": {
    "path": "responsive/top-window.vue",
    "style": {
      "height": "44px"
    }
  },
  "leftWindow": {
    "path": "responsive/left-window.vue",
    "style": {
      "width": "300px"
    }
  },
  "rightWindow": {
    "path": "responsive/right-window.vue",
    "style": {
      "width": "300px"
    },
    "matchMedia": {
      "minWidth": 768
    }
  }
}
```

:::

### manifest.json

manifest.json 文件是应用的配置文件，用于指定应用的名称、图标、权限等内容。

以下是官网给出的配置示例：

::: details

```js
{
  "appid": "__UNI__XXXXXX，创建应用时云端分配的，不要修改。",
  "name": "应用名称，如uni-app",
  "description": "应用描述",
  "versionName": "1.0.0",
  "versionCode": "100",
  "uniStatistics": {
    "enable": false
  },
  "app-plus": {
    "allowsInlineMediaPlayback": true, //可选，Boolean类型, 是否允许 h5 中视频非全屏播放，3.8.5版本开始默认值为 true （仅iOS生效）
    "mediaPlaybackRequiresUserAction": false, //可选，Boolean类型,可通过此属性配置 h5中的音视频是否可通过API自动播放，注意当设置为 false 时允许API控制自动播放，3.8.5版本开始默认值为 false（仅iOS生效 3.0.1 + 版本支持）
    "nvueCompiler": "weex", //可选，字符串类型，nvue页面编译模式，可取值uni-app、weex，参考：https://ask.dcloud.net.cn/article/36074
    "nvueStyleCompiler": "weex", //可选，字符串类型，nvue页面样式编译模式，可取值uni-app、weex，参考：https://ask.dcloud.net.cn/article/38751
    "renderer": "native", //可选，字符串类型，可不加载基于 webview 的运行框架，可取值native
    "compilerVersion": 2, //可选，数字类型，编译器版本，可取值2、3，参考：https://ask.dcloud.net.cn/article/36599
    "nvueLaunchMode": "normal", //可选，字符串类型，nvue首页启动模式，compilerVersion值为3时生效，可取值normal、fast，参考：https://ask.dcloud.net.cn/article/36749
    "nvue": {
      //可选，JSON对象，nvue页面相关配置
      "flex-direction": "row" //可选，字符串类型，nvue页面的flex-direction默认值，可取值row、row-reverse、column、column-reverse
    },
    "optimization": {
      //可选，JSON对象，分包配置
      "subPackages": true //可选，Boolean类型，是否开启分包优化，参考：https://uniapp.dcloud.io/collocation/pages.html#subpackages
    },
    "uniStatistics": {
      //可选，JSON对象，uni统计配置
      "enable": true //可选，Boolean类型，是否开启uni统计
    },
    "screenOrientation": [
      //可选，字符串数组类型，应用支持的横竖屏
      "portrait-primary", //可选，字符串类型，支持竖屏
      "portrait-secondary", //可选，字符串类型，支持反向竖屏
      "landscape-primary", //可选，字符串类型，支持横屏
      "landscape-secondary" //可选，字符串类型，支持反向横屏
    ],
    "splashscreen": {
      //可选，JSON对象，splash界面配置
      "alwaysShowBeforeRender": true, //可选，Boolean类型，是否等待首页渲染完毕后再关闭启动界面
      "autoclose": true, //可选，Boolean类型，是否自动关闭启动界面
      "waiting": true, //可选，Boolean类型，是否在程序启动界面显示等待雪花
      "event": "loaded", //可选，字符串类型，可取值titleUpdate、rendering、loaded，uni-app项目已废弃
      "target": "defalt", //可选，字符串类型，可取值default、second，uni-app项目已废弃
      "dealy": 0, //可选，数字类型，延迟自动关闭启动时间，单位为毫秒，uni-app项目已废弃
      "ads": {
        //可选，JSON对象，开屏广告配置
        "backaground": "#RRGGBB", //可选，字符串类型，格式为#RRGGBB，开屏广告背景颜色
        "image": "" //可选，字符串类型，底部图片地址，相对应用资源目录路径
      },
      "androidTranslucent": false //可选，Boolean类型，使用“自定义启动图”启动界面时是否显示透明过渡界面，可解决点击桌面图标延时启动应用的效果
    },
    "modules": {
      //可选，JSON对象，使用的模块
      "Bluetooth": {
        //可选，JSON对象，Bluetooth(低功耗蓝牙)
        "description": "低功耗蓝牙"
      },
      "Contacts": {
        //可选，JSON对象，Contact(通讯录)
        "description": "通讯录"
      },
      "FaceID": {
        //可选，JSON对象，FaceID(人脸识别)，仅iOS支持
        "description": "人脸识别"
      },
      "Fingerprint": {
        //可选，JSON对象，Fingerprint(指纹识别)
        "description": "指纹识别"
      },
      "Geolocation": {
        //可选，JSON对象，Geolocation(定位)
        "description": "定位"
      },
      "iBeacon": {
        //可选，JSON对象，iBeacon
        "description": "iBeacon"
      },
      "LivePusher": {
        //可选，JSON对象，LivePusher(直播推流)
        "description": "直播推流"
      },
      "Maps": {
        //可选，JSON对象，Maps(地图)
        "description": "地图"
      },
      "Messaging": {
        //可选，JSON对象，Messaging(短彩邮件消息)
        "description": "短彩邮件消息"
      },
      "OAuth": {
        //可选，JSON对象，OAuth(登录鉴权)
        "description": "登录鉴权"
      },
      "Payment": {
        //可选，JSON对象，Payment(支付)
        "description": "iBeacon"
      },
      "Push": {
        //可选，JSON对象，Push(消息推送)
        "description": "iBeacon"
      },
      "Share": {
        //可选，JSON对象，Share(分享)
        "description": "iBeacon"
      },
      "Speech": {
        //可选，JSON对象，Speech(语音输入)
        "description": "iBeacon"
      },
      "Statistic": {
        //可选，JSON对象，Statistic(统计)
        "description": "iBeacon"
      },
      "SQLite": {
        //可选，JSON对象，SQLite(统计)
        "description": "iBeacon"
      },
      "VideoPlayer": {
        //可选，JSON对象，VideoPlayer(视频播放)
        "description": "iBeacon"
      },
      "Webview-x5": {
        //可选，JSON对象，Android X5 Webview(腾讯TBS)，仅Android支持
        "description": "iBeacon"
      },
      "UIWebview": {
        //可选，JSON对象，UIWebview，仅iOS支持
        "description": "iBeacon"
      }
    },
    "webView": {
      // 3.5.0 + 当系统webview低于指定版本时，会弹出提示。或者下载x5内核后继续启动，仅Android支持
      "minUserAgentVersion": "95.0.4638.75", // 最小webview版本
      "x5": {
        // 此属性需要勾选 Android X5 Webview 模块，详细参见下面的说明
        "timeOut": 3000, // 超时时间
        "showTipsWithoutWifi": true, // 是否在非WiFi网络环境时，显示用户确认下载x5内核的弹窗。
        "allowDownloadWithoutWiFi": false // 是否允许用户在非WiFi网络时进行x5内核的下载。（如果为true，就不会显示用户确认的弹窗。）
      }
    },
    "checkPermissionDenied": false, // 是否校验已拒绝权限 如果拒绝则不会再申请 默认false 不校验已拒绝权限
    "distribute": {
      //必选，JSON对象，云端打包配置
      "android": {
        //可选，JSON对象，Android平台云端打包配置
        "packagename": "", //必填，字符串类型，Android包名
        "keystore": "", //必填，字符串类型，Android签名证书文件路径
        "password": "", //必填，字符串类型，Android签名证书文件的密码
        "aliasname": "", //必填，字符串类型，Android签名证书别名
        "schemes": "", //可选，字符串类型，参考：https://uniapp.dcloud.io/tutorial/app-android-schemes
        "abiFilters": [
          //可选，字符串数组类型，参考：https://uniapp.dcloud.io/tutorial/app-android-abifilters
          "armeabi-v7a",
          "arm64-v8a",
          "x86",
          "x86_64"
        ],
        "permissions": [
          //可选，字符串数组类型，Android权限配置
          "<uses-feature android:name=\"android.hardware.camera\"/>"
        ],
        "custompermissions": false, //可选，Boolean类型，是否自定义Android权限配置
        "permissionExternalStorage": {
          //可选，JSON对象，Android平台应用启动时申请读写手机存储权限策略
          "request": "always", //必填，字符串类型，申请读写手机存储权限策略，可取值none、once、always
          "prompt": "" //可选，字符串类型，当request设置为always值用户拒绝时弹出提示框上的内容
        },
        "permissionPhoneState": {
          //可选，JSON对象，Android平台应用启动时申请读取设备信息权限配置
          "request": "always", //必填，字符串类型，申请读取设备信息权限策略，可取值none、once、always
          "prompt": "" //可选，字符串类型，当request设置为always值用户拒绝时弹出提示框上的内容
        },
        "minSdkVersion": 21, //可选，数字类型，Android平台最低支持版本，参考：https://uniapp.dcloud.io/tutorial/app-android-minsdkversion
        "targetSdkVersion": 30, //可选，数字类型，Android平台目标版本，参考：https://uniapp.dcloud.io/tutorial/app-android-targetsdkversion
        "packagingOptions": [
          //可选，字符串数组类型，Android平台云端打包时build.gradle的packagingOptions配置项
          "doNotStrip '*/armeabi-v7a/*.so'",
          "merge '**/LICENSE.txt'"
        ],
        "jsEngine": "v8", //可选，字符串类型，uni-app使用的JS引擎，可取值v8、jsc
        "debuggable": false, //可选，Boolean类型，是否开启Android调试开关
        "locale": "default", //可选，应用的语言
        "forceDarkAllowed": false, //可选，Boolean类型，是否强制允许暗黑模式
        "resizeableActivity": false, //可选，Boolean类型，是否支持分屏调整窗口大小
        "hasTaskAffinity": false, //可选，Boolean类型，是否设置android：taskAffinity
        "buildFeatures": {
          //（HBuilderX3.5.0+版本支持）可选，JSON对象，Android平台云端打包时build.gradle的buildFeatures配置项
          "dataBinding": false, //可选，Boolean类型，是否设置dataBinding
          "viewBinding": false //可选，Boolean类型，是否设置viewBinding
        }
      },
      "ios": {
        //可选，JSON对象，iOS平台云端打包配置
        "appid": "", //必填，字符串类型，iOS平台Bundle ID
        "mobileprovision": "", //必填，字符串类型，iOS打包使用的profile文件路径
        "p12": "", //必填，字符串类型，iOS打包使用的证书文件路径
        "password": "", //必填，字符串类型，iOS打包使用的证书密码
        "devices": "iphone", //必填，字符串类型，iOS支持的设备类型，可取值iphone、ipad、universal
        "urlschemewhitelist": "baidumap", //可选，字符串类型，应用访问白名单列表，参考：https://uniapp.dcloud.io/tutorial/app-ios-schemewhitelist
        "urltypes": "", //可选，字符串类型，参考：https://uniapp.dcloud.io/tutorial/app-ios-schemes
        "UIBackgroundModes": "audio", //可选，字符串类型，应用后台运行模式，参考：https://uniapp.dcloud.io/tutorial/app-ios-uibackgroundmodes
        "frameworks": [
          //可选，字符串数组类型，依赖的系统库，已废弃，推荐使用uni原生插件扩展使用系统依赖库
          "CoreLocation.framework"
        ],
        "deploymentTarget": "10.0", //可选，字符串类型，iOS支持的最低版本
        "privacyDescription": {
          //可选，JSON对象，iOS隐私信息访问的许可描述
          "NSPhotoLibraryUsageDescription": "", //可选，字符串类型，系统相册读取权限描述
          "NSPhotoLibraryAddUsageDescription": "", //可选，字符串类型，系统相册写入权限描述
          "NSCameraUsageDescription": "", //可选，字符串类型，摄像头使用权限描述
          "NSMicrophoneUsageDescription": "", //可选，字符串类型，麦克风使用权限描述
          "NSLocationWhenInUseUsageDescription": "", //可选，字符串类型，运行期访问位置权限描述
          "NSLocationAlwaysUsageDescription": "", //可选，字符串类型，后台运行访问位置权限描述
          "NSLocationAlwaysAndWhenInUseUsageDescription": "", //可选，字符串类型，运行期后后台访问位置权限描述
          "NSCalendarsUsageDescription": "", //可选，字符串类型，使用日历权限描述
          "NSContactsUsageDescription": "", //可选，字符串类型，使用通讯录权限描述
          "NSBluetoothPeripheralUsageDescription": "", //可选，字符串类型，使用蓝牙权限描述
          "NSBluetoothAlwaysUsageDescription": "", //可选，字符串类型，后台使用蓝牙权限描述
          "NSSpeechRecognitionUsageDescription": "", //可选，字符串类型，系统语音识别权限描述
          "NSRemindersUsageDescription": "", //可选，字符串类型，系统提醒事项权限描述
          "NSMotionUsageDescription": "", //可选，字符串类型，使用运动与健康权限描述
          "NSHealthUpdateUsageDescription": "", //可选，字符串类型，使用健康更新权限描述
          "NSHealthShareUsageDescription": "", //可选，字符串类型，使用健康分享权限描述
          "NSAppleMusicUsageDescription": "", //可选，字符串类型，使用媒体资料库权限描述
          "NFCReaderUsageDescription": "", //可选，字符串类型，使用NFC权限描述
          "NSHealthClinicalHealthRecordsShareUsageDescription": "", //可选，字符串类型，访问临床记录权限描述
          "NSHomeKitUsageDescription": "", //可选，字符串类型，访问HomeKit权限描述
          "NSSiriUsageDescription": "", //可选，字符串类型，访问Siri权限描述
          "NSFaceIDUsageDescription": "", //可选，字符串类型，使用FaceID权限描述
          "NSLocalNetworkUsageDescription": "", //可选，字符串类型，访问本地网络权限描述
          "NSUserTrackingUsageDescription": "" //可选，字符串类型，跟踪用户活动权限描述
        },
        "idfa": true, //可选，Boolean类型，是否使用广告标识
        "capabilities": {
          //可选，JSON对象，应用的能力配置（Capabilities）
        },
        "CFBundleName": "HBuilder", //可选，字符串类型，CFBundleName名称
        "validArchitectures": [
          //可选，字符串数组类型，编译时支持的CPU指令，可取值arm64、arm64e、armv7、armv7s、x86_64
          "arm64"
        ],
        "pushRegisterMode": "manual", //可选，使用“Push(消息推送)”模块时申请系统推送权限模式，manual表示调用push相关API时申请，其它值表示应用启动时自动申请
        "privacyRegisterMode": "manual" //可选，仅iOS有效，设置为manual表示用户同意隐私政策后才获取idfv，设置为其它值表示应用启动时自动获取
      },
      "sdkConfigs": {
        //可选，JSON对象，三方SDK相关配置
        "geolocation": {
          //可选，JSON对象，Geolocation(定位)模块三方SDK配置
          "system": {
            //可选，JSON对象，使用系统定位
            "__platform__": ["ios", "android"] //可选，字符串数组类型，支持的平台
          },
          "amap": {
            //可选，JSON对象，使用高德定位SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "appkey_ios": "", //必填，字符串类型，iOS平台高德定位appkey
            "appkey_android": "" //必填，字符串类型，Android平台高德定位appkey
          },
          "baidu": {
            //可选，JSON对象，使用百度定位SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "appkey_ios": "", //必填，字符串类型，iOS平台百度定位appkey
            "appkey_android": "" //必填，字符串类型，Android平台百度定位appkey
          }
        },
        "maps": {
          //可选，JSON对象，Maps(地图)模块三方SDK配置
          "amap": {
            //可选，JSON对象，使用高德地图SDK配置
            "appkey_ios": "", //必填，字符串类型，iOS平台高德地图appkey
            "appkey_android": "" //必填，字符串类型，Android平台高德地图appkey
          },
          "baidu": {
            //可选，JSON对象，使用百度地图SDK配置
            "appkey_ios": "", //必填，字符串类型，iOS平台百度地图appkey
            "appkey_android": "" //必填，字符串类型，Android平台百度地图appkey
          },
          "google": {
            //可选，JSON对象，使用Google地图SDK配置
            "APIKey_ios": "", //必填，字符串类型，iOS平台Google地图APIKey
            "APIKey_android": "" //必填，字符串类型，Android平台Google地图APIKey
          }
        },
        "oauth": {
          //可选，JSON对象，OAuth(登录鉴权)模块三方SDK配置
          "univerify": {
            //可选，JSON对象，使用一键登录(univerify)SDK配置，无需手动配置参数，云端打包自动获取配置参数
          },
          "apple": {
            //可选，JSON对象，使用苹果登录(Sign in with Apple)SDK配置，无配置参数，仅iOS平台支持
          },
          "weixin": {
            //可选，JSON对象，使用微信登录SDK配置
            "appid": "", //必填，字符串类型，微信开放平台申请的appid
            "appsecret": "", //必填，字符串类型，微信开放平台申请的appsecret
            "UniversalLinks": "" //可选，字符串类型，微信开放平台配置的iOS平台通用链接
          },
          "qq": {
            //可选，JSON对象，使用QQ登录SDK配置
            "appid": "", //必填，字符串类型，QQ开放平台申请的appid
            "UniversalLinks": "" //可选，字符串类型，QQ开放平台配置的iOS平台通用链接
          },
          "sina": {
            //可选，JSON对象，使用新浪微博登录SDK配置
            "appkey": "", //必填，字符串类型，新浪微博开放平台申请的appid
            "redirect_uri": "", //必填，字符串类型，新浪微博开放平台配置的redirect_uri
            "UniversalLinks": "" //可选，字符串类型，新浪微博开放平台配置的iOS平台通用链接
          },
          "google": {
            //可选，JSON对象，使用Google登录SDK配置
            "clientid": "" //必填，字符串类型，Google开发者后台申请的clientid
          },
          "facebook": {
            //可选，JSON对象，使用Facebook登录SDK配置
            "appid": "" //必填，字符串类型，Facebook开发者后台申请的appid
          }
        },
        "payment": {
          //可选，JSON对象，Payment(支付)模块三方SDK配置
          "appleiap": {
            //可选，JSON对象，使用Apple应用内支付配置，无配置参数，仅iOS平台支持
          },
          "alipay": {
            //可选，JSON对象，使用支付宝支付SDK配置
            "__platform__": ["ios", "android"] //可选，字符串数组类型，支持的平台
          },
          "weixin": {
            //可选，JSON对象，使用微信支付SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "appid": "", //必填，字符串类型，微信开放平台申请的appid
            "UniversalLinks": "" //可选，字符串类型，微信开放平台配置的iOS平台通用链接
          },
          "paypal": {
            //可选，JSON对象，使用paypal支付SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "returnURL_ios": "", //必填，字符串类型，paypa开发者者后台配置的iOS平台returnURL
            "returnURL_android": "" //必填，字符串类型，paypa开发者者后台配置的Android平台returnURL
          },
          "stripe": {
            //可选，JSON对象，使用stripe支付SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "returnURL_ios": "" //必填，字符串类型，stripe开发者者后台配置的iOS平台returnURL
          },
          "google": {
            //可选，JSON对象，使用google支付SDK配置，无配置参数，仅Android平台支持
          }
        },
        "push": {
          //可选，JSON对象，Push(消息推送)模块三方SDK配置
          "unipush": {
            //可选，JSON对象，使用UniPush SDK配置，无需手动配置参数，云端打包自动获取配置参数
            "icons": {
              //可选，JSON对象，推送图标配置
              "push": {
                //可选，JSON对象，Push图标配置
                "ldpi": "", //可选，字符串类型，普通屏设备推送图标路径，分辨率要求48x48
                "mdpi": "", //可选，字符串类型，大屏设备设备推送图标路径，分辨率要求48x48
                "hdpi": "", //可选，字符串类型，高分屏设备推送图标路径，分辨率要求72x72
                "xdpi": "", //可选，字符串类型，720P高分屏设备推送图标路径，分辨率要求96x96
                "xxdpi": "", //可选，字符串类型，1080P高密度屏幕推送图标路径，分辨率要求144x144
                "xxxdpi": "" //可选，字符串类型，4K屏设备推送图标路径，分辨率要求192x192
              },
              "smal": {
                //可选，JSON对象，Push小图标配置
                "ldpi": "", //可选，字符串类型，普通屏设备推送小图标路径，分辨率要求18x18
                "mdpi": "", //可选，字符串类型，大屏设备设备推送小图标路径，分辨率要求24x24
                "hdpi": "", //可选，字符串类型，高分屏设备推送小图标路径，分辨率要求36x36
                "xdpi": "", //可选，字符串类型，720P高分屏设备推送小图标路径，分辨率要求48x48
                "xxdpi": "", //可选，字符串类型，1080P高密度屏幕推送小图标路径，分辨率要求72x72
                "xxxdpi": "" //可选，字符串类型，4K屏设备推送小图标路径，分辨率要求96x96
              }
            }
          },
          "igexin": {
            //可选，JSON对象，使用个推推送SDK配置，**已废弃，推荐使用UniPush，UniPush是个推推送VIP版，功能更强大**
            "appid": "", //必填，字符串类型，个推开放平台申请的appid
            "appkey": "", //必填，字符串类型，个推开放平台申请的appkey
            "appsecret": "", //必填，字符串类型，个推开放平台申请的appsecret
            "icons": {
              //可选，JSON对象，推送图标配置
              "push": {
                //可选，JSON对象，Push图标配置
                "ldpi": "", //可选，字符串类型，普通屏设备推送图标路径，分辨率要求48x48
                "mdpi": "", //可选，字符串类型，大屏设备设备推送图标路径，分辨率要求48x48
                "hdpi": "", //可选，字符串类型，高分屏设备推送图标路径，分辨率要求72x72
                "xdpi": "", //可选，字符串类型，720P高分屏设备推送图标路径，分辨率要求96x96
                "xxdpi": "", //可选，字符串类型，1080P高密度屏幕推送图标路径，分辨率要求144x144
                "xxxdpi": "" //可选，字符串类型，4K屏设备推送图标路径，分辨率要求192x192
              },
              "smal": {
                //可选，JSON对象，Push小图标配置
                "ldpi": "", //可选，字符串类型，普通屏设备推送小图标路径，分辨率要求18x18
                "mdpi": "", //可选，字符串类型，大屏设备设备推送小图标路径，分辨率要求24x24
                "hdpi": "", //可选，字符串类型，高分屏设备推送小图标路径，分辨率要求36x36
                "xdpi": "", //可选，字符串类型，720P高分屏设备推送小图标路径，分辨率要求48x48
                "xxdpi": "", //可选，字符串类型，1080P高密度屏幕推送小图标路径，分辨率要求72x72
                "xxxdpi": "" //可选，字符串类型，4K屏设备推送小图标路径，分辨率要求96x96
              }
            }
          }
        },
        "share": {
          //可选，JSON对象，Share(分享)模块三方SDK配置
          "weixin": {
            //可选，JSON对象，使用微信分享SDK配置
            "appid": "", //必填，字符串类型，微信开放平台申请的appid
            "UniversalLinks": "" //可选，字符串类型，微信开放平台配置的iOS平台通用链接
          },
          "qq": {
            //可选，JSON对象，使用QQ分享SDK配置
            "appid": "", //必填，字符串类型，QQ开放平台申请的appid
            "UniversalLinks": "" //可选，字符串类型，QQ开放平台配置的iOS平台通用链接
          },
          "sina": {
            //可选，JSON对象，使用新浪微博分享SDK配置
            "appkey": "", //必填，字符串类型，新浪微博开放平台申请的appid
            "redirect_uri": "", //必填，字符串类型，新浪微博开放平台配置的redirect_uri
            "UniversalLinks": "" //可选，字符串类型，新浪微博开放平台配置的iOS平台通用链接
          }
        },
        "speech": {
          //可选，JSON对象，Speech(语音识别)模块三方SDK配置
          "baidu": {
            //可选，JSON对象，使用百度语音识别SDK配置
            "appid": "", //必填，字符串类型，百度开放平台申请的appid
            "apikey": "", //必填，字符串类型，百度开放平台申请的apikey
            "secretkey": "" //必填，字符串类型，百度开放平台申请的secretkey
          }
        },
        "statics": {
          //可选，JSON对象，Statistic(统计)模块三方SDK配置
          "umeng": {
            //可选，JSON对象，使用友盟统计SDK配置
            "appkey_ios": "", //必填，字符串类型，友盟统计开放平台申请的iOS平台appkey
            "channelid_ios": "", //可选，字符串类型，友盟统计iOS平台的渠道标识
            "appkey_android": "", //必填，字符串类型，友盟统计开放平台申请的Android平台appkey
            "channelid_android": "" //可选，字符串类型，友盟统计Android平台的渠道标识
          },
          "google": {
            //可选，JSON对象，使用Google Analytics for Firebase配置
            "config_ios": "", //必填，字符串类型，Google Firebase统计开发者后台获取的iOS平台配置文件路径
            "config_android": "" //必填，字符串类型，Google Firebase统计开发者后台获取的Android平台配置文件路径
          }
        },
        "ad": {
          //可选，JSON对象，uni-AD配置
          "360": {
            //可选，JSON对象，使用360广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "csj": {
            //可选，JSON对象，使用今日头条穿山甲广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "gdt": {
            //可选，JSON对象，使用腾讯优量汇广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "ks": {
            //可选，JSON对象，使用快手广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "ks-content": {
            //可选，JSON对象，使用快手内容联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "sigmob": {
            //可选，JSON对象，使用Sigmob广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "hw": {
            //可选，JSON对象，使用华为广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "bd": {
            //可选，JSON对象，使用百度百青藤广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "BXM-AD": {
            //可选，JSON对象，使用互动游戏(变现猫)SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          }
        }
      },
      "icons": {
        //可选，JSON对象，应用图标相关配置
        "ios": {
          //可选，JSON对象，iOS平台图标配置
          "appstore": "", //必填，字符串类型，分辨率1024x1024, 提交app sotre使用的图标路径
          "iphone": {
            //可选，JSON对象，iPhone设备图标配置
            "app@2x": "", //可选，字符串类型，分辨率120x120，程序图标路径
            "app@3x": "", //可选，字符串类型，分辨率180x180，程序图标路径
            "spotlight@2x": "", //可选，字符串类型，分辨率80x80，Spotlight搜索图标路径
            "spotlight@3x": "", //可选，字符串类型，分辨率120x120，Spotlight搜索图标路径
            "settings@2x": "", //可选，字符串类型，分辨率58x58，Settings设置图标路径
            "settings@3x": "", //可选，字符串类型，分辨率87x87，Settings设置图标路径
            "notification@2x": "", //可选，字符串类型，分辨率40x40，通知栏图标路径
            "notification@3x": "" //可选，字符串类型，分辨率60x60，通知栏图标路径
          },
          "ipad": {
            //可选，JSON对象，iPad设备图标配置
            "app": "", //可选，字符串类型，分辨率76x76，程序图标图标路径
            "app@2x": "", //可选，字符串类型，分辨率152x152，程序图标图标路径
            "proapp@2x": "", //可选，字符串类型，分辨率167x167，程序图标图标路径
            "spotlight": "", //可选，字符串类型，分辨率40x40，Spotlight搜索图标路径
            "spotlight@2x": "", //可选，字符串类型，分辨率80x80，Spotlight搜索图标路径
            "settings": "", //可选，字符串类型，分辨率29x29，Settings设置图标路径
            "settings@2x": "", //可选，字符串类型，分辨率58x58，Settings设置图标路径
            "notification": "", //可选，字符串类型，分辨率20x20，通知栏图标路径
            "notification@2x": "" //可选，字符串类型，分辨率740x40，通知栏图标路径
          }
        },
        "android": {
          //可选，JSON对象，Android平台图标配置
          "ldpi": "", //可选，字符串类型，普通屏设备程序图标，分辨率要求48x48，已废弃
          "mdpi": "", //可选，字符串类型，大屏设备程序图标，分辨率要求48x48，已废弃
          "hdpi": "", //可选，字符串类型，高分屏设备程序图标，分辨率要求72x72
          "xhdpi": "", //可选，字符串类型，720P高分屏设备程序图标，分辨率要求96x96
          "xxhdpi": "", //可选，字符串类型，1080P高分屏设备程序图标，分辨率要求144x144
          "xxxhdpi": "" //可选，字符串类型，2K屏设备程序图标，分辨率要求192x192
        }
      },
      "splashscreen": {
        //可选，JSON对象，启动界面配置
        "iosStyle": "common", //可选，字符串类型，iOS平台启动界面样式，可取值common、default、storyboard
        "ios": {
          //可选，JSON对象，iOS平台启动界面配置
          "storyboard": "", //可选，字符串类型，自定义storyboard启动界面文件路径，iosStyle值为storyboard时生效
          "iphone": {
            //可选，JSON对象，iPhone设备启动图配置，iosStyle值为default时生效
            "default": "", //可选，字符串类型，分辨率320x480，iPhone3（G/GS）启动图片路径，已废弃
            "retina35": "", //可选，字符串类型，分辨率640x960，3.5英寸设备(iPhone4/4S)启动图片路径，已废弃
            "retina40": "", //可选，字符串类型，分辨率640x1136，4.0英寸设备(iPhone5/5S)启动图片路径
            "retina40l": "", //可选，字符串类型，分辨率1136x640，4.0英寸设备(iPhone5/5S)横屏启动图片路径
            "retina47": "", //可选，字符串类型，分辨率750x1334，4.7英寸设备（iPhone6/7/8）启动图片路径
            "retina47l": "", //可选，字符串类型，分辨率1334x750，4.7英寸设备（iPhone6/7/8）横屏启动图片路径
            "retina55": "", //可选，字符串类型，分辨率1242x2208，5.5英寸设备（iPhone6/7/8Plus）启动图片路径
            "retina55l": "", //可选，字符串类型，分辨率2208x1242，5.5英寸设备（iPhone6/7/8Plus）横屏启动图片路径
            "iphonex": "", //可选，字符串类型，分辨率1125x2436，5.8英寸设备（iPhoneX/XS）启动图片路径
            "iphonexl": "", //可选，字符串类型，分辨率2436x1125，5.8英寸设备（iPhoneX/XS）横屏启动图片路径
            "portrait-896h@2x": "", //可选，字符串类型，分辨率828x1792，6.1英寸设备（iPhoneXR）启动图片路径
            "landscape-896h@2x": "", //可选，字符串类型，分辨率1792x828，6.1英寸设备（iPhoneXR）iPhoneXR横屏启动图片路径
            "portrait-896h@3x": "", //可选，字符串类型，分辨率1242x2688，6.5英寸设备（iPhoneXS Max）启动图片路径
            "landscape-896h@3x": "" //可选，字符串类型，分辨率2688x1242，6.5英寸设备（iPhoneXS Max）横屏启动图片路径
          },
          "ipad": {
            //可选，JSON对象，iPad设备启动图配置，iosStyle值为default时生效
            "portrait": "", //可选，字符串类型，分辨率768x1004，iPad竖屏启动图片路径，已废弃
            "portrait-retina": "", //可选，字符串类型，分辨率1536x2008，iPad高分屏竖屏启动图片路径，已废弃
            "landscape": "", //可选，字符串类型，分辨率1024x748，iPad横屏启动图片路径，已废弃
            "landscape-retina": "", //可选，字符串类型，分辨率2048x1496，iPad高分屏横屏启动图片路径，已废弃
            "portrait7": "", //可选，字符串类型，分辨率768x1024，9.7/7.9英寸iPad/mini竖屏启动图片路径
            "landscape7": "", //可选，字符串类型，分辨率1024x768，9.7/7.9英寸iPad/mini横屏启动图片路径
            "portrait-retina7": "", //可选，字符串类型，分辨率1536x2048，9.7/7.9英寸iPad/mini高分屏竖屏图片路径
            "landscape-retina7": "", //可选，字符串类型，分辨率2048x1536，9.7/7.9英寸iPad/mini高分屏横屏启动图片路径
            "portrait-1112h@2x": "", //可选，字符串类型，分辨率1668x2224，10.5英寸iPad Pro竖屏启动图片路径
            "landscape-1112h@2x": "", //可选，字符串类型，分辨率2224x1668，10.5英寸iPad Pro横屏启动图片路径
            "portrait-1194h@2x": "", //可选，字符串类型，分辨率1668x2388，11英寸iPad Pro竖屏启动图片路径
            "landscape-1194h@2x": "", //可选，字符串类型，分辨率2388x1668，11英寸iPad Pro横屏启动图片路径
            "portrait-1366h@2x": "", //可选，字符串类型，分辨率2048x2732，12.9英寸iPad Pro竖屏启动图片路径
            "landscape-1366h@2x": "" //可选，字符串类型，分辨率2732x2048，12.9英寸iPad Pro横屏启动图片路径
          }
        },
        "androidStyle": "common", //可选，字符串类型，Android平台启动界面样式，可取值common、default
        "android": {
          //可选，JSON对象，Android平台启动图片配置， androidStyle值为default时生效
          "ldpi": "", //可选，字符串类型，分辨率320x442，低密度屏幕启动图片路径，已废弃
          "mdpi": "", //可选，字符串类型，分辨率240x282，中密度屏幕启动图片路径，已废弃
          "hdpi": "", //可选，字符串类型，分辨率480x762，高密度屏幕启动图片路径
          "xhdpi": "", //可选，字符串类型，分辨率720x1242，720P高密度屏幕启动图片路径
          "xxhdpi": "" //可选，字符串类型，分辨率1080x1882，1080P高密度屏幕启动图片路径
        }
      },
      "orientation": [
        //可选，字符串数组类型，应用支持的横竖屏，**已废弃，使用screenOrientation配置**
        "portrait-primary",
        "portrait-secondary",
        "landscape-primary",
        "landscape-secondary"
      ]
    },
    "compatible": {
      //可选，JSON对象，uni-app兼容模式
      "ignoreVersion": false, //可选，Boolean类型，是否忽略版本兼容检查提示
      "runtimeVersion": "", //可选，字符串类型，兼容的uni-app运行环境版本号，多个版本使用,分割
      "compilerVersion": "" //可选，字符串类型，兼容的编译器版本号
    },
    "confusion": {
      //可选，JSON对象，原生混淆加密配置，参考：https://uniapp.dcloud.io/tutorial/app-sec-confusion
      "description": "", //可选，字符串类型，原生混淆描述
      "resources": {
        //必填，JSON对象，原生混淆文件配置
        "js/common.js": {
          //可选，JSON对象，键名为需要原生混淆的文件路径
        }
      }
    },
    "channel": "", //可选，字符串类型，渠道标识
    "cers": {
      //可选，JSON对象，应用的异常崩溃与错误报告系统配置
      "crash": true //可选，Boolean类型，是否提交应用异常崩溃信息
    },
    "cache": {
      //可选，JSON对象，Webview窗口默认使用的缓存模式，uni-app项目已废弃
      "mode": "default" //可选，字符串类型，可取值default、cacheElseNetwork、noCache、cacheOnly
    },
    "error": {
      //可选，JSON对象，页面加载错误配置，uni-app项目仅对webview组件有效，参考：https://uniapp.dcloud.io/tutorial/app-webview-error
      "url": "" //必填，字符串类型，webview页面错误是跳转的页面地址
    },
    "kernel": {
      //可选，JSON对象，webview内核配置
      "ios": "WKWebview", //可选，iOS平台使用的webview类型，可取值WKWebview、UIWebview
      "recovery": "reload" //可选，iOS平台使用WKWebview时，内核崩溃后的处理逻辑，可取值restart、reload、none
    },
    "launchwebview": {
      //可选，JSON对象，应用首页相关配置，uni-app项目不建议手动修改
      "plusrequire": "normal", //可选，字符串类型，加载plus API时机，可取值ahead、normal、later、none
      "injection": false, //可选，Boolean类型，是否提前注入plus API
      "overrideresource": [
        //可选，JSON对象数组，应用首页的拦截资源相关配置
        {
          "match": "", //可选，字符串类型，匹配拦截的资源url地址的正则表达式
          "redirect": "", //可选，字符串类型，拦截资源的重定向地址
          "mime": "", //可选，字符串类型，拦截资源的数据类型mime
          "encoding": "", //可选，字符串类型，拦截资源的数据编码
          "header": {
            //可选，JSON对象，拦截资源的http头数据
          }
        }
      ],
      "overrideurl": {
        //可选，JSON对象，应用首页的拦截链接请求处理逻辑
        "mode": "reject", //可选，字符串类型，拦截模式，可取值allow、reject
        "match": "", //可选，字符串类型，匹配拦截规则，支持正则表达式
        "exclude": "none" //可选，字符串类型，排除拦截理规则，可取值none、redirect
      },
      "replacewebapi": {
        //可选，JSON对象，是否重写Web API实现相关配置
        "geolocation": "none" //可选，字符串类型，重写标准定位API，可取值none、alldevice、auto
      },
      "subNViews": [
        //可选，JSON对象数组，首页原生View相关配置，已废弃
        {
          "id": "", //可选，字符串类型，原生View标识
          "styles": {
            //可选，JSON对象，原生View样式
          },
          "tags": [
            //可选，JSON对象数组，原生View中包含的tag标签列表
            {}
          ]
        }
      ],
      "titleNView": {
        //可选，JSON对象，标题栏相关配置
        "backgroundColor": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，标题栏背景颜色
        "titleText": "", //可选，字符串类型，标题栏标题文字内容
        "titleColor": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，标题栏标题文字颜色
        "titleSize": "17px", //可选，字符串类型，标题字体大小，默认大小为17px
        "autoBackButton": true, //可选，Boolean类型，是否显示标题栏上返回键
        "backButton": {
          //可选，JSON对象，返回键样式
          "backgournd": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，返回按钮背景颜色
          "color": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，返回图标颜色
          "colorPressed": "#RRGGBB" //可选，字符串类型，#RRGGBB，返回图标按下时的颜色
        },
        "buttons": [
          //可选，JSON对象数组，标题栏按钮配置
          {
            "color": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，按钮上的文字颜色
            "colorPressed": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，按钮按下状态的文字颜色
            "float": "right", //可选，字符串类型，按钮显示位置，可取值left、right
            "fontWeight": "normal", //可选，字符串类型，按钮上文字的粗细，可取值normal、bold
            "fontSize": "22px", //可选，字符串类型，按钮上文字的大小
            "fontSrc": "", //可选，字符串类型，按钮上文字使用的字体文件路径
            "text": "" //可选，字符串类型，按钮上显示的文字
          }
        ],
        "splitLine": {
          //可选，JSON对象，标题栏分割线样式
          "color": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，分割线颜色
          "height": "1px" //可选，字符串类型，分割线高度
        }
      },
      "statusbar": {
        //可选，JSON对象，状态栏配置
        "background": "#RRGGBB" //可选，字符串类型，#RRGGBB格式，沉浸式状态栏样式下系统状态栏背景颜色
      },
      "top": "0px", //可选，字符串类型，Webview的顶部偏移量，支持px、%单位
      "height": "100%", //可选，字符串类型，Webview窗口高度，支持px、%单位
      "bottom": "0px", //可选，字符串类型，Webview的底部偏移量，仅在未同时设置top和height属性时生效
      "backButtonAutoControl": "none", //可选，字符串类型，运行环境自动处理返回键的控制逻辑，可取值none、hide、close
      "additionalHttpHeaders": {
        //可选，JSON对象，额外添加HTTP请求头数据
      }
    },
    "nativePlugins": {
      //可选，JSON数组对象，uni原生插件配置，参考：https://nativesupport.dcloud.net.cn/NativePlugin/use/use_local_plugin
      "%UniPlugin-ID%": {
        //可选，JSON对象，键名为插件标识，值为插件配置参数
      }
    },
    "popGesture": "none", //可选，字符串类型，窗口侧滑返回默认效果，可取值none、close、hide
    "runmode": "liberate", //可选，字符串类型，应用资源运行模式，可取值normal、liberate
    "safearea": {
      //可选，JSON对象，安全区域配置
      "background": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，安全区域背景颜色
      "backgroundDark": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，暗黑模式安全区域背景颜色
      "bottom": {
        //可选，JSON对象，底部安全区域配置
        "offset": "none" //可选，字符串类型，安全区域偏移值，可取值auto、none
      },
      "left": {
        //可选，JSON对象，左侧安全区域配置
        "offset": "none" //可选，字符串类型，安全区域偏移值，可取值auto、none
      },
      "right": {
        //可选，JSON对象，左侧安全区域配置
        "offset": "none" //可选，字符串类型，安全区域偏移值，可取值auto、none
      }
    },
    "softinput": {
      //可选，JSON对象，软键盘相关配置
      "navBar": "auto", //可选，字符串类型，iOS平台软键盘上导航条的显示模式，可取值auto、none
      "auxiliary": false, //可选，Boolean类型，是否开启辅助输入功能
      "mode": "adjustResize" //可选，字符串类型，弹出系统软键盘模式，可取值adjustResize、adjustPan
    },
    "ssl": {
      //可选，JSON对象，ssl相关设置
      "untrustedca": "accept" //可选，字符串类型，https请求时服务器非受信证书的处理逻辑，可取值accept、refuse、warning
    },
    "statusbar": {
      //可选，JSON对象，应用启动后的系统状态栏相关配置
      "immersed": "none", //可选，字符串类型，沉浸式状态栏样式，可取值none、suggestedDevice、supportedDevice
      "style": "light", //可选，字符串类型，系统状态栏样式（前景颜色），可取值dark、light
      "background": "#RRGGBB" //可选，字符串类型，#RRGGBB格式，系统状态栏背景颜色
    },
    "useragent": {
      //可选，JSON对象，应用UserAgent相关配置，默认值为系统UserAgent，并添加 uni-app Html5Plus/1.0
      "value": "", //可选，字符串类型，设置的默认userAgent值
      "concatenate": false //可选，Boolean类型，是否将value值作为追加值连接到系统默认userAgent值之后
    },
    "useragent_android": {
      //可选，JSON对象，Android平台应用UserAgent相关配置，优先级高于useragent配置
      "value": "", //可选，字符串类型，设置的默认userAgent值
      "concatenate": false //可选，Boolean类型，是否将value值作为追加值连接到系统默认userAgent值之后
    },
    "useragent_ios": {
      //可选，JSON对象，iOS平台应用UserAgent相关配置，优先级高于useragent配置
      "value": "", //可选，字符串类型，设置的默认userAgent值
      "concatenate": false //可选，Boolean类型，是否将value值作为追加值连接到系统默认userAgent值之后
    }
  },
  "quickapp": {},
  "mp-weixin": {
    "appid": "wx开头的微信小程序appid",
    "uniStatistics": {
      "enable": false
    }
  },
  "mp-baidu": {
    "appid": "百度小程序appid"
  },
  "mp-toutiao": {
    "appid": "抖音小程序appid"
  },
  "mp-lark": {
    "appid": "飞书小程序appid"
  },
  "h5": {
    "title": "演示",
    "template": "index.html",
    "router": {
      "mode": "history",
      "base": "/hello/"
    },
    "async": {
      "loading": "AsyncLoading",
      "error": "AsyncError",
      "delay": 200,
      "timeout": 3000
    }
  }
}
```

:::

## uni.scss

这个是全局的样式文件，官方预定了很多常用的样式规则和变量。

## package.json

在 web 和小程序添加一些依赖包，扩展其他的功能。

### vite.config.js

vue3 项目生成的配置文件。

## 全局组件

全局组件主要是内置组件和扩展组件。

## 内置组件

所有的视图组件，包括 view、swiper 等，本身不显示任何可视化元素，用途都是为了包裹其他真正显示的组件，可以直接在 vue 页面中使用。

常见有：

* uniapp 组件
* vue 组件
* nvue 组件
* 小程序组件

## 扩展组件

uni-ui 是 DCloud 提供的一个跨端 ui 库，它是基于 vue 组件的、flex 布局的、无 dom 的跨全端 ui 框架，不包括基础组件，它是基础组件的补充，有些组件需要到插件市场下载才可以使用。

常见有：

* 列表组件
* 表单组件
* 表格组件
* 加载更多组件
* 自定义导航栏组件
* 弹出层组件

## 常用 API

### 基础

* onPageNotFound，页面不存在事件；
* onError，错误事件；
* onAppShow，页面前台事件；
* onAppHide，页面后台事件；
* addInterceptor，拦截器；

### 网络

* request，发起请求；
* uploadFile，上传文件；
* downloadFile，下载文件；
* connectSocket，创建一个 websocket 连接；
* onSocketOpen，ws 打开事件；
* onSocketError，错误事件；
* sendSocketMessage，发送 ws 消息；
* onSocketMessage，接收 ws 消息；
* closeSocket，关闭 ws；
* onSocketClose，监听关闭 ws；

### 页面路由

* navigateTo，保留当前页面，跳转到其他页面；
* redirectTo，关闭当前页面，跳转到其他页面；
* reLaunch，关闭所有页面，跳转到其他页面；
* switchTab，跳转到 tabBar 底部导航页面；
* navigateBack，返回上一个页面或多级页面；

### 数据缓存

setStorage，将数据存储在本地缓存中的指定 key 中，覆盖原来该 key 的内容；
getStorage，从本地缓存中获取指定 key 的内容；
removeStorage，从本地缓存中移除指定 key 及内容；
clearStorage，清除本地缓存；
getStorageInfo，获取本地缓存信息；

### 界面

* showToast，显示消息提示框；
* hideToast，隐藏消息提示框；
* showLoading，显示加载提示框；
* hideLoading，隐藏加载提示框；
* showModal，显示模态弹出框；
* showActionSheet，从底部弹出操作菜单；
* onPullDownRefresh，下拉刷新；
* createSelectorQuery，节点信息；

### 文件

* chooseImage，选择图片；
* saveImageToPhotosAlbum，保存图片到相册；
* chooseFile，选择文件；
* saveFile，保存文件到本地；
* removeSavedFile，删除本地保存的文件；
* getSavedFileList，获取本地保存的文件列表；
* getFileInfo，获取文件信息；
* openDocument，新页面打开文档；

### 条件编译

**概念**

条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。

写法：以 `#ifdef` 或 `#ifndef` 加 `%PLATFORM%` 开头，以 `#endif` 结尾。

* `#ifdef`：if defined 仅在某平台存在;
* `#ifndef`：if not defined 除了某平台均存在;
* `%PLATFORM%`：平台名称;

**%PLATFORM%值：**

以下是 UniApp 中 `%PLATFORM%` 的常见值及其对应平台的表格整理：

| **平台变量**         | **对应平台**               | **说明**                              |
|----------------------|---------------------------|--------------------------------------|
| `H5`                 | Web 浏览器（HTML5）        | 运行在浏览器环境                     |
| `MP-WEIXIN`          | 微信小程序                | 微信平台的小程序                     |
| `MP-ALIPAY`          | 支付宝小程序              | 支付宝平台的小程序                   |
| `MP-BAIDU`           | 百度智能小程序            | 百度平台的小程序                     |
| `MP-TOUTIAO`         | 字节跳动小程序            | 抖音、今日头条等字节系小程序         |
| `MP-LARK`            | 飞书小程序                | 飞书平台的小程序                     |
| `MP-QQ`              | QQ 小程序                 | QQ 平台的小程序                      |
| `MP-KUAISHOU`        | 快手小程序                | 快手平台的小程序                     |
| `APP` / `APP-PLUS`   | 原生应用（Android/iOS）    | 通过 UniApp 打包成 APK 或 IPA        |
| `APP-PLUS-NVUE`      | 原生应用（NVue 页面）      | 使用 weex 原生渲染的页面             |
| `MP-360`             | 360 小程序                | 360 平台的小程序（较少使用）         |
| `QUICKAPP-WEBVIEW`   | 快应用（Webview 模式）     | 华为、小米等快应用联盟               |
| `QUICKAPP-WEBVIEW-UNION` | 快应用联盟            | 支持多厂商的快应用                   |

### **使用示例**

```javascript
// #ifdef H5
console.log("这段代码仅在 H5 环境执行");
// #endif

// #ifdef MP-WEIXIN
console.log("这段代码仅在微信小程序执行");
// #endif
```

### **注意事项**

1. **大小写敏感**：必须全大写（如 `MP-WEIXIN`，不能写成 `mp-weixin`）。
2. **条件编译**：不同平台的代码会在编译时自动分离，减少包体积。
3. **动态判断**：如需运行时判断，可使用 `uni.getSystemInfoSync().platform`，但条件编译更高效。

如果需要更详细的平台支持或最新变动，建议参考 [UniApp 官方文档](https://uniapp.dcloud.io/)。

**支持的文件**

* .vue、.pug
* .css、.scss、.less、.stylus
* .js、.ts
* pages.json

## 写法

vue/nvue 模板里使用 `<!-- 注释 -->`，css 使用 /\* 注释 \*/，js 使用 // 注释。

**模板写法**

```vue
<!--  #ifdef  %PLATFORM% -->
平台特有的组件
<!--  #endif -->

```

**css 样式写法**

```css
/*  #ifdef  %PLATFORM%  */
平台特有样式
/*  #endif  */

```

**JS 写法**

```js
// #ifdef  %PLATFORM%
平台特有的API实现;
// #endif
```

**pages.json**

```json
// #ifdef %PLATFORM%
{
  "pagePath": "pages/eg",
  "text": "案例"
}
// #endif

```

## 插件开发

[插件市场官网](https://ext.dcloud.net.cn/)

有数千款插件，支持前端组件、js sdk、页面模板、项目模板、原生插件等多种类型。在生态建设上远远领先于竞品。
请注意尽量在官方市场寻找插件，npm 等三方市场没有 uni-app 兼容性描述，很容易下载到无法跨平台的、仅适配 web 的插件。

**插件分类**

DCloud 插件市场将插件分为前端组件、JS SDK、uni-app 前端模板、App 原生插件、uniCloud 等 7 大类、20 多个子类。

**uni\_modules**

uni\_modules 是 uni-app 的插件模块化规范（HBuilderX 3.1.0+支持），通常是对一组 js sdk、组件、页面、uniCloud 云函数、公共模块等的封装，用于嵌入到 uni-app 项目中使用，也支持直接封装为项目模板。

---

---
url: /learning/engineering/modules/page5.md
---
# uniapp

## 全局文件

这里主要是两个文件：pages.json管理页面路由、和manifest.json管理应用配置。

### pages.json

pages.json 文件是进行全局配置，包括`页面文件路径`、`样式`、`原生导航栏`等内容

以下是官网给出的配置示例：

::: details

```js
{
  "pages": [
    {
      "path": "pages/component/index",
      "style": {
        "navigationBarTitleText": "组件"
      }
    },
    {
      "path": "pages/API/index",
      "style": {
        "navigationBarTitleText": "接口"
      }
    },
    {
      "path": "pages/component/view/index",
      "style": {
        "navigationBarTitleText": "view"
      }
    }
  ],
  "condition": {
    //模式配置，仅开发期间生效
    "current": 0, //当前激活的模式（list 的索引项）
    "list": [
      {
        "name": "test", //模式名称
        "path": "pages/component/view/index" //启动页面，必选
      }
    ]
  },
  "globalStyle": {
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "演示",
    "navigationBarBackgroundColor": "#F8F8F8",
    "backgroundColor": "#F8F8F8",
    "usingComponents": {
      "collapse-tree-item": "/components/collapse-tree-item"
    },
    "renderingMode": "seperated", // 仅微信小程序，webrtc 无法正常时尝试强制关闭同层渲染
    "pageOrientation": "portrait", //横屏配置，全局屏幕旋转设置(仅 APP/微信/QQ小程序)，支持 auto / portrait / landscape
    "rpxCalcMaxDeviceWidth": 960,
    "rpxCalcBaseDeviceWidth": 375,
    "rpxCalcIncludeWidth": 750
  },
  "tabBar": {
    "color": "#7A7E83",
    "selectedColor": "#3cc51f",
    "borderStyle": "black",
    "backgroundColor": "#ffffff",
    "height": "50px",
    "fontSize": "10px",
    "iconWidth": "24px",
    "spacing": "3px",
    "iconfontSrc": "static/iconfont.ttf", // app tabbar 字体.ttf文件路径 app 3.4.4+
    "list": [
      {
        "pagePath": "pages/component/index",
        "iconPath": "static/image/icon_component.png",
        "selectedIconPath": "static/image/icon_component_HL.png",
        "text": "组件",
        "iconfont": {
          // 优先级高于 iconPath，该属性依赖 tabbar 根节点的 iconfontSrc
          "text": "\ue102",
          "selectedText": "\ue103",
          "fontSize": "17px",
          "color": "#000000",
          "selectedColor": "#0000ff"
        }
      },
      {
        "pagePath": "pages/API/index",
        "iconPath": "static/image/icon_API.png",
        "selectedIconPath": "static/image/icon_API_HL.png",
        "text": "接口"
      }
    ],
    "midButton": {
      "width": "80px",
      "height": "50px",
      "text": "文字",
      "iconPath": "static/image/midButton_iconPath.png",
      "iconWidth": "24px",
      "backgroundImage": "static/image/midButton_backgroundImage.png"
    }
  },
  "easycom": {
    "autoscan": true, //是否自动扫描组件
    "custom": {
      //自定义扫描规则
      "^uni-(.*)": "@/components/uni-$1.vue"
    }
  },
  "topWindow": {
    "path": "responsive/top-window.vue",
    "style": {
      "height": "44px"
    }
  },
  "leftWindow": {
    "path": "responsive/left-window.vue",
    "style": {
      "width": "300px"
    }
  },
  "rightWindow": {
    "path": "responsive/right-window.vue",
    "style": {
      "width": "300px"
    },
    "matchMedia": {
      "minWidth": 768
    }
  }
}
```

:::

### manifest.json

manifest.json 文件是应用的配置文件，用于指定应用的名称、图标、权限等内容。

以下是官网给出的配置示例：

::: details

```js
{
  "appid": "__UNI__XXXXXX，创建应用时云端分配的，不要修改。",
  "name": "应用名称，如uni-app",
  "description": "应用描述",
  "versionName": "1.0.0",
  "versionCode": "100",
  "uniStatistics": {
    "enable": false
  },
  "app-plus": {
    "allowsInlineMediaPlayback": true, //可选，Boolean类型, 是否允许 h5 中视频非全屏播放，3.8.5版本开始默认值为 true （仅iOS生效）
    "mediaPlaybackRequiresUserAction": false, //可选，Boolean类型,可通过此属性配置 h5中的音视频是否可通过API自动播放，注意当设置为 false 时允许API控制自动播放，3.8.5版本开始默认值为 false（仅iOS生效 3.0.1 + 版本支持）
    "nvueCompiler": "weex", //可选，字符串类型，nvue页面编译模式，可取值uni-app、weex，参考：https://ask.dcloud.net.cn/article/36074
    "nvueStyleCompiler": "weex", //可选，字符串类型，nvue页面样式编译模式，可取值uni-app、weex，参考：https://ask.dcloud.net.cn/article/38751
    "renderer": "native", //可选，字符串类型，可不加载基于 webview 的运行框架，可取值native
    "compilerVersion": 2, //可选，数字类型，编译器版本，可取值2、3，参考：https://ask.dcloud.net.cn/article/36599
    "nvueLaunchMode": "normal", //可选，字符串类型，nvue首页启动模式，compilerVersion值为3时生效，可取值normal、fast，参考：https://ask.dcloud.net.cn/article/36749
    "nvue": {
      //可选，JSON对象，nvue页面相关配置
      "flex-direction": "row" //可选，字符串类型，nvue页面的flex-direction默认值，可取值row、row-reverse、column、column-reverse
    },
    "optimization": {
      //可选，JSON对象，分包配置
      "subPackages": true //可选，Boolean类型，是否开启分包优化，参考：https://uniapp.dcloud.io/collocation/pages.html#subpackages
    },
    "uniStatistics": {
      //可选，JSON对象，uni统计配置
      "enable": true //可选，Boolean类型，是否开启uni统计
    },
    "screenOrientation": [
      //可选，字符串数组类型，应用支持的横竖屏
      "portrait-primary", //可选，字符串类型，支持竖屏
      "portrait-secondary", //可选，字符串类型，支持反向竖屏
      "landscape-primary", //可选，字符串类型，支持横屏
      "landscape-secondary" //可选，字符串类型，支持反向横屏
    ],
    "splashscreen": {
      //可选，JSON对象，splash界面配置
      "alwaysShowBeforeRender": true, //可选，Boolean类型，是否等待首页渲染完毕后再关闭启动界面
      "autoclose": true, //可选，Boolean类型，是否自动关闭启动界面
      "waiting": true, //可选，Boolean类型，是否在程序启动界面显示等待雪花
      "event": "loaded", //可选，字符串类型，可取值titleUpdate、rendering、loaded，uni-app项目已废弃
      "target": "defalt", //可选，字符串类型，可取值default、second，uni-app项目已废弃
      "dealy": 0, //可选，数字类型，延迟自动关闭启动时间，单位为毫秒，uni-app项目已废弃
      "ads": {
        //可选，JSON对象，开屏广告配置
        "backaground": "#RRGGBB", //可选，字符串类型，格式为#RRGGBB，开屏广告背景颜色
        "image": "" //可选，字符串类型，底部图片地址，相对应用资源目录路径
      },
      "androidTranslucent": false //可选，Boolean类型，使用“自定义启动图”启动界面时是否显示透明过渡界面，可解决点击桌面图标延时启动应用的效果
    },
    "modules": {
      //可选，JSON对象，使用的模块
      "Bluetooth": {
        //可选，JSON对象，Bluetooth(低功耗蓝牙)
        "description": "低功耗蓝牙"
      },
      "Contacts": {
        //可选，JSON对象，Contact(通讯录)
        "description": "通讯录"
      },
      "FaceID": {
        //可选，JSON对象，FaceID(人脸识别)，仅iOS支持
        "description": "人脸识别"
      },
      "Fingerprint": {
        //可选，JSON对象，Fingerprint(指纹识别)
        "description": "指纹识别"
      },
      "Geolocation": {
        //可选，JSON对象，Geolocation(定位)
        "description": "定位"
      },
      "iBeacon": {
        //可选，JSON对象，iBeacon
        "description": "iBeacon"
      },
      "LivePusher": {
        //可选，JSON对象，LivePusher(直播推流)
        "description": "直播推流"
      },
      "Maps": {
        //可选，JSON对象，Maps(地图)
        "description": "地图"
      },
      "Messaging": {
        //可选，JSON对象，Messaging(短彩邮件消息)
        "description": "短彩邮件消息"
      },
      "OAuth": {
        //可选，JSON对象，OAuth(登录鉴权)
        "description": "登录鉴权"
      },
      "Payment": {
        //可选，JSON对象，Payment(支付)
        "description": "iBeacon"
      },
      "Push": {
        //可选，JSON对象，Push(消息推送)
        "description": "iBeacon"
      },
      "Share": {
        //可选，JSON对象，Share(分享)
        "description": "iBeacon"
      },
      "Speech": {
        //可选，JSON对象，Speech(语音输入)
        "description": "iBeacon"
      },
      "Statistic": {
        //可选，JSON对象，Statistic(统计)
        "description": "iBeacon"
      },
      "SQLite": {
        //可选，JSON对象，SQLite(统计)
        "description": "iBeacon"
      },
      "VideoPlayer": {
        //可选，JSON对象，VideoPlayer(视频播放)
        "description": "iBeacon"
      },
      "Webview-x5": {
        //可选，JSON对象，Android X5 Webview(腾讯TBS)，仅Android支持
        "description": "iBeacon"
      },
      "UIWebview": {
        //可选，JSON对象，UIWebview，仅iOS支持
        "description": "iBeacon"
      }
    },
    "webView": {
      // 3.5.0 + 当系统webview低于指定版本时，会弹出提示。或者下载x5内核后继续启动，仅Android支持
      "minUserAgentVersion": "95.0.4638.75", // 最小webview版本
      "x5": {
        // 此属性需要勾选 Android X5 Webview 模块，详细参见下面的说明
        "timeOut": 3000, // 超时时间
        "showTipsWithoutWifi": true, // 是否在非WiFi网络环境时，显示用户确认下载x5内核的弹窗。
        "allowDownloadWithoutWiFi": false // 是否允许用户在非WiFi网络时进行x5内核的下载。（如果为true，就不会显示用户确认的弹窗。）
      }
    },
    "checkPermissionDenied": false, // 是否校验已拒绝权限 如果拒绝则不会再申请 默认false 不校验已拒绝权限
    "distribute": {
      //必选，JSON对象，云端打包配置
      "android": {
        //可选，JSON对象，Android平台云端打包配置
        "packagename": "", //必填，字符串类型，Android包名
        "keystore": "", //必填，字符串类型，Android签名证书文件路径
        "password": "", //必填，字符串类型，Android签名证书文件的密码
        "aliasname": "", //必填，字符串类型，Android签名证书别名
        "schemes": "", //可选，字符串类型，参考：https://uniapp.dcloud.io/tutorial/app-android-schemes
        "abiFilters": [
          //可选，字符串数组类型，参考：https://uniapp.dcloud.io/tutorial/app-android-abifilters
          "armeabi-v7a",
          "arm64-v8a",
          "x86",
          "x86_64"
        ],
        "permissions": [
          //可选，字符串数组类型，Android权限配置
          "<uses-feature android:name=\"android.hardware.camera\"/>"
        ],
        "custompermissions": false, //可选，Boolean类型，是否自定义Android权限配置
        "permissionExternalStorage": {
          //可选，JSON对象，Android平台应用启动时申请读写手机存储权限策略
          "request": "always", //必填，字符串类型，申请读写手机存储权限策略，可取值none、once、always
          "prompt": "" //可选，字符串类型，当request设置为always值用户拒绝时弹出提示框上的内容
        },
        "permissionPhoneState": {
          //可选，JSON对象，Android平台应用启动时申请读取设备信息权限配置
          "request": "always", //必填，字符串类型，申请读取设备信息权限策略，可取值none、once、always
          "prompt": "" //可选，字符串类型，当request设置为always值用户拒绝时弹出提示框上的内容
        },
        "minSdkVersion": 21, //可选，数字类型，Android平台最低支持版本，参考：https://uniapp.dcloud.io/tutorial/app-android-minsdkversion
        "targetSdkVersion": 30, //可选，数字类型，Android平台目标版本，参考：https://uniapp.dcloud.io/tutorial/app-android-targetsdkversion
        "packagingOptions": [
          //可选，字符串数组类型，Android平台云端打包时build.gradle的packagingOptions配置项
          "doNotStrip '*/armeabi-v7a/*.so'",
          "merge '**/LICENSE.txt'"
        ],
        "jsEngine": "v8", //可选，字符串类型，uni-app使用的JS引擎，可取值v8、jsc
        "debuggable": false, //可选，Boolean类型，是否开启Android调试开关
        "locale": "default", //可选，应用的语言
        "forceDarkAllowed": false, //可选，Boolean类型，是否强制允许暗黑模式
        "resizeableActivity": false, //可选，Boolean类型，是否支持分屏调整窗口大小
        "hasTaskAffinity": false, //可选，Boolean类型，是否设置android：taskAffinity
        "buildFeatures": {
          //（HBuilderX3.5.0+版本支持）可选，JSON对象，Android平台云端打包时build.gradle的buildFeatures配置项
          "dataBinding": false, //可选，Boolean类型，是否设置dataBinding
          "viewBinding": false //可选，Boolean类型，是否设置viewBinding
        }
      },
      "ios": {
        //可选，JSON对象，iOS平台云端打包配置
        "appid": "", //必填，字符串类型，iOS平台Bundle ID
        "mobileprovision": "", //必填，字符串类型，iOS打包使用的profile文件路径
        "p12": "", //必填，字符串类型，iOS打包使用的证书文件路径
        "password": "", //必填，字符串类型，iOS打包使用的证书密码
        "devices": "iphone", //必填，字符串类型，iOS支持的设备类型，可取值iphone、ipad、universal
        "urlschemewhitelist": "baidumap", //可选，字符串类型，应用访问白名单列表，参考：https://uniapp.dcloud.io/tutorial/app-ios-schemewhitelist
        "urltypes": "", //可选，字符串类型，参考：https://uniapp.dcloud.io/tutorial/app-ios-schemes
        "UIBackgroundModes": "audio", //可选，字符串类型，应用后台运行模式，参考：https://uniapp.dcloud.io/tutorial/app-ios-uibackgroundmodes
        "frameworks": [
          //可选，字符串数组类型，依赖的系统库，已废弃，推荐使用uni原生插件扩展使用系统依赖库
          "CoreLocation.framework"
        ],
        "deploymentTarget": "10.0", //可选，字符串类型，iOS支持的最低版本
        "privacyDescription": {
          //可选，JSON对象，iOS隐私信息访问的许可描述
          "NSPhotoLibraryUsageDescription": "", //可选，字符串类型，系统相册读取权限描述
          "NSPhotoLibraryAddUsageDescription": "", //可选，字符串类型，系统相册写入权限描述
          "NSCameraUsageDescription": "", //可选，字符串类型，摄像头使用权限描述
          "NSMicrophoneUsageDescription": "", //可选，字符串类型，麦克风使用权限描述
          "NSLocationWhenInUseUsageDescription": "", //可选，字符串类型，运行期访问位置权限描述
          "NSLocationAlwaysUsageDescription": "", //可选，字符串类型，后台运行访问位置权限描述
          "NSLocationAlwaysAndWhenInUseUsageDescription": "", //可选，字符串类型，运行期后后台访问位置权限描述
          "NSCalendarsUsageDescription": "", //可选，字符串类型，使用日历权限描述
          "NSContactsUsageDescription": "", //可选，字符串类型，使用通讯录权限描述
          "NSBluetoothPeripheralUsageDescription": "", //可选，字符串类型，使用蓝牙权限描述
          "NSBluetoothAlwaysUsageDescription": "", //可选，字符串类型，后台使用蓝牙权限描述
          "NSSpeechRecognitionUsageDescription": "", //可选，字符串类型，系统语音识别权限描述
          "NSRemindersUsageDescription": "", //可选，字符串类型，系统提醒事项权限描述
          "NSMotionUsageDescription": "", //可选，字符串类型，使用运动与健康权限描述
          "NSHealthUpdateUsageDescription": "", //可选，字符串类型，使用健康更新权限描述
          "NSHealthShareUsageDescription": "", //可选，字符串类型，使用健康分享权限描述
          "NSAppleMusicUsageDescription": "", //可选，字符串类型，使用媒体资料库权限描述
          "NFCReaderUsageDescription": "", //可选，字符串类型，使用NFC权限描述
          "NSHealthClinicalHealthRecordsShareUsageDescription": "", //可选，字符串类型，访问临床记录权限描述
          "NSHomeKitUsageDescription": "", //可选，字符串类型，访问HomeKit权限描述
          "NSSiriUsageDescription": "", //可选，字符串类型，访问Siri权限描述
          "NSFaceIDUsageDescription": "", //可选，字符串类型，使用FaceID权限描述
          "NSLocalNetworkUsageDescription": "", //可选，字符串类型，访问本地网络权限描述
          "NSUserTrackingUsageDescription": "" //可选，字符串类型，跟踪用户活动权限描述
        },
        "idfa": true, //可选，Boolean类型，是否使用广告标识
        "capabilities": {
          //可选，JSON对象，应用的能力配置（Capabilities）
        },
        "CFBundleName": "HBuilder", //可选，字符串类型，CFBundleName名称
        "validArchitectures": [
          //可选，字符串数组类型，编译时支持的CPU指令，可取值arm64、arm64e、armv7、armv7s、x86_64
          "arm64"
        ],
        "pushRegisterMode": "manual", //可选，使用“Push(消息推送)”模块时申请系统推送权限模式，manual表示调用push相关API时申请，其它值表示应用启动时自动申请
        "privacyRegisterMode": "manual" //可选，仅iOS有效，设置为manual表示用户同意隐私政策后才获取idfv，设置为其它值表示应用启动时自动获取
      },
      "sdkConfigs": {
        //可选，JSON对象，三方SDK相关配置
        "geolocation": {
          //可选，JSON对象，Geolocation(定位)模块三方SDK配置
          "system": {
            //可选，JSON对象，使用系统定位
            "__platform__": ["ios", "android"] //可选，字符串数组类型，支持的平台
          },
          "amap": {
            //可选，JSON对象，使用高德定位SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "appkey_ios": "", //必填，字符串类型，iOS平台高德定位appkey
            "appkey_android": "" //必填，字符串类型，Android平台高德定位appkey
          },
          "baidu": {
            //可选，JSON对象，使用百度定位SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "appkey_ios": "", //必填，字符串类型，iOS平台百度定位appkey
            "appkey_android": "" //必填，字符串类型，Android平台百度定位appkey
          }
        },
        "maps": {
          //可选，JSON对象，Maps(地图)模块三方SDK配置
          "amap": {
            //可选，JSON对象，使用高德地图SDK配置
            "appkey_ios": "", //必填，字符串类型，iOS平台高德地图appkey
            "appkey_android": "" //必填，字符串类型，Android平台高德地图appkey
          },
          "baidu": {
            //可选，JSON对象，使用百度地图SDK配置
            "appkey_ios": "", //必填，字符串类型，iOS平台百度地图appkey
            "appkey_android": "" //必填，字符串类型，Android平台百度地图appkey
          },
          "google": {
            //可选，JSON对象，使用Google地图SDK配置
            "APIKey_ios": "", //必填，字符串类型，iOS平台Google地图APIKey
            "APIKey_android": "" //必填，字符串类型，Android平台Google地图APIKey
          }
        },
        "oauth": {
          //可选，JSON对象，OAuth(登录鉴权)模块三方SDK配置
          "univerify": {
            //可选，JSON对象，使用一键登录(univerify)SDK配置，无需手动配置参数，云端打包自动获取配置参数
          },
          "apple": {
            //可选，JSON对象，使用苹果登录(Sign in with Apple)SDK配置，无配置参数，仅iOS平台支持
          },
          "weixin": {
            //可选，JSON对象，使用微信登录SDK配置
            "appid": "", //必填，字符串类型，微信开放平台申请的appid
            "appsecret": "", //必填，字符串类型，微信开放平台申请的appsecret
            "UniversalLinks": "" //可选，字符串类型，微信开放平台配置的iOS平台通用链接
          },
          "qq": {
            //可选，JSON对象，使用QQ登录SDK配置
            "appid": "", //必填，字符串类型，QQ开放平台申请的appid
            "UniversalLinks": "" //可选，字符串类型，QQ开放平台配置的iOS平台通用链接
          },
          "sina": {
            //可选，JSON对象，使用新浪微博登录SDK配置
            "appkey": "", //必填，字符串类型，新浪微博开放平台申请的appid
            "redirect_uri": "", //必填，字符串类型，新浪微博开放平台配置的redirect_uri
            "UniversalLinks": "" //可选，字符串类型，新浪微博开放平台配置的iOS平台通用链接
          },
          "google": {
            //可选，JSON对象，使用Google登录SDK配置
            "clientid": "" //必填，字符串类型，Google开发者后台申请的clientid
          },
          "facebook": {
            //可选，JSON对象，使用Facebook登录SDK配置
            "appid": "" //必填，字符串类型，Facebook开发者后台申请的appid
          }
        },
        "payment": {
          //可选，JSON对象，Payment(支付)模块三方SDK配置
          "appleiap": {
            //可选，JSON对象，使用Apple应用内支付配置，无配置参数，仅iOS平台支持
          },
          "alipay": {
            //可选，JSON对象，使用支付宝支付SDK配置
            "__platform__": ["ios", "android"] //可选，字符串数组类型，支持的平台
          },
          "weixin": {
            //可选，JSON对象，使用微信支付SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "appid": "", //必填，字符串类型，微信开放平台申请的appid
            "UniversalLinks": "" //可选，字符串类型，微信开放平台配置的iOS平台通用链接
          },
          "paypal": {
            //可选，JSON对象，使用paypal支付SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "returnURL_ios": "", //必填，字符串类型，paypa开发者者后台配置的iOS平台returnURL
            "returnURL_android": "" //必填，字符串类型，paypa开发者者后台配置的Android平台returnURL
          },
          "stripe": {
            //可选，JSON对象，使用stripe支付SDK配置
            "__platform__": ["ios", "android"], //可选，字符串数组类型，支持的平台
            "returnURL_ios": "" //必填，字符串类型，stripe开发者者后台配置的iOS平台returnURL
          },
          "google": {
            //可选，JSON对象，使用google支付SDK配置，无配置参数，仅Android平台支持
          }
        },
        "push": {
          //可选，JSON对象，Push(消息推送)模块三方SDK配置
          "unipush": {
            //可选，JSON对象，使用UniPush SDK配置，无需手动配置参数，云端打包自动获取配置参数
            "icons": {
              //可选，JSON对象，推送图标配置
              "push": {
                //可选，JSON对象，Push图标配置
                "ldpi": "", //可选，字符串类型，普通屏设备推送图标路径，分辨率要求48x48
                "mdpi": "", //可选，字符串类型，大屏设备设备推送图标路径，分辨率要求48x48
                "hdpi": "", //可选，字符串类型，高分屏设备推送图标路径，分辨率要求72x72
                "xdpi": "", //可选，字符串类型，720P高分屏设备推送图标路径，分辨率要求96x96
                "xxdpi": "", //可选，字符串类型，1080P高密度屏幕推送图标路径，分辨率要求144x144
                "xxxdpi": "" //可选，字符串类型，4K屏设备推送图标路径，分辨率要求192x192
              },
              "smal": {
                //可选，JSON对象，Push小图标配置
                "ldpi": "", //可选，字符串类型，普通屏设备推送小图标路径，分辨率要求18x18
                "mdpi": "", //可选，字符串类型，大屏设备设备推送小图标路径，分辨率要求24x24
                "hdpi": "", //可选，字符串类型，高分屏设备推送小图标路径，分辨率要求36x36
                "xdpi": "", //可选，字符串类型，720P高分屏设备推送小图标路径，分辨率要求48x48
                "xxdpi": "", //可选，字符串类型，1080P高密度屏幕推送小图标路径，分辨率要求72x72
                "xxxdpi": "" //可选，字符串类型，4K屏设备推送小图标路径，分辨率要求96x96
              }
            }
          },
          "igexin": {
            //可选，JSON对象，使用个推推送SDK配置，**已废弃，推荐使用UniPush，UniPush是个推推送VIP版，功能更强大**
            "appid": "", //必填，字符串类型，个推开放平台申请的appid
            "appkey": "", //必填，字符串类型，个推开放平台申请的appkey
            "appsecret": "", //必填，字符串类型，个推开放平台申请的appsecret
            "icons": {
              //可选，JSON对象，推送图标配置
              "push": {
                //可选，JSON对象，Push图标配置
                "ldpi": "", //可选，字符串类型，普通屏设备推送图标路径，分辨率要求48x48
                "mdpi": "", //可选，字符串类型，大屏设备设备推送图标路径，分辨率要求48x48
                "hdpi": "", //可选，字符串类型，高分屏设备推送图标路径，分辨率要求72x72
                "xdpi": "", //可选，字符串类型，720P高分屏设备推送图标路径，分辨率要求96x96
                "xxdpi": "", //可选，字符串类型，1080P高密度屏幕推送图标路径，分辨率要求144x144
                "xxxdpi": "" //可选，字符串类型，4K屏设备推送图标路径，分辨率要求192x192
              },
              "smal": {
                //可选，JSON对象，Push小图标配置
                "ldpi": "", //可选，字符串类型，普通屏设备推送小图标路径，分辨率要求18x18
                "mdpi": "", //可选，字符串类型，大屏设备设备推送小图标路径，分辨率要求24x24
                "hdpi": "", //可选，字符串类型，高分屏设备推送小图标路径，分辨率要求36x36
                "xdpi": "", //可选，字符串类型，720P高分屏设备推送小图标路径，分辨率要求48x48
                "xxdpi": "", //可选，字符串类型，1080P高密度屏幕推送小图标路径，分辨率要求72x72
                "xxxdpi": "" //可选，字符串类型，4K屏设备推送小图标路径，分辨率要求96x96
              }
            }
          }
        },
        "share": {
          //可选，JSON对象，Share(分享)模块三方SDK配置
          "weixin": {
            //可选，JSON对象，使用微信分享SDK配置
            "appid": "", //必填，字符串类型，微信开放平台申请的appid
            "UniversalLinks": "" //可选，字符串类型，微信开放平台配置的iOS平台通用链接
          },
          "qq": {
            //可选，JSON对象，使用QQ分享SDK配置
            "appid": "", //必填，字符串类型，QQ开放平台申请的appid
            "UniversalLinks": "" //可选，字符串类型，QQ开放平台配置的iOS平台通用链接
          },
          "sina": {
            //可选，JSON对象，使用新浪微博分享SDK配置
            "appkey": "", //必填，字符串类型，新浪微博开放平台申请的appid
            "redirect_uri": "", //必填，字符串类型，新浪微博开放平台配置的redirect_uri
            "UniversalLinks": "" //可选，字符串类型，新浪微博开放平台配置的iOS平台通用链接
          }
        },
        "speech": {
          //可选，JSON对象，Speech(语音识别)模块三方SDK配置
          "baidu": {
            //可选，JSON对象，使用百度语音识别SDK配置
            "appid": "", //必填，字符串类型，百度开放平台申请的appid
            "apikey": "", //必填，字符串类型，百度开放平台申请的apikey
            "secretkey": "" //必填，字符串类型，百度开放平台申请的secretkey
          }
        },
        "statics": {
          //可选，JSON对象，Statistic(统计)模块三方SDK配置
          "umeng": {
            //可选，JSON对象，使用友盟统计SDK配置
            "appkey_ios": "", //必填，字符串类型，友盟统计开放平台申请的iOS平台appkey
            "channelid_ios": "", //可选，字符串类型，友盟统计iOS平台的渠道标识
            "appkey_android": "", //必填，字符串类型，友盟统计开放平台申请的Android平台appkey
            "channelid_android": "" //可选，字符串类型，友盟统计Android平台的渠道标识
          },
          "google": {
            //可选，JSON对象，使用Google Analytics for Firebase配置
            "config_ios": "", //必填，字符串类型，Google Firebase统计开发者后台获取的iOS平台配置文件路径
            "config_android": "" //必填，字符串类型，Google Firebase统计开发者后台获取的Android平台配置文件路径
          }
        },
        "ad": {
          //可选，JSON对象，uni-AD配置
          "360": {
            //可选，JSON对象，使用360广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "csj": {
            //可选，JSON对象，使用今日头条穿山甲广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "gdt": {
            //可选，JSON对象，使用腾讯优量汇广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "ks": {
            //可选，JSON对象，使用快手广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "ks-content": {
            //可选，JSON对象，使用快手内容联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "sigmob": {
            //可选，JSON对象，使用Sigmob广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "hw": {
            //可选，JSON对象，使用华为广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "bd": {
            //可选，JSON对象，使用百度百青藤广告联盟SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          },
          "BXM-AD": {
            //可选，JSON对象，使用互动游戏(变现猫)SDK，无需手动配置，在uni-AD后台申请开通后自动获取配置参数
          }
        }
      },
      "icons": {
        //可选，JSON对象，应用图标相关配置
        "ios": {
          //可选，JSON对象，iOS平台图标配置
          "appstore": "", //必填，字符串类型，分辨率1024x1024, 提交app sotre使用的图标路径
          "iphone": {
            //可选，JSON对象，iPhone设备图标配置
            "app@2x": "", //可选，字符串类型，分辨率120x120，程序图标路径
            "app@3x": "", //可选，字符串类型，分辨率180x180，程序图标路径
            "spotlight@2x": "", //可选，字符串类型，分辨率80x80，Spotlight搜索图标路径
            "spotlight@3x": "", //可选，字符串类型，分辨率120x120，Spotlight搜索图标路径
            "settings@2x": "", //可选，字符串类型，分辨率58x58，Settings设置图标路径
            "settings@3x": "", //可选，字符串类型，分辨率87x87，Settings设置图标路径
            "notification@2x": "", //可选，字符串类型，分辨率40x40，通知栏图标路径
            "notification@3x": "" //可选，字符串类型，分辨率60x60，通知栏图标路径
          },
          "ipad": {
            //可选，JSON对象，iPad设备图标配置
            "app": "", //可选，字符串类型，分辨率76x76，程序图标图标路径
            "app@2x": "", //可选，字符串类型，分辨率152x152，程序图标图标路径
            "proapp@2x": "", //可选，字符串类型，分辨率167x167，程序图标图标路径
            "spotlight": "", //可选，字符串类型，分辨率40x40，Spotlight搜索图标路径
            "spotlight@2x": "", //可选，字符串类型，分辨率80x80，Spotlight搜索图标路径
            "settings": "", //可选，字符串类型，分辨率29x29，Settings设置图标路径
            "settings@2x": "", //可选，字符串类型，分辨率58x58，Settings设置图标路径
            "notification": "", //可选，字符串类型，分辨率20x20，通知栏图标路径
            "notification@2x": "" //可选，字符串类型，分辨率740x40，通知栏图标路径
          }
        },
        "android": {
          //可选，JSON对象，Android平台图标配置
          "ldpi": "", //可选，字符串类型，普通屏设备程序图标，分辨率要求48x48，已废弃
          "mdpi": "", //可选，字符串类型，大屏设备程序图标，分辨率要求48x48，已废弃
          "hdpi": "", //可选，字符串类型，高分屏设备程序图标，分辨率要求72x72
          "xhdpi": "", //可选，字符串类型，720P高分屏设备程序图标，分辨率要求96x96
          "xxhdpi": "", //可选，字符串类型，1080P高分屏设备程序图标，分辨率要求144x144
          "xxxhdpi": "" //可选，字符串类型，2K屏设备程序图标，分辨率要求192x192
        }
      },
      "splashscreen": {
        //可选，JSON对象，启动界面配置
        "iosStyle": "common", //可选，字符串类型，iOS平台启动界面样式，可取值common、default、storyboard
        "ios": {
          //可选，JSON对象，iOS平台启动界面配置
          "storyboard": "", //可选，字符串类型，自定义storyboard启动界面文件路径，iosStyle值为storyboard时生效
          "iphone": {
            //可选，JSON对象，iPhone设备启动图配置，iosStyle值为default时生效
            "default": "", //可选，字符串类型，分辨率320x480，iPhone3（G/GS）启动图片路径，已废弃
            "retina35": "", //可选，字符串类型，分辨率640x960，3.5英寸设备(iPhone4/4S)启动图片路径，已废弃
            "retina40": "", //可选，字符串类型，分辨率640x1136，4.0英寸设备(iPhone5/5S)启动图片路径
            "retina40l": "", //可选，字符串类型，分辨率1136x640，4.0英寸设备(iPhone5/5S)横屏启动图片路径
            "retina47": "", //可选，字符串类型，分辨率750x1334，4.7英寸设备（iPhone6/7/8）启动图片路径
            "retina47l": "", //可选，字符串类型，分辨率1334x750，4.7英寸设备（iPhone6/7/8）横屏启动图片路径
            "retina55": "", //可选，字符串类型，分辨率1242x2208，5.5英寸设备（iPhone6/7/8Plus）启动图片路径
            "retina55l": "", //可选，字符串类型，分辨率2208x1242，5.5英寸设备（iPhone6/7/8Plus）横屏启动图片路径
            "iphonex": "", //可选，字符串类型，分辨率1125x2436，5.8英寸设备（iPhoneX/XS）启动图片路径
            "iphonexl": "", //可选，字符串类型，分辨率2436x1125，5.8英寸设备（iPhoneX/XS）横屏启动图片路径
            "portrait-896h@2x": "", //可选，字符串类型，分辨率828x1792，6.1英寸设备（iPhoneXR）启动图片路径
            "landscape-896h@2x": "", //可选，字符串类型，分辨率1792x828，6.1英寸设备（iPhoneXR）iPhoneXR横屏启动图片路径
            "portrait-896h@3x": "", //可选，字符串类型，分辨率1242x2688，6.5英寸设备（iPhoneXS Max）启动图片路径
            "landscape-896h@3x": "" //可选，字符串类型，分辨率2688x1242，6.5英寸设备（iPhoneXS Max）横屏启动图片路径
          },
          "ipad": {
            //可选，JSON对象，iPad设备启动图配置，iosStyle值为default时生效
            "portrait": "", //可选，字符串类型，分辨率768x1004，iPad竖屏启动图片路径，已废弃
            "portrait-retina": "", //可选，字符串类型，分辨率1536x2008，iPad高分屏竖屏启动图片路径，已废弃
            "landscape": "", //可选，字符串类型，分辨率1024x748，iPad横屏启动图片路径，已废弃
            "landscape-retina": "", //可选，字符串类型，分辨率2048x1496，iPad高分屏横屏启动图片路径，已废弃
            "portrait7": "", //可选，字符串类型，分辨率768x1024，9.7/7.9英寸iPad/mini竖屏启动图片路径
            "landscape7": "", //可选，字符串类型，分辨率1024x768，9.7/7.9英寸iPad/mini横屏启动图片路径
            "portrait-retina7": "", //可选，字符串类型，分辨率1536x2048，9.7/7.9英寸iPad/mini高分屏竖屏图片路径
            "landscape-retina7": "", //可选，字符串类型，分辨率2048x1536，9.7/7.9英寸iPad/mini高分屏横屏启动图片路径
            "portrait-1112h@2x": "", //可选，字符串类型，分辨率1668x2224，10.5英寸iPad Pro竖屏启动图片路径
            "landscape-1112h@2x": "", //可选，字符串类型，分辨率2224x1668，10.5英寸iPad Pro横屏启动图片路径
            "portrait-1194h@2x": "", //可选，字符串类型，分辨率1668x2388，11英寸iPad Pro竖屏启动图片路径
            "landscape-1194h@2x": "", //可选，字符串类型，分辨率2388x1668，11英寸iPad Pro横屏启动图片路径
            "portrait-1366h@2x": "", //可选，字符串类型，分辨率2048x2732，12.9英寸iPad Pro竖屏启动图片路径
            "landscape-1366h@2x": "" //可选，字符串类型，分辨率2732x2048，12.9英寸iPad Pro横屏启动图片路径
          }
        },
        "androidStyle": "common", //可选，字符串类型，Android平台启动界面样式，可取值common、default
        "android": {
          //可选，JSON对象，Android平台启动图片配置， androidStyle值为default时生效
          "ldpi": "", //可选，字符串类型，分辨率320x442，低密度屏幕启动图片路径，已废弃
          "mdpi": "", //可选，字符串类型，分辨率240x282，中密度屏幕启动图片路径，已废弃
          "hdpi": "", //可选，字符串类型，分辨率480x762，高密度屏幕启动图片路径
          "xhdpi": "", //可选，字符串类型，分辨率720x1242，720P高密度屏幕启动图片路径
          "xxhdpi": "" //可选，字符串类型，分辨率1080x1882，1080P高密度屏幕启动图片路径
        }
      },
      "orientation": [
        //可选，字符串数组类型，应用支持的横竖屏，**已废弃，使用screenOrientation配置**
        "portrait-primary",
        "portrait-secondary",
        "landscape-primary",
        "landscape-secondary"
      ]
    },
    "compatible": {
      //可选，JSON对象，uni-app兼容模式
      "ignoreVersion": false, //可选，Boolean类型，是否忽略版本兼容检查提示
      "runtimeVersion": "", //可选，字符串类型，兼容的uni-app运行环境版本号，多个版本使用,分割
      "compilerVersion": "" //可选，字符串类型，兼容的编译器版本号
    },
    "confusion": {
      //可选，JSON对象，原生混淆加密配置，参考：https://uniapp.dcloud.io/tutorial/app-sec-confusion
      "description": "", //可选，字符串类型，原生混淆描述
      "resources": {
        //必填，JSON对象，原生混淆文件配置
        "js/common.js": {
          //可选，JSON对象，键名为需要原生混淆的文件路径
        }
      }
    },
    "channel": "", //可选，字符串类型，渠道标识
    "cers": {
      //可选，JSON对象，应用的异常崩溃与错误报告系统配置
      "crash": true //可选，Boolean类型，是否提交应用异常崩溃信息
    },
    "cache": {
      //可选，JSON对象，Webview窗口默认使用的缓存模式，uni-app项目已废弃
      "mode": "default" //可选，字符串类型，可取值default、cacheElseNetwork、noCache、cacheOnly
    },
    "error": {
      //可选，JSON对象，页面加载错误配置，uni-app项目仅对webview组件有效，参考：https://uniapp.dcloud.io/tutorial/app-webview-error
      "url": "" //必填，字符串类型，webview页面错误是跳转的页面地址
    },
    "kernel": {
      //可选，JSON对象，webview内核配置
      "ios": "WKWebview", //可选，iOS平台使用的webview类型，可取值WKWebview、UIWebview
      "recovery": "reload" //可选，iOS平台使用WKWebview时，内核崩溃后的处理逻辑，可取值restart、reload、none
    },
    "launchwebview": {
      //可选，JSON对象，应用首页相关配置，uni-app项目不建议手动修改
      "plusrequire": "normal", //可选，字符串类型，加载plus API时机，可取值ahead、normal、later、none
      "injection": false, //可选，Boolean类型，是否提前注入plus API
      "overrideresource": [
        //可选，JSON对象数组，应用首页的拦截资源相关配置
        {
          "match": "", //可选，字符串类型，匹配拦截的资源url地址的正则表达式
          "redirect": "", //可选，字符串类型，拦截资源的重定向地址
          "mime": "", //可选，字符串类型，拦截资源的数据类型mime
          "encoding": "", //可选，字符串类型，拦截资源的数据编码
          "header": {
            //可选，JSON对象，拦截资源的http头数据
          }
        }
      ],
      "overrideurl": {
        //可选，JSON对象，应用首页的拦截链接请求处理逻辑
        "mode": "reject", //可选，字符串类型，拦截模式，可取值allow、reject
        "match": "", //可选，字符串类型，匹配拦截规则，支持正则表达式
        "exclude": "none" //可选，字符串类型，排除拦截理规则，可取值none、redirect
      },
      "replacewebapi": {
        //可选，JSON对象，是否重写Web API实现相关配置
        "geolocation": "none" //可选，字符串类型，重写标准定位API，可取值none、alldevice、auto
      },
      "subNViews": [
        //可选，JSON对象数组，首页原生View相关配置，已废弃
        {
          "id": "", //可选，字符串类型，原生View标识
          "styles": {
            //可选，JSON对象，原生View样式
          },
          "tags": [
            //可选，JSON对象数组，原生View中包含的tag标签列表
            {}
          ]
        }
      ],
      "titleNView": {
        //可选，JSON对象，标题栏相关配置
        "backgroundColor": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，标题栏背景颜色
        "titleText": "", //可选，字符串类型，标题栏标题文字内容
        "titleColor": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，标题栏标题文字颜色
        "titleSize": "17px", //可选，字符串类型，标题字体大小，默认大小为17px
        "autoBackButton": true, //可选，Boolean类型，是否显示标题栏上返回键
        "backButton": {
          //可选，JSON对象，返回键样式
          "backgournd": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，返回按钮背景颜色
          "color": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，返回图标颜色
          "colorPressed": "#RRGGBB" //可选，字符串类型，#RRGGBB，返回图标按下时的颜色
        },
        "buttons": [
          //可选，JSON对象数组，标题栏按钮配置
          {
            "color": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，按钮上的文字颜色
            "colorPressed": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，按钮按下状态的文字颜色
            "float": "right", //可选，字符串类型，按钮显示位置，可取值left、right
            "fontWeight": "normal", //可选，字符串类型，按钮上文字的粗细，可取值normal、bold
            "fontSize": "22px", //可选，字符串类型，按钮上文字的大小
            "fontSrc": "", //可选，字符串类型，按钮上文字使用的字体文件路径
            "text": "" //可选，字符串类型，按钮上显示的文字
          }
        ],
        "splitLine": {
          //可选，JSON对象，标题栏分割线样式
          "color": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，分割线颜色
          "height": "1px" //可选，字符串类型，分割线高度
        }
      },
      "statusbar": {
        //可选，JSON对象，状态栏配置
        "background": "#RRGGBB" //可选，字符串类型，#RRGGBB格式，沉浸式状态栏样式下系统状态栏背景颜色
      },
      "top": "0px", //可选，字符串类型，Webview的顶部偏移量，支持px、%单位
      "height": "100%", //可选，字符串类型，Webview窗口高度，支持px、%单位
      "bottom": "0px", //可选，字符串类型，Webview的底部偏移量，仅在未同时设置top和height属性时生效
      "backButtonAutoControl": "none", //可选，字符串类型，运行环境自动处理返回键的控制逻辑，可取值none、hide、close
      "additionalHttpHeaders": {
        //可选，JSON对象，额外添加HTTP请求头数据
      }
    },
    "nativePlugins": {
      //可选，JSON数组对象，uni原生插件配置，参考：https://nativesupport.dcloud.net.cn/NativePlugin/use/use_local_plugin
      "%UniPlugin-ID%": {
        //可选，JSON对象，键名为插件标识，值为插件配置参数
      }
    },
    "popGesture": "none", //可选，字符串类型，窗口侧滑返回默认效果，可取值none、close、hide
    "runmode": "liberate", //可选，字符串类型，应用资源运行模式，可取值normal、liberate
    "safearea": {
      //可选，JSON对象，安全区域配置
      "background": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，安全区域背景颜色
      "backgroundDark": "#RRGGBB", //可选，字符串类型，#RRGGBB格式，暗黑模式安全区域背景颜色
      "bottom": {
        //可选，JSON对象，底部安全区域配置
        "offset": "none" //可选，字符串类型，安全区域偏移值，可取值auto、none
      },
      "left": {
        //可选，JSON对象，左侧安全区域配置
        "offset": "none" //可选，字符串类型，安全区域偏移值，可取值auto、none
      },
      "right": {
        //可选，JSON对象，左侧安全区域配置
        "offset": "none" //可选，字符串类型，安全区域偏移值，可取值auto、none
      }
    },
    "softinput": {
      //可选，JSON对象，软键盘相关配置
      "navBar": "auto", //可选，字符串类型，iOS平台软键盘上导航条的显示模式，可取值auto、none
      "auxiliary": false, //可选，Boolean类型，是否开启辅助输入功能
      "mode": "adjustResize" //可选，字符串类型，弹出系统软键盘模式，可取值adjustResize、adjustPan
    },
    "ssl": {
      //可选，JSON对象，ssl相关设置
      "untrustedca": "accept" //可选，字符串类型，https请求时服务器非受信证书的处理逻辑，可取值accept、refuse、warning
    },
    "statusbar": {
      //可选，JSON对象，应用启动后的系统状态栏相关配置
      "immersed": "none", //可选，字符串类型，沉浸式状态栏样式，可取值none、suggestedDevice、supportedDevice
      "style": "light", //可选，字符串类型，系统状态栏样式（前景颜色），可取值dark、light
      "background": "#RRGGBB" //可选，字符串类型，#RRGGBB格式，系统状态栏背景颜色
    },
    "useragent": {
      //可选，JSON对象，应用UserAgent相关配置，默认值为系统UserAgent，并添加 uni-app Html5Plus/1.0
      "value": "", //可选，字符串类型，设置的默认userAgent值
      "concatenate": false //可选，Boolean类型，是否将value值作为追加值连接到系统默认userAgent值之后
    },
    "useragent_android": {
      //可选，JSON对象，Android平台应用UserAgent相关配置，优先级高于useragent配置
      "value": "", //可选，字符串类型，设置的默认userAgent值
      "concatenate": false //可选，Boolean类型，是否将value值作为追加值连接到系统默认userAgent值之后
    },
    "useragent_ios": {
      //可选，JSON对象，iOS平台应用UserAgent相关配置，优先级高于useragent配置
      "value": "", //可选，字符串类型，设置的默认userAgent值
      "concatenate": false //可选，Boolean类型，是否将value值作为追加值连接到系统默认userAgent值之后
    }
  },
  "quickapp": {},
  "mp-weixin": {
    "appid": "wx开头的微信小程序appid",
    "uniStatistics": {
      "enable": false
    }
  },
  "mp-baidu": {
    "appid": "百度小程序appid"
  },
  "mp-toutiao": {
    "appid": "抖音小程序appid"
  },
  "mp-lark": {
    "appid": "飞书小程序appid"
  },
  "h5": {
    "title": "演示",
    "template": "index.html",
    "router": {
      "mode": "history",
      "base": "/hello/"
    },
    "async": {
      "loading": "AsyncLoading",
      "error": "AsyncError",
      "delay": 200,
      "timeout": 3000
    }
  }
}
```

:::

## uni.scss

这个是全局的样式文件，官方预定了很多常用的样式规则和变量。

## package.json

在 web 和小程序添加一些依赖包，扩展其他的功能。

### vite.config.js

vue3 项目生成的配置文件。

## 全局组件

全局组件主要是内置组件和扩展组件。

## 内置组件

所有的视图组件，包括 view、swiper 等，本身不显示任何可视化元素，用途都是为了包裹其他真正显示的组件，可以直接在 vue 页面中使用。

常见有：

* uniapp 组件
* vue 组件
* nvue 组件
* 小程序组件

## 扩展组件

uni-ui 是 DCloud 提供的一个跨端 ui 库，它是基于 vue 组件的、flex 布局的、无 dom 的跨全端 ui 框架，不包括基础组件，它是基础组件的补充，有些组件需要到插件市场下载才可以使用。

常见有：

* 列表组件
* 表单组件
* 表格组件
* 加载更多组件
* 自定义导航栏组件
* 弹出层组件

## 常用 API

### 基础

* onPageNotFound，页面不存在事件；
* onError，错误事件；
* onAppShow，页面前台事件；
* onAppHide，页面后台事件；
* addInterceptor，拦截器；

### 网络

* request，发起请求；
* uploadFile，上传文件；
* downloadFile，下载文件；
* connectSocket，创建一个 websocket 连接；
* onSocketOpen，ws 打开事件；
* onSocketError，错误事件；
* sendSocketMessage，发送 ws 消息；
* onSocketMessage，接收 ws 消息；
* closeSocket，关闭 ws；
* onSocketClose，监听关闭 ws；

### 页面路由

* navigateTo，保留当前页面，跳转到其他页面；
* redirectTo，关闭当前页面，跳转到其他页面；
* reLaunch，关闭所有页面，跳转到其他页面；
* switchTab，跳转到 tabBar 底部导航页面；
* navigateBack，返回上一个页面或多级页面；

### 数据缓存

setStorage，将数据存储在本地缓存中的指定 key 中，覆盖原来该 key 的内容；
getStorage，从本地缓存中获取指定 key 的内容；
removeStorage，从本地缓存中移除指定 key 及内容；
clearStorage，清除本地缓存；
getStorageInfo，获取本地缓存信息；

### 界面

* showToast，显示消息提示框；
* hideToast，隐藏消息提示框；
* showLoading，显示加载提示框；
* hideLoading，隐藏加载提示框；
* showModal，显示模态弹出框；
* showActionSheet，从底部弹出操作菜单；
* onPullDownRefresh，下拉刷新；
* createSelectorQuery，节点信息；

### 文件

* chooseImage，选择图片；
* saveImageToPhotosAlbum，保存图片到相册；
* chooseFile，选择文件；
* saveFile，保存文件到本地；
* removeSavedFile，删除本地保存的文件；
* getSavedFileList，获取本地保存的文件列表；
* getFileInfo，获取文件信息；
* openDocument，新页面打开文档；

### 条件编译

**概念**

条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。

写法：以 `#ifdef` 或 `#ifndef` 加 `%PLATFORM%` 开头，以 `#endif` 结尾。

* `#ifdef`：if defined 仅在某平台存在;
* `#ifndef`：if not defined 除了某平台均存在;
* `%PLATFORM%`：平台名称;

**%PLATFORM%值：**

以下是 UniApp 中 `%PLATFORM%` 的常见值及其对应平台的表格整理：

| **平台变量**         | **对应平台**               | **说明**                              |
|----------------------|---------------------------|--------------------------------------|
| `H5`                 | Web 浏览器（HTML5）        | 运行在浏览器环境                     |
| `MP-WEIXIN`          | 微信小程序                | 微信平台的小程序                     |
| `MP-ALIPAY`          | 支付宝小程序              | 支付宝平台的小程序                   |
| `MP-BAIDU`           | 百度智能小程序            | 百度平台的小程序                     |
| `MP-TOUTIAO`         | 字节跳动小程序            | 抖音、今日头条等字节系小程序         |
| `MP-LARK`            | 飞书小程序                | 飞书平台的小程序                     |
| `MP-QQ`              | QQ 小程序                 | QQ 平台的小程序                      |
| `MP-KUAISHOU`        | 快手小程序                | 快手平台的小程序                     |
| `APP` / `APP-PLUS`   | 原生应用（Android/iOS）    | 通过 UniApp 打包成 APK 或 IPA        |
| `APP-PLUS-NVUE`      | 原生应用（NVue 页面）      | 使用 weex 原生渲染的页面             |
| `MP-360`             | 360 小程序                | 360 平台的小程序（较少使用）         |
| `QUICKAPP-WEBVIEW`   | 快应用（Webview 模式）     | 华为、小米等快应用联盟               |
| `QUICKAPP-WEBVIEW-UNION` | 快应用联盟            | 支持多厂商的快应用                   |

### **使用示例**

```javascript
// #ifdef H5
console.log("这段代码仅在 H5 环境执行");
// #endif

// #ifdef MP-WEIXIN
console.log("这段代码仅在微信小程序执行");
// #endif
```

### **注意事项**

1. **大小写敏感**：必须全大写（如 `MP-WEIXIN`，不能写成 `mp-weixin`）。
2. **条件编译**：不同平台的代码会在编译时自动分离，减少包体积。
3. **动态判断**：如需运行时判断，可使用 `uni.getSystemInfoSync().platform`，但条件编译更高效。

如果需要更详细的平台支持或最新变动，建议参考 [UniApp 官方文档](https://uniapp.dcloud.io/)。

**支持的文件**

* .vue、.pug
* .css、.scss、.less、.stylus
* .js、.ts
* pages.json

## 写法

vue/nvue 模板里使用 `<!-- 注释 -->`，css 使用 /\* 注释 \*/，js 使用 // 注释。

**模板写法**

```vue
<!--  #ifdef  %PLATFORM% -->
平台特有的组件
<!--  #endif -->

```

**css 样式写法**

```css
/*  #ifdef  %PLATFORM%  */
平台特有样式
/*  #endif  */

```

**JS 写法**

```js
// #ifdef  %PLATFORM%
平台特有的API实现;
// #endif
```

**pages.json**

```json
// #ifdef %PLATFORM%
{
  "pagePath": "pages/eg",
  "text": "案例"
}
// #endif

```

## 插件开发

[插件市场官网](https://ext.dcloud.net.cn/)

有数千款插件，支持前端组件、js sdk、页面模板、项目模板、原生插件等多种类型。在生态建设上远远领先于竞品。
请注意尽量在官方市场寻找插件，npm 等三方市场没有 uni-app 兼容性描述，很容易下载到无法跨平台的、仅适配 web 的插件。

**插件分类**

DCloud 插件市场将插件分为前端组件、JS SDK、uni-app 前端模板、App 原生插件、uniCloud 等 7 大类、20 多个子类。

**uni\_modules**

uni\_modules 是 uni-app 的插件模块化规范（HBuilderX 3.1.0+支持），通常是对一组 js sdk、组件、页面、uniCloud 云函数、公共模块等的封装，用于嵌入到 uni-app 项目中使用，也支持直接封装为项目模板。

---

---
url: /Interview/css/page.md
---


---

---
url: /Interview/html/page.md
---


---

---
url: /about/page.md
---
## 关于我

**技术栈**

|                                |  Stack              |
| ---------------------------------- | :----------------- |
| Language             |                    |
| FrontEnd   |                        |
| CI/CD   |                |

**能做什么？**

|         端                       |  技术栈              |
| ---------------------------------- | :----------------- |
| PC端 | vue2/vue3 |
| H5端 | vue2/vue3 |
| 微信小程序 |uniapp |
| 桌面应用程序 |uniapp |

---

---
url: /englishCorner/modules/page.md
---


---

---
url: /learning/browserNetwork/modules/page10.md
---


---

---
url: /learning/browserNetwork/modules/page11.md
---


---

---
url: /learning/browserNetwork/modules/page8.md
---


---

---
url: /learning/browserNetwork/modules/page9.md
---


---

---
url: /learning/core/modules/page10.md
---


---

---
url: /learning/core/modules/page11.md
---


---

---
url: /learning/core/modules/page7.md
---


---

---
url: /learning/core/modules/page8.md
---


---

---
url: /learning/core/modules/page9.md
---


---

---
url: /learning/engineering/modules/page10.md
---


---

---
url: /learning/engineering/modules/page11.md
---


---

---
url: /learning/engineering/modules/page12.md
---


---

---
url: /learning/engineering/modules/page7.md
---


---

---
url: /learning/engineering/modules/page8.md
---


---

---
url: /learning/engineering/modules/page9.md
---


---

---
url: /learning/layoutStyle/modules/page11.md
---


---

---
url: /learning/layoutStyle/modules/page10.md
---


---

---
url: /learning/layoutStyle/modules/page3.md
---


---

---
url: /learning/layoutStyle/modules/page4.md
---


---

---
url: /learning/layoutStyle/modules/page5.md
---


---

---
url: /learning/layoutStyle/modules/page6.md
---


---

---
url: /learning/layoutStyle/modules/page7.md
---


---

---
url: /learning/layoutStyle/modules/page8.md
---


---

---
url: /learning/layoutStyle/modules/page9.md
---


---

---
url: /learning/optimization/modules/page10.md
---


---

---
url: /learning/optimization/modules/page11.md
---


---

---
url: /learning/optimization/modules/page5.md
---


---

---
url: /learning/optimization/modules/page6.md
---


---

---
url: /learning/optimization/modules/page7.md
---


---

---
url: /learning/optimization/modules/page8.md
---


---

---
url: /learning/optimization/modules/page9.md
---


---

---
url: /mathCorner/modules/page1.md
---


---

---
url: /note/rollup/modules/page1.md
---


---

---
url: /note/rollup/modules/page2.md
---


---

---
url: /note/rollup/modules/page3.md
---


---

---
url: /note/rollup/modules/page4.md
---


---

---
url: /note/typeScript/modules/page1.md
---


---

---
url: /note/rollup/page.md
---


---

---
url: /note/typeScript/modules/page2.md
---


---

---
url: /note/typeScript/modules/page3.md
---


---

---
url: /note/typeScript/modules/page4.md
---


---

---
url: /note/typeScript/page.md
---


---

---
url: /note/uniapp/modules/page1.md
---


---

---
url: /note/uniapp/modules/page3.md
---


---

---
url: /note/uniapp/modules/page4.md
---


---

---
url: /note/uniapp/modules/page2.md
---


---

---
url: /note/uniapp/page.md
---


---

---
url: /note/vite/modules/page3.md
---


---

---
url: /note/vite/modules/page4.md
---


---

---
url: /note/vite/page1.md
---


---

---
url: /note/vue3/modules/page2.md
---


---

---
url: /note/vue3/modules/page3.md
---


---

---
url: /note/vue3/modules/page4.md
---


---

---
url: /note/webpack/modules/page1.md
---


---

---
url: /note/webpack/modules/page2.md
---


---

---
url: /note/webpack/modules/page3.md
---


---

---
url: /note/webpack/modules/page4.md
---


---

---
url: /note/webpack/page.md
---


---

---
url: /novel/overachiever/pages/page21.md
---


---

---
url: /site/framework.md
---


---

---
url: /site/html-css.md
---


---

---
url: /site/page.md
---


---

---
url: /Interview/vue/pages/page10.md
---
# v-if 与 v-show 的区别

当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。

---

---
url: /Interview/vue/pages/page6.md
---
# v-model 双向绑定的原理是什么

v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。

---

---
url: /learning/engineering/modules/page2.md
---
# Vite

> Vite 是一个现代化的前端构建工具，它的底层实现原理和构建优化策略与传统的打包工具（如 Webpack）有显著不同。Vite 利用 **原生 ES 模块（ESM）** 和 **按需编译** 的特性，实现了**极速冷启动**和**高效的热更新（HMR）**。

## 一、Vite 的核心实现原理

### 1. 利用浏览器原生 ESM 支持（原生模块加载）

Vite 的核心思想是：

> **“在开发阶段，不打包代码，直接通过浏览器的原生 ES Module 加载机制运行代码。”**

这意味着：

* 不需要将所有代码打包成一个 bundle 文件
* 不需要构建整个依赖图谱
* 每个文件作为独立的模块通过 `import` 加载
* 遇到非原生支持的文件（如 `.ts`, `.jsx`, `.vue`）时，Vite 才会进行按需编译

这样做的好处是：

✅ 极快的冷启动\
✅ 高效的热更新（HMR）\
✅ 极低的构建延迟

***

### 2. 开发服务器（Dev Server） + 中间件架构

Vite 的开发服务器基于 **Koa** 或 **Connect** 类似的中间件架构，使用 **esbuild**、**PostCSS**、**Rollup** 等工具进行按需转换。

#### 主要流程如下：

1. 用户访问入口文件（如 `index.html`）
2. 浏览器请求入口 JS 文件（如 `main.js`）
3. Vite 拦截请求，判断是否需要转换（如 `.ts`, `.vue`, `.jsx`）
4. 如果需要，调用相应的插件进行编译和转换（如使用 esbuild 编译 TypeScript）
5. 返回处理后的代码，浏览器继续加载依赖模块
6. 循环处理所有依赖模块，直到页面加载完成

***

## 二、Vite 的构建原理（生产构建）

在生产构建阶段，Vite 使用 **Rollup** 进行打包。Rollup 是一个专注于 ESM 的打包工具，非常适合现代 JavaScript 的打包优化。

### 构建流程：

1. **入口分析**：从 `index.html` 中解析出入口模块（如 `<script type="module">` 中的 src）
2. **依赖收集**：递归解析所有依赖模块，构建完整的依赖图
3. **编译转换**：
   * 使用 esbuild 编译 TypeScript、JSX、CSS 预处理器等
   * 使用 PostCSS 处理 CSS
   * 使用 Babel 转译低版本兼容代码（可选）
4. **优化打包**：
   * Tree Shaking：移除未使用代码
   * Code Splitting：按需拆分代码
   * CSS 提取
5. **输出构建结果**：生成最终的 `dist/` 目录

***

## 三、Vite 的优化原理

### 1. 冷启动快（Dev Server 无需打包）

* 传统工具（如 Webpack）在启动时需要打包整个项目，耗时长
* Vite 启动时仅启动开发服务器，不打包，直接运行代码，因此启动速度极快（通常 < 1s）

### 2. 热更新快（HMR 无需全量刷新）

* Webpack 的 HMR 是基于 bundle 的，修改一个文件可能触发整个 bundle 重新打包
* Vite 的 HMR 是基于模块的，只更新修改的模块，速度极快

### 3. 插件系统灵活（基于 Rollup 插件）

* Vite 使用 Rollup 的插件生态，支持丰富的插件扩展（如 Vue、React、TypeScript、CSS 预处理器等）
* 插件可以在开发和构建阶段都生效

### 4. 依赖预构建（Dependency Pre-Bundling）

Vite 会将 `node_modules` 中的依赖进行预构建，解决以下问题：

* 一些第三方库使用的是 CommonJS 或 UMD 格式，浏览器无法直接加载
* 依赖可能包含多个模块，预构建可以减少请求次数

预构建使用 **esbuild**，速度非常快。

***

## 四、Vite 的关键技术栈

| 技术 | 作用 |
|------|------|
| **esbuild** | 极速的 TypeScript、JSX、CSS 预处理器编译器 |
| **Rollup** | 生产环境打包工具，用于 Tree Shaking、Code Splitting |
| **PostCSS** | CSS 后处理，支持自动加前缀等 |
| **Babel** | 可选，用于低版本浏览器兼容 |
| **WebSocket** | 实现 HMR，通知浏览器更新模块 |

***

## 五、Vite 与 Webpack 的对比

| 特性 | Vite | Webpack |
|------|------|---------|
| 开发模式 | 原生 ESM，不打包 | 打包成 bundle |
| 启动速度 | 极快（< 1s） | 较慢（几秒到几十秒） |
| HMR 速度 | 极快（毫秒级） | 相对较慢 |
| 生产打包 | 基于 Rollup | 基于 Webpack |
| 插件生态 | 基于 Rollup 插件 | 自有插件系统 |
| 支持语言 | 支持 TS、JSX、Vue、React、CSS 预处理器等 | 支持广泛，但配置较复杂 |

***

## 六、总结一句话：

> **Vite 的核心原理是利用浏览器原生 ESM 支持，在开发阶段按需编译模块，不打包，从而实现极快的冷启动和热更新；在生产阶段使用 Rollup 进行高效打包，结合 esbuild 和插件系统，提供现代前端开发的最佳体验。**

***

如果你正在准备前端高级面试，建议结合以下内容深入理解 Vite：

* Rollup 的打包机制
* esbuild 的编译原理
* HMR 的实现细节
* 插件系统的运行机制
* 如何自定义 Vite 插件

## Vite 的缺点

尽管 Vite 作为新一代的前端构建工具提供了许多创新性的功能和显著的性能提升，但它也并非完美无缺。以下是一些 Vite 的潜在缺点或限制：

### 1. **兼容性问题**

* **浏览器支持**：虽然现代浏览器对 ES 模块的支持已经相当成熟，但在某些老旧浏览器上，可能需要额外的 polyfills 或者使用 Babel 进行转译，这可能会增加项目的复杂度。
* **服务端渲染（SSR）**：对于一些复杂的 SSR 场景，Vite 可能会遇到一些挑战或者需要特定配置来适配。

### 2. **插件生态不如 Webpack 成熟**

* 尽管 Vite 基于 Rollup 插件系统，并且可以兼容部分 Webpack 插件，但其整体插件生态系统相较于 Webpack 来说还不够丰富和成熟。这意味着在某些特殊需求下，你可能找不到合适的插件，或者需要自己开发。

### 3. **学习曲线**

* 对于习惯了传统打包工具（如 Webpack）的开发者来说，转向 Vite 可能需要一定的时间来适应其不同的工作流和概念。特别是如何有效利用 Vite 的特性来优化项目结构和性能方面。

### 4. **大型项目中的表现**

* 在非常大型的项目中，由于 Vite 不预先打包所有代码，在开发环境中可能会导致较多的网络请求，尤其是在模块数量非常多的情况下。虽然可以通过适当的配置进行优化，但这仍然是一个需要注意的地方。

### 5. **依赖预构建**

* Vite 使用 esbuild 预构建 `node_modules` 中的依赖，这对于提高开发效率是非常有帮助的。然而，在某些情况下，如果第三方库更新频繁，可能会影响开发体验，因为每次重新安装依赖时都可能触发一次预构建过程。

### 6. **生产环境下的打包时间**

* 虽然 Vite 在开发模式下表现出色，但在生产环境下使用 Rollup 进行打包时，与经过高度优化的 Webpack 打包流程相比，打包时间和最终输出文件大小可能存在差异。不过，随着 Vite 和 Rollup 的不断进化，这个问题正在逐渐改善。

### Vite 如何解决浏览器兼容性问题？

Vite 主要通过以下几种方式来解决浏览器兼容性问题：

1. **Browserslist 配置**：Vite 使用 `browserslist` 来确定目标浏览器的范围。你可以在项目根目录下的 `package.json` 文件中配置 `browserslist` 字段，或者创建一个独立的 `.browserslistrc` 文件。基于这个配置，Vite 可以自动应用适当的转译和 polyfills。

2. **PostCSS 和 Autoprefixer**：对于 CSS 的兼容性问题，Vite 默认集成了 PostCSS 以及 Autoprefixer 插件，它能够根据你的 `browserslist` 配置为 CSS 属性添加必要的前缀，确保样式在不同浏览器中的兼容性。

3. **JS 转译**：虽然 Vite 强调使用现代 JavaScript 特性（ESM），但对于需要支持旧版浏览器的情况，可以通过 Babel 或其他工具对 JavaScript 进行转译。你可以配置 Vite 使用 Babel 来转换 ES6+ 代码到更早版本的 JavaScript，以便在不完全支持 ESM 的浏览器上运行。

4. **Polyfill 服务或手动引入 Polyfills**：如果项目需要支持非常老旧的浏览器，可能还需要额外引入 polyfills（例如 fetch、Promise 等）。这通常不是默认行为，开发者需要根据具体需求手动配置或引入相应的 polyfill 库。

### Vite 在大型项目中的优化策略

为了应对大型项目的挑战，Vite 提供了多种优化策略：

1. **依赖预构建（Dependency Pre-Bundling）**：Vite 使用 esbuild 对 `node_modules` 中的依赖进行预构建。Esbuild 是用 Go 编写的高性能打包工具，相比 JavaScript 实现的打包器如 Webpack 或 Rollup，它的速度要快得多。这不仅提高了开发服务器的启动速度，也减少了浏览器请求次数，因为一些重复的模块会被合并成单一文件。

2. **Code Splitting 和 Tree Shaking**：在生产环境中，Vite 利用 Rollup 的能力来进行代码分割和摇树优化。这意味着只有实际使用的代码才会被打包进最终的应用程序中，未使用的代码将被移除，从而减少最终打包体积。

3. **按需加载与异步导入（Dynamic Imports）**：Vite 支持动态导入语法，允许按需加载模块，这对于大型应用尤其重要，因为它可以帮助减少初始加载时间，并且只在需要时才加载特定部分的功能。

4. **环境变量与条件编译**：利用环境变量和条件编译技术，可以针对不同的部署环境（开发、测试、生产等）进行定制化构建，去除不必要的功能或日志输出，进一步减小包大小并提高性能。

5. **自定义插件扩展**：Vite 拥有灵活的插件系统，允许开发者根据自身需求编写插件，比如用于处理特定类型的资源文件、优化图片加载、压缩文本资源等，以适应大型项目的特殊要求。

通过这些策略，Vite 不仅能够在开发阶段提供快速响应和高效的热更新体验，同时也能保证在生产环境中生成高效、优化良好的应用。

当然可以！下面我将详细解释 **Vite 的依赖预构建原理** 和 **按需加载的实现机制**，这两个特性是 Vite 高性能开发体验的核心。

***

## 一、Vite 的依赖预构建（Dependency Pre-Bundling）原理详解

### 🎯 1. 什么是依赖预构建？

在开发模式下，Vite 使用浏览器原生 ES 模块（ESM）来加载代码。但很多第三方库（如 React、Vue、lodash 等）并不是以 ESM 格式发布的，而是使用 CommonJS（CJS）、UMD 或者包含多个模块的包结构。

这些格式不能直接被浏览器加载，因此 Vite 在启动开发服务器之前会先进行一个 **“预构建”** 步骤，把 `node_modules` 中的依赖转换为浏览器可识别的 ESM 格式。

***

### 🔧 2. 预构建的实现流程

#### （1）检测依赖

Vite 会解析入口文件中引用的模块路径（如 `import vue from 'vue'`），识别出哪些是外部依赖（即来自 `node_modules` 的模块）。

#### （2）使用 esbuild 进行快速打包

Vite 内部使用 [esbuild](https://esbuild.github.io/) 来执行预构建。esbuild 是用 Go 编写的超快 JS/TS 打包工具，比 Webpack 快几十倍。

* 它会将 CJS 模块转换为 ESM
* 合并多个依赖文件，减少 HTTP 请求次数
* 可以进行压缩和 Tree Shaking（可选）

#### （3）缓存机制

预构建的结果会被缓存到 `.vite/deps/` 目录中：

* 第一次启动时会构建依赖
* 下次启动时如果依赖未变，则直接复用缓存
* 如果你修改了 `package.json` 中的依赖版本或名称，Vite 会自动重新构建

#### （4）注入虚拟模块

Vite 将预构建后的依赖作为虚拟模块提供给浏览器访问，例如：

```javascript
import vue from 'vue'
```

实际请求的是：

```
/__vite_init__/deps/vue.js
```

这是由 Vite 开发服务器动态代理的路径。

***

### ✅ 3. 预构建的好处

| 好处 | 说明 |
|------|------|
| ⚡ 极快的冷启动 | esbuild 的编译速度非常快，几乎不影响开发体验 |
| 📡 减少请求数量 | 多个模块合并后，浏览器只需加载少量文件 |
| 🧩 支持非 ESM 库 | 能让 CommonJS 或 UMD 模块也能在浏览器中运行 |
| 🗂️ 统一模块系统 | 所有依赖最终都以 ESM 形式暴露，避免兼容问题 |

***

### 🧰 4. 如何配置依赖预构建？

你可以通过 `vite.config.js` 中的 `optimizeDeps` 字段手动控制预构建行为：

```js
// vite.config.js
export default defineConfig({
  optimizeDeps: {
    include: ['vue', 'react', 'lodash'], // 强制预构建的依赖
    exclude: ['some-heavy-lib'], // 排除某些依赖不预构建
    esbuildOptions: {
      // 自定义 esbuild 参数
      target: 'es2020',
      supported: {
        bigint: true
      }
    }
  }
})
```

***

## 二、Vite 的按需加载（On-demand Loading）如何实现？

Vite 的开发模式基于原生 ESM，天然支持按需加载，它不像 Webpack 那样需要提前构建整个 bundle，而是在浏览器真正需要某个模块时才去请求和编译。

***

### 🌐 1. 基本原理：浏览器驱动的模块加载

在开发环境中，Vite 不预先打包所有代码，而是根据浏览器的 `import` 请求，逐个处理模块。

例如：

```js
import { add } from './math.js'
```

浏览器会发起对 `math.js` 的请求，Vite 开发服务器拦截该请求，并根据文件类型进行实时编译和返回。

***

### 🧪 2. 动态导入（Dynamic Import）

Vite 对 `import()` 动态导入的支持也非常优秀，这使得你可以实现懒加载功能模块。

例如：

```js
button.addEventListener('click', async () => {
  const utils = await import('./utils.js')
  utils.doSomething()
})
```

在这种情况下：

* 初始页面不会加载 `utils.js`
* 只有当用户点击按钮时才会请求并执行 `utils.js`
* Vite 会拦截该请求并实时编译该模块（如有必要）

***

### 📦 3. 插件介入编译过程

Vite 的插件系统可以在模块加载过程中介入：

* 拦截特定文件类型（如 `.ts`, `.vue`, `.scss`）
* 使用 esbuild / Babel / PostCSS 等工具进行转换
* 返回处理后的代码供浏览器使用

例如，当你写：

```js
import App from './App.vue'
```

Vite 会调用 Vue 插件，将 `.vue` 文件编译成标准的 JavaScript 模块再返回。

***

### 📈 4. HMR（热更新）优化

由于是按需加载模块，Vite 的 HMR（热更新）也非常高效：

* 修改一个文件只触发该模块的更新
* 不需要重新打包整个应用
* 更新延迟通常在毫秒级

***

## 总结对比：Vite vs Webpack 的按需加载策略

| 特性 | Vite | Webpack |
|------|------|---------|
| 按需加载方式 | 浏览器驱动，原生 ESM + 实时编译 | Webpack Runtime 控制代码分割 |
| 动态导入 | 支持，无需额外配置 | 支持，但需要 splitChunks 配置 |
| 热更新效率 | 极快，仅更新改动模块 | 较慢，可能重新打包部分 chunk |
| 开发阶段是否打包 | 否 | 是 |

***

## ✅ 总结一句话：

> **Vite 的依赖预构建利用 esbuild 将 `node_modules` 中的依赖转换为浏览器可用的 ESM 模块，提升开发体验；其按需加载机制基于原生 ESM，结合动态导入和插件系统，在开发阶段实现高效的模块加载和热更新。**

***

如果你正在准备前端高级面试，建议深入理解以下内容：

* `esbuild` 的工作原理与优势
* `Rollup` 与 `Webpack` 在生产打包上的差异
* Vite 插件系统的生命周期与钩子函数
* 如何自定义 Vite 插件实现特定编译逻辑

当然可以！下面我将详细为你解释：

***

## 一、**esbuild 的工作原理详解**

### 🔍 1. esbuild 是什么？

[esbuild](https://esbuild.github.io/) 是一个用 Go 编写的 JavaScript/TypeScript/JSX 打包工具和压缩器，以 **极快的构建速度** 著称。它比 Webpack 或 Babel 快几十倍甚至上百倍，非常适合用于开发阶段的快速编译。

Vite 在开发模式中大量使用 esbuild 来处理 `.ts`, `.jsx`, `.css`, `.json` 等文件的即时编译，从而实现极速的冷启动和热更新。

***

### 🧠 2. esbuild 的核心工作原理

esbuild 的高性能来源于其独特的设计哲学和实现方式：

#### ✅ （1）原生语言编写（Go）

* 使用 Go 编写，执行速度快，内存管理效率高
* 相比 JS 实现的打包工具（如 Babel、Webpack），性能优势明显

#### ✅ （2）单线程 + 并行化处理

* esbuild 利用多核 CPU 并行解析和生成代码
* 每个文件独立处理，互不依赖，提高吞吐量

#### ✅ （3）语法分析器高度优化

* 内置超快的词法分析器和语法分析器，直接读取源码并解析 AST（抽象语法树）
* 不像 Babel 那样做复杂的转换，而是专注于“解析 → 转换 → 输出”

#### ✅ （4）最小化的 AST 操作

* esbuild 尽可能减少对 AST 的操作，避免复杂插件系统带来的性能损耗
* 支持基本的 JSX、TS、CSS、JSON 转换，但不支持复杂的 Babel 插件生态

#### ✅ （5）内置压缩功能

* 支持高效的 JS/CSS 压缩（minify）
* 可替代 UglifyJS/Terser，压缩速度更快

***

### ⚙️ 3. esbuild 的典型用途

| 用途 | 说明 |
|------|------|
| TypeScript 编译 | 支持 `.ts` 和 `.tsx` 文件，无需额外配置 Babel |
| JSX 转换 | 支持 React 的 JSX 语法 |
| CSS 合并与压缩 | 支持内联 CSS 并进行压缩 |
| JSON 处理 | 支持 JSON 文件导入 |
| 构建工具集成 | Vite、Snowpack、Deno 等现代工具都使用了 esbuild |

***

### 💡 4. esbuild 的局限性

虽然 esbuild 非常快，但它不是万能的：

| 局限 | 说明 |
|------|------|
| 插件系统弱 | 不支持复杂的 Babel 插件或自定义 AST 转换 |
| 不支持装饰器 | 默认不支持 experimental decorators |
| 不支持 PostCSS 插件 | 无法处理 CSS 预处理器（需配合 PostCSS） |
| 不能完全替代 Babel/Webpack | 更适合开发阶段的快速编译，生产环境仍需 Rollup/Webpack |

***

## 二、**Vite 的插件系统有哪些内置插件？**

Vite 的插件系统基于 **Rollup 插件规范**，同时也提供了一些专为开发服务器定制的内置插件。

这些插件在开发和构建阶段自动启用，帮助你处理各种类型的模块和资源。

***

### 🧩 1. Vite 核心内置插件列表

以下是 Vite 默认启用的一些关键内置插件：

| 插件名称 | 功能描述 |
|----------|-----------|
| `@vitejs/plugin-react` | 支持 React JSX 和 Fast Refresh |
| `@vitejs/plugin-vue` | 支持 Vue 单文件组件（SFC）编译 |
| `@vitejs/plugin-vue-jsx` | 支持 Vue 中使用 JSX 语法 |
| `@vitejs/plugin-preact` | 支持 Preact 开发 |
| `unplugin-vue-components` | 自动按需引入 Vue 组件（如 Element Plus、Ant Design Vue 等 UI 库） |
| `@vitejs/plugin-eslint` | ESLint 代码检查 |
| `@vitejs/plugin-babel` | 支持 Babel 转译（可选） |
| `@vitejs/plugin-commonjs` | 支持 CommonJS 模块（主要用于 SSR 场景） |
| `@vitejs/plugin-legacy` | 支持旧浏览器（IE11）的构建 |
| `@vitejs/plugin-md` | 支持 Markdown 文件作为组件 |
| `@vitejs/plugin-svg-icons` | SVG 图标自动加载支持 |

> 这些插件大多数是通过 `vite.config.js` 中的 `plugins` 字段引入的，有些则是默认启用的（如 Vue 插件在 Vue 项目中自动加载）。

***

### 📁 2. 内置插件的工作流程

Vite 插件主要在以下两个阶段起作用：

#### 🛠️ 开发阶段（Dev Server）

* 拦截浏览器请求的模块（如 `.vue`, `.ts`, `.scss`）
* 对模块内容进行实时转换（如：Vue SFC 编译成 JS 模块）
* 返回给浏览器运行

#### 📦 构建阶段（Build）

* 参与 Rollup 的打包流程
* 处理代码分割、Tree Shaking、资源优化等
* 最终输出生产环境可用的打包结果

***

### 🧪 3. 如何查看当前项目使用的插件？

你可以打开项目的 `vite.config.js` 查看插件列表：

```js
import vue from '@vitejs/plugin-vue'
import react from '@vitejs/plugin-react'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    vue(),
    react()
  ]
})
```

也可以使用命令查看 Vite 内部使用的插件：

```bash
npx vite build --mode production --report
```

或者使用调试工具（如 VSCode 调试器）查看插件注册过程。

***

## ✅ 总结一句话：

> **esbuild 是一个基于 Go 的极速 JS/TS 打包工具，Vite 用它实现实时编译和依赖预构建；而 Vite 的插件系统基于 Rollup 插件机制，内置了对 Vue、React、TypeScript、CSS 预处理器等的支持，帮助开发者高效地处理各种模块和资源类型。**

***

如果你正在准备前端高级面试，建议深入理解以下扩展内容：

* 如何编写一个简单的 Vite 插件？
* Rollup 插件钩子函数（如 `resolveId`, `load`, `transform`）
* esbuild 与 Babel 的区别与适用场景
* Vite 插件如何影响 HMR 和 SSR

当然可以！Vite 的插件系统基于 **Rollup 插件规范**，所以你可以使用 Rollup 的插件钩子来编写 Vite 插件。下面我将带你一步步写出一个**简单的 Vite 插件**，并解释其原理。

***

## 🧱 一、Vite 插件的基本结构

Vite 插件本质上是一个对象（或函数返回一个对象），它包含一些钩子函数，用于在构建和开发流程中执行特定任务。

### 最简插件模板：

```js
// plugins/my-plugin.js
export default {
  name: 'my-plugin', // 插件名称（必须）

  // 钩子函数示例
  transform(code, id) {
    if (id.endsWith('.js')) {
      // 修改 JS 文件内容
      return code.replace('console.log("hello")', 'console.log("hello from my plugin")')
    }
  }
}
```

然后在 `vite.config.js` 中引入：

```js
import { defineConfig } from 'vite'
import myPlugin from './plugins/my-plugin'

export default defineConfig({
  plugins: [myPlugin()]
})
```

***

## 🔍 二、常用插件钩子函数说明

| 钩子函数 | 触发时机 | 用途 |
|----------|-----------|------|
| `config` | 在配置被读取后调用 | 修改或扩展 Vite 配置 |
| `transformIndexHtml` | HTML 被处理时 | 修改 HTML 内容（如注入脚本） |
| `resolveId(id, importer)` | 解析模块 ID 时 | 自定义模块解析逻辑 |
| `load(id)` | 加载文件时 | 返回自定义的模块内容 |
| `transform(code, id)` | 模块转换阶段 | 修改代码内容（如替换变量、注入代码） |
| `handleHotUpdate(ctx)` | 热更新时 | 自定义 HMR 行为 |

***

## 💡 三、实战：写一个“Hello World”级的插件

我们来写一个插件，在页面加载时自动注入一段 JS 代码，显示欢迎信息。

### 步骤 1：创建插件文件

```js
// plugins/hello-world-plugin.js
export default function helloWorldPlugin() {
  return {
    name: 'hello-world-plugin',

    // 修改 HTML 内容
    transformIndexHtml(html) {
      return html.replace(
        '</body>',
        `<script>
          console.log('Hello from Vite Plugin!')
        </script>
        </body>`
      )
    }
  }
}
```

### 步骤 2：在 `vite.config.js` 中注册插件

```js
import { defineConfig } from 'vite'
import helloWorldPlugin from './plugins/hello-world-plugin'

export default defineConfig({
  plugins: [helloWorldPlugin()]
})
```

### 效果：

当你启动项目时，浏览器控制台会输出：

```
Hello from Vite Plugin!
```

***

## 🛠️ 四、进阶：实现一个“动态导入日志”的插件

我们来写一个插件，当某个模块被动态导入时，打印日志。

```js
// plugins/log-dynamic-imports.js
export default function logDynamicImports() {
  return {
    name: 'log-dynamic-imports',

    transform(code, id) {
      if (code.includes('import(')) {
        // 替换 import(...) 为带有日志的版本
        const transformedCode = code.replace(
          /import$(.*?)$/g,
          `(() => {
            console.log('Dynamic importing:', $1);
            return import($1);
          })()`
        )
        return transformedCode
      }
    }
  }
}
```

这个插件会在每次使用 `import()` 动态导入模块时，输出一条日志。

***

## 📚 五、插件生命周期与顺序

* 插件是按数组顺序执行的，顺序会影响行为。
* 有些插件需要放在其他插件之前或之后才能正常工作。
* 可以通过 `enforce: 'pre' | 'post'` 来控制插件执行顺序：

```js
{
  name: 'my-pre-plugin',
  enforce: 'pre',
  transform(code, id) {
    // 这个插件会在其他非 pre 的插件之前运行
  }
}
```

***

## ✅ 六、总结一句话：

> **编写一个 Vite 插件的核心是理解 Rollup 插件钩子机制，并根据需求选择合适的钩子函数进行拦截和修改操作。无论是修改 HTML、注入脚本、转换代码还是监听热更新，都可以通过插件灵活实现。**

***

如果你正在准备前端高级面试，建议深入掌握以下内容：

* 如何利用 `resolveId` 和 `load` 实现虚拟模块？
* 如何在插件中集成 esbuild 或 Babel 做复杂转换？
* 如何编写支持 SSR 的插件？
* 插件如何影响 Tree Shaking 和 Code Splitting？

当然可以！下面我将为你写一个 **Vite 插件示例**，该插件会在开发服务器运行时：

* 实时打印浏览器请求的模块路径（URL）
* 在控制台记录请求日志（包括时间、方法、路径等）

这个插件非常适合用于调试开发环境下的模块加载流程。

***

## ✅ 示例目标

* 创建一个 Vite 插件
* 监听开发服务器的每个 HTTP 请求
* 打印请求路径和相关信息到终端（Node.js 控制台）
* 支持配置是否开启日志功能

***

## 📁 1. 创建插件文件

创建一个插件文件，比如：`plugins/request-logger-plugin.js`

```js
// plugins/request-logger-plugin.js

export default function requestLoggerPlugin(options = {}) {
  const { enable = true } = options;

  return {
    name: 'vite-plugin-request-logger',

    // 这个钩子在开发服务器启动后调用
    configureServer(server) {
      if (!enable) return;

      return () => {
        server.middlewares.use((req, res, next) => {
          const startTime = Date.now();

          // 记录请求开始
          console.log(
            `\x1b[36m[Request]\x1b[0m ${req.method} ${req.url} \x1b[33m(starting)\x1b[0m`
          );

          // 包装 end 方法以监听响应结束
          const originalEnd = res.end;
          res.end = function (chunk, encoding) {
            const duration = Date.now() - startTime;
            console.log(
              `\x1b[32m[Request]\x1b[0m ${req.method} ${req.url} \x1b[35m${duration}ms\x1b[0m \x1b[33m(ended)\x1b[0m`
            );
            return originalEnd.call(this, chunk, encoding);
          };

          next();
        });
      };
    }
  };
}
```

***

## 🛠️ 2. 在 `vite.config.js` 中使用插件

```js
import { defineConfig } from 'vite'
import requestLoggerPlugin from './plugins/request-logger-plugin'

export default defineConfig({
  plugins: [
    requestLoggerPlugin({
      enable: true // 可以设为 false 关闭日志
    })
  ]
})
```

***

## 📈 3. 插件功能说明

| 功能 | 说明 |
|------|------|
| 日志拦截 | 使用中间件拦截所有开发服务器的请求 |
| 请求方法与路径 | 显示 `GET`, `POST` 等方法及完整 URL 路径 |
| 请求耗时 | 记录从请求进入插件到响应结束的时间 |
| 彩色输出 | 使用 ANSI 颜色代码美化控制台输出 |

***

## 🎯 4. 示例输出效果（终端）

```bash
[Request] GET /main.js                  (starting)
[Request] GET /main.js                  8ms (ended)

[Request] GET /__vite_open_in_editor_host__
[Request] GET /__vite_open_in_editor_host__  3ms (ended)

[Request] GET /src/App.vue              (starting)
[Request] GET /src/App.vue              12ms (ended)
```

***

## 🔍 5. 插件扩展建议（可选）

你可以进一步增强这个插件的功能，例如：

* 将日志写入文件（配合 `fs.appendFileSync`）
* 排除某些路径（如 `/@vite/*`）避免过多日志干扰
* 添加 IP 地址识别（通过 `req.socket.remoteAddress`）
* 支持日志级别（info/warn/error）

***

## ✅ 总结一句话：

> **我们通过编写一个基于 `configureServer` 钩子的 Vite 插件，成功实现了开发阶段对 HTTP 请求路径的实时日志记录功能。这种插件机制可用于调试模块加载、性能分析或实现自定义中间件逻辑。**

***

如果你正在准备前端高级面试，这个插件可以帮助你展示你对 Vite 插件系统、中间件机制、HTTP 生命周期的理解。

需要我帮你整理一份完整的 **“Vite 插件开发实战手册”** 吗？包含插件模板、钩子函数详解、最佳实践等内容。

---

---
url: /note/vite/modules/page1.md
---
# Vite + Vue3 项目中支持 JSX 语法

### 1. 安装必要依赖

首先需要安装支持 JSX 的插件：

```bash
npm install @vitejs/plugin-vue-jsx -D
# 或者
yarn add @vitejs/plugin-vue-jsx -D
```

### 2. 配置 Vite

修改 `vite.config.js` 文件：

```javascript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueJsx from '@vitejs/plugin-vue-jsx'

export default defineConfig({
  plugins: [
    vue(), 
    vueJsx() // 添加这行
  ]
})
```

### 3. 使用 JSX

现在你可以在 `.vue` 文件或 `.jsx`/`.tsx` 文件中使用 JSX 了：

#### 方式一：在 .vue 文件中使用

```vue
<script setup>
const title = 'Hello JSX'
const count = ref(0)

const renderTitle = () => <h1>{title}</h1>
</script>

<template>
  <div>
    {renderTitle()}
    <button onClick={() => count.value++}>
      点击次数: {count.value}
    </button>
  </div>
</template>
```

#### 方式二：创建单独的 JSX 组件

创建 `MyComponent.jsx` 文件：

```jsx
import { defineComponent } from 'vue'

export default defineComponent({
  setup() {
    return () => (
      <div>
        <h1>我是JSX组件</h1>
      </div>
    )
  }
})
```

### 4. 在组件中使用 JSX 组件

```vue
<script setup>
import MyComponent from './MyComponent.jsx'
</script>

<template>
  <MyComponent />
</template>
```

### 5. 常见问题解决

#### 问题1：JSX 中如何使用 v-model？

```jsx
<input v-model={value} />
// 等同于
<input value={value} onInput={e => value = e.target.value} />
```

#### 问题2：如何绑定事件？

```jsx
<button onClick={handleClick}>点击</button>
```

#### 问题3：如何绑定 class 和 style？

```jsx
<div class={['foo', { active: isActive }]} style={{ color: 'red' }}>
  样式和类名绑定
</div>
```

### 6. TypeScript 支持

如果是 TS 项目，确保 `tsconfig.json` 中有：

```json
{
  "compilerOptions": {
    "jsx": "preserve"
  }
}
```

### 7. 为什么推荐这种方式？

* 官方维护的插件，兼容性好
* 配置简单，只需安装一个插件
* 支持 Vue3 的所有特性
* 与 Vite 的热更新完美配合

### 8. 其他注意事项

1. JSX 中组件名必须大写开头（如 `<MyComponent />`）
2. 片段需要用 `<></>` 或 `<Fragment></Fragment>` 包裹
3. 属性使用驼峰命名（如 `onClick` 而不是 `@click`）

---

---
url: /note/vite/modules/page2.md
---
# Vite 中使用 CSS 的各种功能

以下是 Vite 中 CSS 功能的全面总结与配置指南，结合最佳实践和示例代码，帮助开发者高效管理样式：

## 🎨 一、基础 CSS 支持

Vite 原生支持 CSS 文件，无需额外配置：

* 直接导入 `CSS`：在 `JS/TS` 文件中通过 `import './style.css'` 引入，`Vite` 会自动将样式注入 `< style>` 标签并插入 `HTML` 头部。

* CSS 变量（自定义属性）：

  支持通过 `:root` 定义全局变量，增强代码复用性：

  ```css
  :root { --primary-color: #1890ff; }
  ```

## 🔒 二、CSS 模块化（避免样式冲突）

通过 .module.css 后缀启用模块化，生成哈希类名：

* 基本使用：

```js
  import styles from './module.module.css';
  <div className={styles.container}>内容</div>
```

* 配置选项（vite.config.js）：

  可自定义类名生成规则和作用域：

  ```js
  export default defineConfig({
    css: {
      modules: {
        scopeBehaviour: 'local', // 局部作用域
        generateScopedName: '[name]__[local]___[hash:base64:5]' // 自定义命名格式
      }
    }
  });
  ```

  通过 globalModulePaths 排除全局样式文件（如 /global.css/）。

## ⚙️ 三、CSS 预处理器支持

Vite 内置 Sass、Less、Stylus 支持，需安装对应依赖（如 npm install sass -D）：

* 全局变量注入（避免重复导入）：

```js
  // vite.config.js
  export default defineConfig({
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: `@import "@/styles/variables.scss";` // 自动注入全局变量
        },
        less: {
          modifyVars: { 'primary-color': '#1DA57A' }, // 修改 Less 变量
          javascriptEnabled: true
        },
        styl: {
          import: ['~@/styles/variables.styl'] // Stylus 全局导入
        }
      }
    }
  });
```

## 🛠️ 四、PostCSS 集成

通过 PostCSS 插件增强 CSS 功能：

* 自动添加浏览器前缀（使用 autoprefixer）：

```js
  // vite.config.js
  import autoprefixer from 'autoprefixer';
  export default defineConfig({
    css: {
      postcss: {
        plugins: [autoprefixer({ overrideBrowserslist: ['Chrome > 40'] })]
      }
    }
  });
```

* 常用插件推荐：

  * postcss-nested：支持嵌套语法（如 Sass 风格）。

  * postcss-pxtorem：将 px 转换为 rem。

  * cssnano：生产环境压缩 CSS。

## ✨ 五、CSS 原子化框架

推荐使用 Windi CSS 或 Tailwind CSS 提升开发效率：

* UnoCSS 接入步骤（Vite 官方推荐）：

  1. 安装依赖：npm install -D unocss @unocss/vite
  2. 配置插件：

  ```js
      // vite.config.js
      import Unocss from 'unocss/vite';
      export default defineConfig({
      plugins: [Unocss({ presets: [presetUno(), presetAttributify()] })]
      });
  ```

  3. 在组件中动态生成原子类：

  ```vue
   <template>
     <div :class="`text-${color}-500 hover:bg-${hoverColor}/50`"></div>
   </template>
  ```
* 优势：

  * 体积减少 60%~80%，提升渲染性能。

  * 支持属性化语法（如 < button bg="blue-400">）。

🚀 六、生产环境优化

* CSS 代码分割：

  * Vite 默认将动态导入组件的 CSS 拆分为独立文件，减少首屏负载：
  * import('./HeavyComponent.vue'); // 自动提取组件 CSS 为独立文件
  * 禁用方式：build: { cssCodeSplit: false }。
* 压缩 CSS：

  使用 build: { minify: 'esbuild' }（默认）或 terser 进一步压缩。

## ⚠️ 常见问题解决

1. 路径别名配置：\
   // vite.config.js
   export default defineConfig({
   resolve: { alias: { '@styles': '/src/styles' } }
   });

   使用：import '@styles/global.css'。
2. 第三方样式不生效：\
   在 css.modules.globalModulePaths 中配置排除路径（如 \[/global.css/]）。
3. Sass 全局变量未注入：\
   检查 preprocessorOptions.scss.additionalData 路径是否正确。

## 💎 总结：功能选择指南

|场景 |推荐方案 |优势|
|------------------|---------------|------------------|
|小型项目| 原生 CSS + 变量 |零配置、轻量快速|
|协作项目| CSS Modules + 预处理器 避|免命名冲突、支持编程语法|
|大型应用| 原子化框架（UnoCSS） + 动态导入 |极致性能、高复用性|
|生产部署| PostCSS 插件 + 代码分割/压缩 |优化加载速度、减少体积|

更多实践细节参考：https://vitejs.dev/guide/features.html#css 或 \[CSS 模块化配置详解]。

---

---
url: /learning/category/modules/page1.md
---
# Vite 相关

以下是与 Vite 相关的，涵盖原理、使用、优化等多个方面

## 💡 一、Vite 基础原理类

### 1. **Vite 和 Webpack 的核心区别是什么？**

**参考答案：**

* 构建原理不同：

  * **Vite**：基于原生 ES 模块（ESM），开发环境无需打包，使用浏览器动态加载模块。
  * **Webpack**：一开始就需要打包所有模块。
* 启动速度：

  * **Vite**：冷启动快，大文件项目优势明显。
  * **Webpack**：项目越大，启动越慢。
* 构建工具：

  * **Vite** 使用 `esbuild` 和 `rollup`，其中 `esbuild` 是用 Go 写的，构建速度快。
* HMR（热更新）：

  * Vite 的 HMR 更快、更轻量，因为是按模块更新。

***

### 2. **Vite 为什么启动速度快？**

**参考答案：**

* 开发时**不打包全部模块**，而是**按需编译和加载**。
* 利用浏览器的原生 ES 模块支持（native ESM）。
* 使用 `esbuild` 进行依赖预构建（极快的编译器）。
* 缓存机制使得依赖变化时无需重新构建全部模块。

***

### 3. **Vite 的构建流程是怎样的？**

**参考答案：**

1. **开发阶段（dev）**：

   * 解析 HTML 文件
   * 使用 `esbuild` 预构建依赖（如 vue、react 等）
   * 以中间服务器形式拦截请求，按需转换 `.ts/.vue` 等文件
   * 浏览器通过原生 ESModule 加载模块

2. **构建阶段（build）**：

   * 使用 `rollup` 进行打包构建
   * 支持代码分割、tree-shaking、压缩等优化

***

### 4. **Vite 为什么要使用 esbuild？**

**参考答案：**

* `esbuild` 是 Go 编写的构建工具，性能比 babel 快 10-100 倍。
* 用于**依赖预构建**和开发环境下的**语法转译**，大大提升启动速度。
* 构建阶段仍使用 `rollup`，兼顾速度和灵活性。

***

### 5. **Vite 支持哪些前端框架？**

**参考答案：**

* Vue（官方提供 `@vitejs/plugin-vue`）
* React（官方提供 `@vitejs/plugin-react`）
* Svelte、Solid、Lit 等现代框架
* 也支持 VanillaJS、TypeScript、PReact、以及 SSR

***

## ⚙️ 二、配置与插件类

### 6. **Vite 配置文件默认文件名是什么？是否支持多个环境配置？**

**参考答案：**

* 默认配置文件：`vite.config.ts` / `vite.config.js`
* 支持不同环境配置文件：

  * `.env`、`.env.development`、`.env.production`
  * 可通过 `import.meta.env` 访问环境变量

***

### 7. **如何在 Vite 中使用别名 alias？**

**参考答案：**

```ts
// vite.config.ts
import { defineConfig } from 'vite'
import path from 'path'

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  }
})
```

***

### 8. **如何在 Vite 中使用插件机制？**

**参考答案：**

* 插件机制类似于 Rollup 插件体系，使用 `plugins` 配置。

```ts
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()]
})
```

* 插件可以实现：

  * 文件解析（transform）
  * 热更新（handleHotUpdate）
  * 服务启动钩子（configureServer）等

***

### 9. **如何设置 Vite 的跨域代理？**

**参考答案：**

```ts
// vite.config.ts
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'https://backend.com',
        changeOrigin: true,
        rewrite: path => path.replace(/^\/api/, '')
      }
    }
  }
})
```

***

## 🚀 三、优化与进阶类

### 10. **Vite 中的依赖预构建（pre-bundling）机制是什么？**

**参考答案：**

* 默认使用 `esbuild` 对 `node_modules` 中的依赖进行预构建（提升冷启动性能）。
* 会生成 `.vite/deps` 缓存。
* 可通过 `optimizeDeps.include/exclude` 手动配置预构建的包。

***

### 11. **如何解决 Vite 构建产物过大或慢的问题？**

**参考答案：**

* 使用 `build.rollupOptions.output.manualChunks` 手动分包
* 利用 `dynamic import` 进行代码分割
* 压缩第三方库
* 优化图片、SVG、字体等静态资源
* 减少不必要的插件

***

### 12. **Vite 的 HMR 热更新原理简述？**

**参考答案：**

* 基于 WebSocket 与浏览器通信
* 当文件变化后，只更新变化的模块，不刷新整个页面
* 利用模块之间的依赖关系，实现模块热替换（类似 Vue 的 `hot.accept()`）

***

## 🔐 四、兼容性与部署类

### 13. **Vite 构建后能在 IE 上运行吗？**

**参考答案：**

* 默认不支持 IE（因为使用了原生 ES Module 和现代语法）
* 可使用插件如 `vite-plugin-legacy` 提供兼容性构建：

```ts
import legacy from '@vitejs/plugin-legacy'

export default defineConfig({
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11']
    })
  ]
})
```

***

### 14. **Vite 打包后的静态资源如何部署？**

**参考答案：**

* 执行 `vite build` 会生成 `dist/` 目录
* 将其部署到静态服务器（如 Nginx、Vercel、Netlify）
* 可配置 `base` 路径用于 CDN 或子目录部署：

```ts
export default defineConfig({
  base: '/my-app/' // 部署到 mydomain.com/my-app/
})
```

***

### 15. **如何在 Vite 项目中启用 SSR（服务端渲染）？**

**参考答案：**

* Vite 官方支持 SSR 模式（见 <https://vitejs.dev/guide/ssr.html）>
* 项目结构需拆分为 `server` 与 `client` 两端
* SSR 中可使用 `vite.createServer()` 动态注入模块，支持热更新与按需构建

***

以下是一套为**前端面试准备的 Vite 口述问答题模板**，每道题包含了：

* ✅【题目】
* 💬【答题结构提示】
* 🧠【模拟口述回答（简洁有逻辑）】

***

## 📘 一、基础原理类

***

### ✅【题目1】Vite 是什么？解决了哪些痛点？

💬结构提示：

* 定义
* 核心优势
* 解决的问题

🧠模拟口述回答：

> Vite 是一个由 Evan You 开发的前端构建工具，主打极速启动和开发体验。它通过利用浏览器原生的 ES Module 机制，在开发阶段不再需要打包，从而大大提升启动速度。同时，它使用 esbuild 预构建依赖，用 Rollup 进行生产构建，兼顾了开发效率和产物优化。
> Vite 主要解决了传统打包工具启动慢、热更新卡顿、配置繁琐等问题。

***

### ✅【题目2】Vite 和 Webpack 的区别有哪些？

💬结构提示：

* 启动原理
* 打包方式
* 热更新
* 插件生态

🧠模拟口述回答：

> Vite 开发时不打包，而 Webpack 需要先打包全部模块。Vite 利用浏览器原生 ESModule 按需加载，Webpack 用的是 CommonJS 或打包成 bundle。
> 热更新方面，Vite 精准更新受影响模块，而 Webpack 热更新粒度更粗。
> 插件上，Vite 用的是 Rollup 插件体系，相对轻量，而 Webpack 插件功能更强但复杂。
> 总体来说，Vite 更适合现代框架的开发场景，启动更快。

***

### ✅【题目3】为什么 Vite 冷启动快？

💬结构提示：

* 按需加载
* 预构建机制
* esbuild

🧠模拟口述回答：

> Vite 冷启动快，主要是因为开发阶段不打包项目源码，只在浏览器请求时按需加载和转换模块。同时，Vite 使用 esbuild 对依赖库进行预构建，比传统 JS 打包器快几十倍。
> 这就避免了一开始全量打包的过程，大大提升了开发体验。

***

## ⚙️ 二、配置使用类

***

### ✅【题目4】Vite 中如何配置环境变量？

💬结构提示：

* `.env` 文件
* `import.meta.env` 使用方式
* 命名规范

🧠模拟口述回答：

> Vite 支持多环境配置文件，例如 `.env.development`、`.env.production`。我们可以通过 `VITE_` 前缀来定义环境变量，比如 `VITE_API_URL`。
> 在代码中通过 `import.meta.env.VITE_API_URL` 来访问。这样就可以根据不同环境注入对应配置。

***

### ✅【题目5】如何在 Vite 项目中配置路径别名？

💬结构提示：

* `resolve.alias` 的用法
* 配合 TypeScript 时需要注意 tsconfig

🧠模拟口述回答：

> 在 `vite.config.ts` 中使用 `resolve.alias` 可以配置路径别名，例如 `@` 指向 `src` 目录。代码中就可以用 `@/components` 替代相对路径。
> 同时，如果使用 TypeScript，还需要在 `tsconfig.json` 中同步配置 `paths` 字段保持一致。

***

### ✅【题目6】Vite 如何配置代理解决跨域？

💬结构提示：

* `server.proxy` 用法
* rewrite 和 changeOrigin 含义

🧠模拟口述回答：

> Vite 提供了内置的开发服务器代理功能，通过 `server.proxy` 配置项可以设置代理规则。比如 `/api` 请求可以转发到后端服务器，同时通过 `rewrite` 去除前缀。
> 设置 `changeOrigin: true` 可以伪装请求头，解决跨域问题。

***

## 🚀 三、性能优化与构建类

***

### ✅【题目7】Vite 的依赖预构建机制是怎样的？

💬结构提示：

* esbuild 的作用
* 预构建触发的时机
* 缓存机制

🧠模拟口述回答：

> Vite 使用 esbuild 对 `node_modules` 中的依赖库进行一次性预构建，将其转为 ESM 格式并缓存到 `.vite/deps`。这一步在项目首次启动或依赖变化时发生。
> 这样可以加快浏览器加载速度，同时避免重复转译。

***

### ✅【题目8】Vite 如何进行构建优化？

💬结构提示：

* 分包策略（manualChunks）
* 资源压缩
* CDN 配置（base）
* 构建参数

🧠模拟口述回答：

> 构建阶段可以通过 `rollupOptions.output.manualChunks` 进行手动分包，减少主包体积。
> Vite 默认会压缩代码，也可以通过插件压缩图片等资源。
> 此外，还能设置 `base` 来适配部署在子路径或使用 CDN。通过合理配置这些项，可以大大提升加载速度。

***

## 🔐 四、兼容性与扩展类

***

### ✅【题目9】Vite 是否支持 IE 浏览器？怎么兼容？

💬结构提示：

* 默认不支持
* 插件方式兼容

🧠模拟口述回答：

> 默认情况下，Vite 不支持 IE，因为使用了原生 ES 模块和现代语法。
> 但可以使用 `@vitejs/plugin-legacy` 插件，为老浏览器生成 polyfill 和兼容代码，实现一定程度的兼容。

***

### ✅【题目10】Vite 插件机制是怎样的？和 Webpack 有什么不同？

💬结构提示：

* 插件生命周期
* 插件来源
* 区别

🧠模拟口述回答：

> Vite 的插件体系基于 Rollup 插件机制，也扩展了一些开发服务器相关钩子，比如 `configureServer`、`transformIndexHtml`。
> 插件可以处理文件转换、服务启动、热更新等功能。
> 相较于 Webpack，Vite 插件更加轻量、组合性更强，也更接近函数式。

***

## 🎯 五、附加题（加分项）

***

### ✅【题目11】如何使用 Vite 做 SSR 项目？

💬结构提示：

* Vite 提供 API
* 服务端渲染入口
* 动态模块加载

🧠模拟口述回答：

> Vite 提供 `createServer` API，可以集成到 Node 服务中，结合 Express 或 Koa 实现 SSR。
> 在开发时，Vite 会动态加载组件代码并提供热更新；在生产环境，则可以使用打包产物结合模板进行服务端渲染。Vue 和 React 都有对应的 SSR 方案。

***

## Vite 中的 import.meta 属性方法详解

`import.meta` 是 JavaScript 模块系统中的一个元属性，Vite 在此基础上扩展了一些特有的属性。以下是 Vite 中 `import.meta` 的主要属性和方法：

### 核心属性

1. **`import.meta.env`**
   * 包含环境变量
   * Vite 使用 `dotenv` 从项目根目录中的 `.env` 文件加载额外的环境变量
   * 默认包含：
     * `import.meta.env.MODE`: 应用运行的模式 (`development`/`production`)
     * `import.meta.env.BASE_URL`: 部署应用时的基本 URL
     * `import.meta.env.PROD`: 是否在生产环境运行
     * `import.meta.env.DEV`: 是否在开发环境运行
     * `import.meta.env.SSR`: 是否在服务器端渲染

2. **`import.meta.glob`**
   * 用于批量导入模块
   * 示例：
     ```js
     const modules = import.meta.glob('./dir/*.js')
     // 返回 { [path]: () => Promise<module> }
     ```
   * 变体：
     * `import.meta.globEager`: 同步立即导入（Vite 2.x）
     * `import.meta.glob('*', { eager: true })`: Vite 3+ 推荐写法

3. **`import.meta.hot`**
   * Vite 的 HMR (热模块替换) API
   * 主要方法：
     * `import.meta.hot.accept()`: 接受模块更新
     * `import.meta.hot.accept(cb)`: 带回调的接受
     * `import.meta.hot.dispose(cb)`: 清理副作用
     * `import.meta.hot.invalidate()`: 强制重新加载页面
     * `import.meta.hot.on(event, cb)`: 监听 HMR 事件

### 其他实用属性

4. **`import.meta.url`**
   * 当前模块的完整 URL (ES 模块标准属性)
   * 示例：`file:///path/to/your/module.js`

5. **`import.meta.resolve`** (实验性)
   * 解析模块路径
   * 示例：
     ```js
     const helperPath = await import.meta.resolve('some-module')
     ```

6. **`import.meta.main`** (Vite 特定)
   * 表示当前模块是否是应用入口模块

### 使用示例

```javascript
// 环境变量
if (import.meta.env.DEV) {
  console.log('开发模式')
}

// 动态导入
const modules = import.meta.glob('./components/*.vue')

// HMR
if (import.meta.hot) {
  import.meta.hot.accept('./dep.js', (newModule) => {
    console.log('模块更新:', newModule)
  })
}

// 解析路径
const path = await import.meta.resolve('lodash')
```

### 注意事项

1. 这些属性只在 Vite 的模块系统中可用，不是所有 JavaScript 环境都支持
2. 在生产构建时，Vite 会静态分析这些属性并进行适当的替换
3. 对于 TypeScript 用户，可以在 `vite/client.d.ts` 中找到这些属性的类型定义

Vite 通过这些 `import.meta` 扩展提供了强大的开发时功能，特别是对于模块热替换和动态导入的支持。

---

---
url: /note/vite/page.md
---
# Vite 笔记

## Vite 官网

[Vite 官网](https://cn.vite.dev/guide/)

---

---
url: /learning/vue/modules/page16.md
---
# Vue 2 迁移到 Vue3 指南

## 一、重大变化概述

1. **Composition API**：Vue3 引入了全新的 Composition API，作为 Options API 的补充
2. **性能提升**：更小的包体积、更好的渲染性能、更高效的组件初始化
3. **TypeScript 支持**：Vue3 使用 TypeScript 重写，提供更好的类型支持
4. **架构变化**：模块化架构，更好的 tree-shaking 支持

## 二、API 变化

### 1. 全局 API 变化

* `Vue.nextTick` → `import { nextTick } from 'vue'`
* `Vue.set` 和 `Vue.delete` 不再需要（响应式系统自动处理）
* `Vue.filter` 已移除，建议使用 methods 或 computed 属性替代
* `Vue.component` → `app.component`
* `Vue.directive` → `app.directive`
* `Vue.mixin` → `app.mixin`
* `Vue.use` → `app.use`

### 2. 实例 API 变化

* `$on`, `$off`, `$once` 移除，推荐使用第三方事件库
* `$children` 移除，推荐使用 `ref` 访问子组件
* `$listeners` 移除，合并到 `$attrs` 中
* `$scopedSlots` 移除，统一使用 `$slots`

## 三、模板语法变化

### 1. v-model 变化

* Vue2 的 `.sync` 修饰符被移除，统一使用 `v-model`
* 可以多个 `v-model` 绑定：`v-model:propName`
* 自定义修饰符处理方式变化

### 2. 事件 API

* `v-on.native` 修饰符移除
* `emits` 选项成为标准配置

### 3. 其他指令变化

* `v-for` 中的 `ref` 不再自动创建数组
* `v-if` 和 `v-for` 优先级变化：`v-if` 现在有更高的优先级
* `key` 在 `<template v-for>` 中的位置变化

## 四、组件相关变化

### 1. 异步组件

* 新的 `defineAsyncComponent` 方法
* 简化了异步组件定义方式

```javascript
import { defineAsyncComponent } from 'vue'

const AsyncComp = defineAsyncComponent(() =>
  import('./components/AsyncComponent.vue')
)
```

### 2. 函数式组件

* 函数式组件语法变化
* 需要通过函数而非对象定义
* 性能优势减少，建议谨慎使用

### 3. 组件生命周期

* `beforeDestroy` → `beforeUnmount`
* `destroyed` → `unmounted`
* 新增 `renderTracked` 和 `renderTriggered` 调试钩子

## 五、响应式系统变化

### 1. Reactivity API

* `Vue.observable` 移除 → 使用 `reactive`
* 新增 `ref`, `reactive`, `readonly` 等 API
* 需要显式导入响应式 API

```javascript
import { ref, reactive } from 'vue'
```

### 2. 响应式原理变化

* 使用 Proxy 替代 `Object.defineProperty`
* 可以检测数组索引变化和对象属性添加/删除
* 不再需要 `Vue.set`/`Vue.delete`

## 六、渲染函数变化

### 1. h 函数变化

* `h` 函数现在全局导入
* 参数格式变化：更一致的 props 结构

```javascript
import { h } from 'vue'

h('div', {
  id: 'app',
  onClick: () => {}
}, 'Hello')
```

### 2. 插槽处理

* 插槽统一为函数形式
* `this.$slots` 现在是函数，需要调用
* `this.$scopedSlots` 移除

## 七、TypeScript 支持

### 1. 更好的类型推断

* 组件选项和 Composition API 都有良好类型支持
* 自定义事件和 props 的类型检查

### 2. 定义组件

* 新的 `defineComponent` 方法提供类型推断

```typescript
import { defineComponent } from 'vue'

export default defineComponent({
  // 类型推断可用
})
```

## 八、迁移策略

1. **逐步迁移**：
   * 使用 `@vue/compat` 构建兼容版本
   * 逐步修复兼容性警告

2. **工具支持**：
   * 使用 Vue CLI 或 Vite 创建新项目
   * 使用迁移辅助工具识别问题

3. **代码重构**：
   * 逐步引入 Composition API
   * 重构过滤器为 computed/methods
   * 更新事件处理逻辑

4. **测试验证**：
   * 确保单元测试和 E2E 测试覆盖
   * 逐步验证组件功能

## 九、其他注意事项

1. **第三方库兼容性**：
   * 检查依赖库是否有 Vue3 版本
   * 常见库如 Vuex, Vue Router 需要升级到最新版

2. **构建工具**：
   * Vue CLI 需要升级到 v4.5.0+
   * 推荐使用 Vite 获得更好的开发体验

3. **浏览器支持**：
   * Vue3 不再支持 IE11 (除非使用特殊构建版本)
   * 确保目标浏览器兼容

4. **DevTools**：
   * 需要安装新的 Vue DevTools 扩展
   * 调试体验有所改进

## 十、资源推荐

1. 官方迁移指南：https://v3-migration.vuejs.org/
2. 迁移构建工具：https://github.com/vuejs/vue-next/tree/master/packages/vue-compat
3. 迁移检查清单：https://v3-migration.vuejs.org/migration-guide.html#overview

通过系统性地处理这些变化点，可以确保 Vue2 到 Vue3 的迁移过程顺利进行。

---

---
url: /learning/vue/modules/page6.md
---
# Vue 3 组件通信方式及其基本原理

#### 父子组件通信

* Props 和 Events
  * `Props`：父组件可以通过属性绑定的方式将数据传递给子组件。子组件使用 `defineProps` 来接收父组件传来的数据
  * `Events`：子组件可以通过触发自定义事件来通知父组件状态发生了变化，并且可以携带参数给父组件
* `v-model` 双向绑定
  * `v-model` 是一种简化的语法糖，用于实现父组件和子组件之间的双向数据绑定。它实际上是 `:modelValue` 和 `@update:modelValue` 的缩写形式

#### 跨层级组件通信

* Provide / Inject
  * Event Bus（mitt库）
    * 在 Vue 3 中，由于 $root 和 $event 已被移除，通常会使用第三方库如 `mitt` 创建一个轻量级的事件总线来实现兄弟组件间的通信
  * 共享父组件状态
    * 当两个或更多的兄弟组件需要共享状态时，可以通过共同的父组件作为中介进行状态管理

#### 高阶方案

* 插槽（Slots）
  * 插槽提供了一种内容分发的API，允许父组件向子组件传递模板片段
* attrs和attrs和listeners（在Vue 3中已合并为 $attrs）
  * `$attrs`包含了所有未被声明为 props 的属性，可以用来透传到子组件
* Ref + DefineExpose
  * 父组件可以通过 ref 直接访问子组件实例或DOM元素，并调用子组件的方法
* Vuex 或 Pinia
  * 对于更复杂的状态管理需求，推荐使用 Vuex 或者 Pinia 这样的状态管理库来集中管理和维护应用的状态

#### 总结

每种通信方式都有其适用场景，选择哪种方式取决于具体的业务需求和组件结构。例如，在父子组件之间，通常首选 Props 和 Events；对于跨层级通信，Provide / Inject 更加合适；而对于非父子关系的组件间通信，则可能需要用到 Event Bus 或者 Vuex / Pinia。

## Vue 组件通信方式

### 1. 父子组件通信

* **Props + Events**
  * 父 → 子：通过 `props` 传递数据
  * 子 → 父：通过 `$emit` 触发事件
  * 原则：遵循单向数据流

* **v-model**
  * 语法糖：`modelValue` prop + `update:modelValue` 事件
  * Vue 3 支持多个 v-model

* **Ref**
  * 父组件通过 `ref` 访问子组件实例方法/数据

### 2. 跨层级通信

* **Provide/Inject**
  * 祖先 → 后代：`provide` 提供数据，`inject` 注入
  * Vue 3 需手动保持响应式（提供 `ref`/`reactive`）

* **事件总线**
  * Vue 2: 新建 Vue 实例作为 EventBus
  * Vue 3: 推荐使用 [mitt](https://github.com/developit/mitt) 库

### 3. 全局状态管理

* **Pinia** (推荐)
  * Vue 3 官方推荐的状态管理库
  * 支持 TypeScript 和 Composition API

* **Vuex**
  * Vue 2 的标准方案
  * Vue 3 仍兼容但不再推荐

### 4. 特殊场景方案

* **共享父组件状态**
  * 通过 `$parent` 访问（不推荐，破坏封装性）
  * 更好的方案：提升状态到父组件 + props 传递

* **本地存储通信**
  * 通过 `localStorage` + `storage` 事件实现跨标签页通信

---

---
url: /Interview/vue/pages/page16.md
---
# Vue complier 的实现原理是什么样

在使用 vue 的时候，我们有两种方式来创建我们的 HTML 页面，第一种情况，也是大多情况下，我们会使用模板 template 的方式，因为这更易读易懂也是官方推荐的方法；第二种情况是使用 render 函数来生成 HTML，它比 template 更接近最终结果。

complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode

complier 主要分为 3 大块：

* parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast
* optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能
* generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数

---

---
url: /learning/vue/modules/page14.md
---
# Vue complier 的实现原理是什么样

在使用 vue 的时候，我们有两种方式来创建我们的 HTML 页面，第一种情况，也是大多情况下，我们会使用模板 template 的方式，因为这更易读易懂也是官方推荐的方法；第二种情况是使用 render 函数来生成 HTML，它比 template 更接近最终结果。

complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode

complier 主要分为 3 大块：

* parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast
* optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能
* generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数

---

---
url: /learning/vue/modules/page11.md
---
# Vue SSR 的实现原理

SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。

SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。

---

---
url: /Interview/vue/pages/page17.md
---
# Vue 与 React 的区别是什么？

React 和 Vue 有许多相似之处，它们都有：

* 使用 Virtual DOM
* 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。
* 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。

由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要承认 React 比 Vue 更好的地方，比如更丰富的生态系统。

---

---
url: /Interview/vue/pages/page22.md
---
# Vue 中的 Key 的作用是什么

key 的作用主要是为了高效的更新虚拟 DOM 。另外 vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。
其实不只是 vue，react 中在执行列表渲染时也会要求给每个组件添加上 key 这个属性。
要解释 key 的作用，不得不先介绍一下虚拟 DOM 的 Diff 算法了。
我们知道，vue 和 react 都实现了一套虚拟 DOM，使我们可以不直接操作 DOM 元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的 Diff 算法。
vue 和 react 的虚拟 DOM 的 Diff 算法大致相同，其核心有以下两点：

两个相同的组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构。
同一层级的一组节点，他们可以通过唯一的 id 进行区分。

基于以上这两点，使得虚拟 DOM 的 Diff 算法的复杂度从 O(n^3) 降到了 O(n) 。

---

---
url: /learning/vue/modules/page15.md
---
# Vue 中的 Key 的作用是什么

key 的作用主要是为了高效的更新虚拟 DOM 。另外 vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。
其实不只是 vue，react 中在执行列表渲染时也会要求给每个组件添加上 key 这个属性。
要解释 key 的作用，不得不先介绍一下虚拟 DOM 的 Diff 算法了。
我们知道，vue 和 react 都实现了一套虚拟 DOM，使我们可以不直接操作 DOM 元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的 Diff 算法。
vue 和 react 的虚拟 DOM 的 Diff 算法大致相同，其核心有以下两点：

两个相同的组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构。
同一层级的一组节点，他们可以通过唯一的 id 进行区分。

基于以上这两点，使得虚拟 DOM 的 Diff 算法的复杂度从 O(n^3) 降到了 O(n) 。

---

---
url: /Interview/vue/pages/page21.md
---
# vue 中的 spa 应用如何优化首屏加载速度

**优化首屏加载可以从这几个方面开始：**

* 请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
* 缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验
* gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。
* http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。
* 懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件
* 预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化
* 合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积
  使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化
* 提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程
* 封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化
* 图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验
  使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求
* 压缩图片：可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片

---

---
url: /Interview/vue/pages/page19.md
---
# vue 修饰符

**在 vue 中修饰符可以分为 3 类：**

* 事件修饰符
* 按键修饰符
* 表单修饰符

**事件修饰符**

> 在事件处理程序中调用 event.preventDefault 或 event.stopPropagation 方法是非常常见的需求。尽管可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。
> 为了解决这个问题，vue 为 v-on 提供了事件修饰符。通过由点 . 表示的指令后缀来调用修饰符。

常见的事件修饰符如下：

* .stop：阻止冒泡。
* .prevent：阻止默认事件。
* .capture：使用事件捕获模式。
* .self：只在当前元素本身触发。
* .once：只触发一次。
* .passive：默认行为将会立即触发。

**按键修饰符**

除了事件修饰符以外，在 vue 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。

* .left：左键
* .right：右键
* .middle：滚轮
* .enter：回车
* .tab：制表键
* .delete：捕获 “删除” 和 “退格” 键
* .esc：返回
* .space：空格
* .up：上
* .down：下
* .left：左
* .right：右
* .ctrl：ctrl 键
* .alt：alt 键
* .shift：shift 键
* .meta：meta 键

**表单修饰符**

> vue 同样也为表单控件也提供了修饰符，常见的有 .lazy、 .number 和 .trim。

* .lazy：在文本框失去焦点时才会渲染
* .number：将文本框中所输入的内容转换为number类型
* .trim：可以自动过滤输入首尾的空格

---

---
url: /learning/vue/modules/page4.md
---
# Vue 如何优化 SEO

在Vue.js项目中优化SEO（搜索引擎优化）主要涉及以下几个方面：

1. **服务端渲染 (SSR)**：默认情况下，Vue应用是客户端渲染的，这意味着在JavaScript执行之前，页面对于搜索引擎来说是空白的。通过使用服务端渲染，可以在服务器上预渲染Vue组件，并将HTML发送到客户端，这有助于搜索引擎更好地理解和索引你的网页内容。

   Vue官方提供了一个名为Vue Server Renderer的库来实现这一点。此外，Nuxt.js是一个基于Vue.js的更高层次的框架，它简化了服务端渲染的配置和使用，同时也提供了静态站点生成等功能。

2. **预渲染 (Prerendering)**：如果您的网站主要是静态内容，或者只有少量动态内容，那么可以考虑使用预渲染。预渲染与服务端渲染类似，但它只在构建时生成特定路由的静态HTML文件，而不是每次请求都进行服务端渲染。这种方法简单易行，适合那些不需要频繁更新的页面。

3. **Meta标签管理**：确保每个页面都有正确的meta标签，这对于SEO至关重要。你可以使用vue-meta等插件来动态管理标题、描述和其他meta信息，使其能够根据不同的路由或状态自动更新。

4. **合理利用Link组件**：在Vue Router中使用`<router-link>`组件代替普通的`<a>`标签可以帮助你更有效地管理内部链接，从而有利于SEO。

5. **提升页面加载速度**：快速加载的页面不仅改善用户体验，也对SEO有正面影响。可以通过代码分割、懒加载非关键资源等方式减少初始加载时间。

6. **创建Sitemap**：为你的Vue应用创建一个XML Sitemap，并提交给搜索引擎，以帮助它们更好地发现和索引你的网站内容。

7. **结构化数据标记**：使用JSON-LD格式添加结构化数据标记，可以帮助搜索引擎理解页面上的内容类型（如产品、文章等），从而可能在搜索结果中显示更丰富的摘要。

8. **避免重复内容**：确保你的URL设计不会导致相同内容出现在多个不同的URL上。如果存在这种情况，应该设置适当的301重定向或使用canonical标签指定首选版本。

结合以上策略，您可以有效地提高基于Vue的应用程序的SEO表现。不过，请记住SEO是一个持续的过程，需要不断地监控和调整策略以适应搜索引擎算法的变化。

## 如何优化 SEO

优化SEO（搜索引擎优化）涉及多个方面，旨在提高网站在搜索引擎结果页面（SERPs）中的可见度。以下是一些关键策略：

1. **关键词研究**：了解您的目标受众使用的搜索词，并确保这些关键词自然地出现在您的网站内容中。使用工具如Google Keyword Planner、Ahrefs或SEMrush来找到合适的关键词。

2. **高质量内容创建**：提供有价值、原创且与目标关键词相关的内容。优质内容不仅能吸引访问者，还能鼓励其他网站链接至您的页面，从而提升排名。

3. **技术优化**：
   * 确保网站加载速度快，移动端友好。
   * 使用SSL证书保证网站安全。
   * 创建并提交网站地图（Sitemap），以便搜索引擎更容易索引您的网站。
   * 使用结构化数据标记帮助搜索引擎理解页面内容。

4. **用户体验（UX）改进**：一个设计良好、易于导航的网站能减少跳出率，增加用户停留时间，这对SEO有利。

5. **外部链接建设**：获取来自权威网站的高质量反向链接。这可以通过内容营销、公关活动和合作伙伴关系实现。

6. **社交媒体整合**：虽然社交媒体信号不直接作为排名因素，但它们可以增加品牌曝光度，间接促进SEO。

7. **本地SEO**：如果您有实体店或服务特定地区，确保在Google My Business等平台注册并优化您的列表。

8. **视频和图片优化**：为所有图片添加alt属性，并考虑制作视频内容以吸引更多流量。

9. **定期更新内容**：保持博客文章和其他类型的内容新鲜度，有助于维持搜索引擎的关注。

10. **避免黑帽SEO技巧**：不要尝试欺骗搜索引擎，如隐藏文本、关键词堆砌等做法，这些可能导致惩罚甚至封禁。

针对基于JavaScript框架如Vue.js构建的单页应用(SPA)，还需要特别注意服务端渲染(SSR)或预渲染(Prerendering)的应用，以确保搜索引擎能够正确抓取和索引您的网页内容。通过结合以上策略，您可以有效地提升网站的SEO表现。

---

---
url: /learning/vue/page.md
---
# Vue 框架

* Vue 双向绑定原理 (响应式核心)

* Vue 生命周期详解 (组件生命周期)

* Vue 自定义指令 (指令系统扩展)

* Vue 如何优化 SEO (特定场景优化)

* Vue2 vs Vue3 (版本演进)

* Vue3 组件通信与原理 (组件交互)

* Vue 路由实现原理（hash vs history） (路由管理)

* Vue keep-alive 原理 (组件缓存)

* Vue computed 原理 (计算属性核心)

* vue3 watch vs watchEffect (Vue3响应式API细节)

* Vue SSR 的实现原理

* vue2.x 和 vuex3.x 渲染器的 diff 算法

* nextTick

---

---
url: /Interview/vue/pages/page15.md
---
# Vue 的 computed 的实现原理

当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。

它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖

但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。

收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty

value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined

dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true

Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中
当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。

如果 dirty 为 false，则直接返回 watcher 的 value
巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher

当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。

由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算

而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。

---

---
url: /learning/vue/modules/page9.md
---
# Vue 的 computed 的实现原理

Vue 的 `computed` 属性实现的核心在于依赖追踪和响应式系统。简要来说，其实现原理包括以下几个关键点：

* 1. **依赖收集**：当一个计算属性（computed property）被访问时，Vue 会自动追踪在这个过程中哪些响应式数据（reactive data）被访问了。这是通过 Vue 的响应式系统来完成的，该系统会在读取响应式数据时进行依赖收集。

* 2. **缓存机制**：计算属性的结果会被缓存起来，并且只有在其依赖的数据发生变化时才会重新计算。这意味着如果相关依赖未发生改变，多次访问同一个计算属性将会立即返回缓存的结果，而不会重复执行计算逻辑。

* 3. **响应更新**：一旦某个计算属性所依赖的数据发生了变化，Vue 就会知道需要重新计算这个计算属性的值，并更新相应的视图。这种更新是自动的，开发者不需要手动干预。

* 4. **惰性求值**：计算属性采用惰性求值策略，即仅在访问计算属性时才执行计算逻辑，而不是在定义时就立即执行。这样可以避免不必要的计算，提高性能。

综上所述，Vue 的 `computed` 利用了依赖追踪、缓存机制以及响应式更新等特性，使得它能够高效地管理复杂状态逻辑，同时简化了代码的编写和维护工作。

---

---
url: /learning/vue/modules/page1.md
---
# Vue 的双向数据绑定原理

`Vue` 使用 `Object.defineProperty` 或 `Proxy` 劫持数据，结合 `Watcher` 实现依赖收集。当数据变化时，通知视图更新；当视图中表单等发生变化时，也会同步更新数据，从而实现双向绑定。”

::: details {open}
Vue 的双向绑定本质是`数据劫持 + 发布订阅模式`。在 Vue 2 中通过 Object.defineProperty 递归转换 data 的每个属性为 getter/setter，在 getter 中收集依赖（Watcher），在 setter 中通知更新。视图层通过 v-model 指令实现双向绑定，它本质是 value 属性绑定和 input 事件监听的语法糖。

Vue 3 改用 Proxy 实现，优势在于能直接监听整个对象且自动处理新增属性。整个系统还包含异步批量更新和虚拟 DOM diff 等优化机制，既保持了开发便捷性又保证了性能。
:::

```js
// Vue2 实现
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      return val;
    },
    set(newVal) {
      if (val !== newVal) {
        val = newVal;
        console.log("数据更新了");
      }
    },
  });
}

const data = { name: "Vue" };
defineReactive(data, "name", data.name);
data.name = "Vue3"; // 控制台输出 "数据更新了"
```

---

---
url: /learning/vue/modules/page3.md
---
# Vue 的自定义指令

* `v-focus`：自动聚焦输入框；
* `v-permission`：权限控制；
* `v-lazy`：图片懒加载；
* `v-throttle`：防抖节流；
* `v-draggable`：拖拽行为。

```js
// 注册自定义指令 v-focus
app.directive("focus", {
  mounted(el) {
    el.focus();
  },
});
```

---

---
url: /learning/vue/modules/page7.md
---
# Vue 的路由实现，hash 路由和 history 路由实现原理

* **Hash 路由**：通过 URL 的 `#` 后面的字符变化实现路由，不触发页面刷新。
* **History 路由**：使用 HTML5 的 `pushState` 和 `replaceState` 方法，URL 更美观，但需要服务器配置支持。

---

---
url: /Interview/vue/pages/page14.md
---
# Vue 组件的 data 为什么必须是函数

一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。

---

---
url: /Interview/vue/page.md
---
# vue 高频面试题

---

---
url: /learning/vue/modules/page5.md
---
# Vue2 和 Vue3 的区别

Vue3 相对于 Vue2 做了较大的改进，主要体现在以下几个方面：

***

#### ✅ 1. **组合式 API vs 选项式 API**

* **Vue2** 使用 Options API（如 `data`、`methods`、`computed` 等）组织代码，逻辑分散，不易复用。
* **Vue3** 引入了 Composition API（如 `setup()`、`ref`、`reactive`、`watch` 等），更灵活，更适合逻辑复用和大型项目的维护。

***

#### ✅ 2. **性能优化**

* **更快的虚拟 DOM**：Vue3 重写了虚拟 DOM，实现更快的 diff 算法。
* **编译优化**：静态提升、事件缓存等机制使渲染更高效。
* **Tree-shaking 支持**：Vue3 使用 ES Module 编写，可以按需引入，减小打包体积。

***

#### ✅ 3. **响应式系统升级**

* **Vue2** 使用 `Object.defineProperty`，不支持对数组、新增属性的完全监测。
* **Vue3** 改用 `Proxy` 实现响应式，更彻底、性能更好，支持更复杂的数据结构。

***

#### ✅ 4. **Fragment / Teleport / Suspense 支持**

* **Fragment**：Vue3 组件可以返回多个根节点，Vue2 不支持。
* **Teleport**：可以将组件渲染到 DOM 的任意位置，适合弹窗等场景。
* **Suspense**：用于异步组件的加载状态处理，配合 `<script setup>` 更加简洁。

***

#### ✅ 5. **TypeScript 支持更好**

* Vue3 是用 TypeScript 重写的，原生支持类型推导和开发体验，Vue2 对 TypeScript 支持较弱。

***

#### ✅ 6. **生命周期钩子不同**

* Composition API 下生命周期名称为 `onMounted`、`onUnmounted` 等，更接近函数语义。
* 而 Vue2 是 `mounted`、`destroyed` 等选项式 API。
* vue3中 beforeDestroy->onBeforeUnmounted, destroyed->onUnmounted
* beforeCreate、created 被语法糖 setup 替代

---

---
url: /learning/vue/modules/page12.md
---
# vue2.x 和 vuex3.x 渲染器的 diff 算法

简单来说，diff算法有以下过程

* 同级比较，再比较子节点
* 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
* 比较都有子节点的情况(核心diff)
* 递归比较子节点

正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -> O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

Vue3.x借鉴了 ivi算法和 inferno算法
在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)

该算法中还运用了动态规划的思想求解最长递归子序列。

---

---
url: /Interview/vue/pages/page7.md
---
# vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下

简单来说，diff算法有以下过程

* 同级比较，再比较子节点
* 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
* 比较都有子节点的情况(核心diff)
* 递归比较子节点

正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -> O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

Vue3.x借鉴了 ivi算法和 inferno算法
在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)

该算法中还运用了动态规划的思想求解最长递归子序列。

---

---
url: /learning/vue/modules/page17.md
---
# Vue3 中插槽传参详解

在 Vue3 中，插槽的使用方式相比 Vue2 有了一些变化，特别是在作用域插槽（传参插槽）方面。以下是 Vue3 中插槽传参的全面指南：

## 一、基本插槽传参

### 1. 默认插槽传参

**子组件**:

```vue
<template>
  <div>
    <slot :user="user" :age="age"></slot>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const user = ref('张三')
const age = ref(25)
</script>
```

**父组件使用**:

```vue
<template>
  <ChildComponent>
    <template v-slot="slotProps">
      用户名：{{ slotProps.user }}，年龄：{{ slotProps.age }}
    </template>
  </ChildComponent>
</template>
```

### 2. 具名插槽传参

**子组件**:

```vue
<template>
  <div>
    <slot name="header" :title="title"></slot>
    <slot :content="content"></slot>
    <slot name="footer" :year="year"></slot>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const title = ref('页面标题')
const content = ref('主要内容')
const year = ref(2023)
</script>
```

**父组件使用**:

```vue
<template>
  <ChildComponent>
    <template #header="{ title }">
      <h1>{{ title }}</h1>
    </template>
    
    <template v-slot="{ content }">
      <p>{{ content }}</p>
    </template>
    
    <template #footer="{ year }">
      <footer>© {{ year }}</footer>
    </template>
  </ChildComponent>
</template>
```

## 二、语法糖写法

Vue3 推荐使用 `#` 简写代替 `v-slot:`

```vue
<template>
  <ChildComponent>
    <!-- 默认插槽 -->
    <template #default="{ content }">
      {{ content }}
    </template>
    
    <!-- 具名插槽 -->
    <template #header="{ title }">
      {{ title }}
    </template>
  </ChildComponent>
</template>
```

## 三、作用域插槽与 Composition API

在 `<script setup>` 中使用插槽传参：

**子组件**:

```vue
<template>
  <div>
    <slot :data="listData" :loading="isLoading"></slot>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const listData = ref([...])
const isLoading = ref(false)
</script>
```

**父组件使用**:

```vue
<template>
  <DataComponent>
    <template #default="{ data, loading }">
      <div v-if="loading">加载中...</div>
      <ul v-else>
        <li v-for="item in data" :key="item.id">{{ item.name }}</li>
      </ul>
    </template>
  </DataComponent>
</template>
```

## 四、动态插槽名传参

```vue
<template>
  <ChildComponent>
    <template #[dynamicSlotName]="{ message }">
      {{ message }}
    </template>
  </ChildComponent>
</template>

<script setup>
import { ref } from 'vue'

const dynamicSlotName = ref('header')
</script>
```

## 五、无渲染组件模式

利用插槽传参实现无渲染组件：

**子组件 (RenderlessComponent.vue)**:

```vue
<template>
  <slot :data="internalData" :update="updateData"></slot>
</template>

<script setup>
import { ref } from 'vue'

const internalData = ref(null)

const updateData = (newData) => {
  internalData.value = newData
}
</script>
```

**父组件使用**:

```vue
<template>
  <RenderlessComponent>
    <template #default="{ data, update }">
      <div>
        <pre>{{ data }}</pre>
        <button @click="update({ timestamp: Date.now() })">
          更新数据
        </button>
      </div>
    </template>
  </RenderlessComponent>
</template>
```

## 六、TypeScript 支持

为插槽 props 添加类型：

**子组件**:

```vue
<template>
  <slot :user="user" :actions="actions"></slot>
</template>

<script setup lang="ts">
interface User {
  name: string
  age: number
}

interface Action {
  type: string
  handler: () => void
}

const user: User = {
  name: '张三',
  age: 25
}

const actions: Action[] = [
  { type: 'edit', handler: () => console.log('编辑') }
]
</script>
```

**父组件使用**:

```vue
<template>
  <ChildComponent>
    <template #default="{ user, actions }">
      <!-- 这里 user 和 actions 会有类型推断 -->
    </template>
  </ChildComponent>
</template>
```

## 七、注意事项

1. **v-slot 只能在 `<template>` 或组件上使用**，不能用在普通 HTML 元素上
2. **默认插槽**需要使用 `#default` 或 `v-slot:default` 来接收作用域参数
3. **解构插槽 props** 时可以使用默认值：
   ```vue
   <template #header="{ title = '默认标题' }">
     {{ title }}
   </template>
   ```
4. Vue3 中移除了 `$scopedSlots`，统一使用 `$slots`

通过以上方式，你可以在 Vue3 中灵活地使用插槽传参功能，实现组件间的灵活通信和内容分发。

---

---
url: /note/vue3/modules/page1.md
---
# vue3 中的 hooks

Vue 3 引入了组合式 API（Composition API），它允许开发者在一个函数内组织和复用逻辑，这些函数通常被称为 hooks。Hooks 在 Vue 3 中并不是一个官方术语，但这个概念是从 React 社区借鉴过来的，用来描述利用 Composition API 实现的状态逻辑复用模式。

### 组合式 API 的基础

在 Vue 2.x 版本中，我们使用 Options API 来定义组件，比如 `data`、`methods`、`computed` 等选项。而在 Vue 3 中，通过引入 `setup` 函数，可以更加灵活地组织代码逻辑，尤其是当组件变得复杂时，这种方式显得尤为有用。

### 创建一个简单的 Hook

下面是一个简单的例子，演示如何创建和使用自定义 hook：

假设我们需要在多个组件中获取窗口大小，并监听其变化。我们可以创建一个名为 `useWindowSize` 的 hook：

```javascript
import { ref, onMounted, onUnmounted } from 'vue';

function useWindowSize() {
  const windowSize = ref({
    width: window.innerWidth,
    height: window.innerHeight
  });

  const handleResize = () => {
    windowSize.value = {
      width: window.innerWidth,
      height: window.innerHeight
    };
  };

  onMounted(() => window.addEventListener('resize', handleResize));
  onUnmounted(() => window.removeEventListener('resize', handleResize));

  return windowSize;
}
```

然后，在你的组件中使用这个 hook：

```javascript
<template>
  <div>
    <p>Width: {{ windowSize.width }}</p>
    <p>Height: {{ windowSize.height }}</p>
  </div>
</template>

<script>
import { defineComponent } from 'vue';
import useWindowSize from './hooks/useWindowSize'; // 假设 hook 文件位于 ./hooks/useWindowSize.js

export default defineComponent({
  setup() {
    const windowSize = useWindowSize();

    return { windowSize };
  }
});
</script>
```

### 总结

* **Composition API** 提供了一种新的方式来组织代码，特别是在处理复杂的场景时。
* **Hook** 是一种设计模式，用于抽取可复用的逻辑，使代码更加清晰和易于维护。
* 通过结合 `ref`、`reactive`、生命周期钩子（如 `onMounted`, `onUnmounted`）等 Composition API 的功能，你可以轻松创建自己的 hooks 来封装特定的行为或逻辑。

## Vue 3 中还有哪些内置的 hooks

在 Vue 3 中，Composition API 提供了一系列的内置 hooks（也称为生命周期钩子），这些钩子允许你在组件的不同阶段执行代码。以下是部分常用的内置 hooks：

* `onBeforeMount`: 在挂载开始之前调用（即，在渲染内容到 DOM 之前）。
* `onMounted`: 实例挂载完成后调用（通常用于执行需要访问 DOM 的操作）。
* `onBeforeUpdate`: 组件更新之前调用。此时可以获取更新前的状态。
* `onUpdated`: 组件因为响应式状态变更导致 DOM 更新后调用。
* `onBeforeUnmount`: 在实例销毁之前调用。此时实例仍然是完全正常的。
* `onUnmounted`: 在实例销毁后调用。调用此钩子时，组件的所有指令都被解绑，所有事件监听器被移除，所有子实例也都被销毁。
* `onErrorCaptured`: 当捕获一个来自后代组件的错误时被调用。
* `onRenderTracked` 和 `onRenderTriggered`: 分别用来调试追踪虚拟 DOM 重新渲染时和触发重新渲染的源头。

### 创建带参数的 Hook 和 如何创建一个带参数的 hook

创建一个接受参数的 hook 很简单，它实际上就是一个返回某些响应式引用或函数的普通函数，你可以根据需求向这个函数传递参数。下面是一个简单的例子，演示如何创建一个带有参数的自定义 hook。

假设我们需要一个 hook 来监听某个特定事件，并且能够指定事件类型和回调函数：

```javascript
import { ref, onMounted, onUnmounted } from 'vue';

function useEventListener(eventType, callback) {
  const listener = (event) => callback(event);

  onMounted(() => window.addEventListener(eventType, listener));
  onUnmounted(() => window.removeEventListener(eventType, listener));
}

export default useEventListener;
```

然后你可以在组件中这样使用它：

```javascript
import { defineComponent } from 'vue';
import useEventListener from './useEventListener'; // 假设 hook 文件位于 ./useEventListener.js

export default defineComponent({
  setup() {
    useEventListener('click', event => console.log(`Clicked at: ${event.clientX}, ${event.clientY}`));

    return {};
  }
});
```

在这个例子中，我们创建了一个名为 `useEventListener` 的 hook，它可以接收两个参数：`eventType` 表示要监听的事件类型，`callback` 是当该事件发生时要执行的回调函数。通过这种方式，我们可以轻松地在不同的组件中复用这段逻辑，并根据需要传入不同的参数。

---

---
url: /note/vue3/page.md
---
# Vue3 相关笔记

---

---
url: /Interview/vue/pages/page3.md
---
# vue3和vue2的区别

## 双向绑定

* `双向绑定的方法不一样`： Vue3 使用了new Proxy，Vue2 使用了Object.defineProperty

- `响应式系统提升`：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化

## 代码组织

* `Vue2` 是选项式 API，Vue3 向下兼容，可以是 选项式 也可以 是组合式，语法糖 setup

## 编译优化

* `编译优化`：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容

## 打包体积优化

* `打包体积优化`：移除了一些不常用的api（inline-template、filter）

## 生命周期的变化

* beforeDestroy -> beforeUnmount,destroyed -> unmounted
* beforeCreate 和 created 被 setup() 函数本身替代

## 其它

* `$set` 在Vue3中没有，因为 `new Proxy` 不需要

- `Vue2` v-for 优先级大于 v-if，Vue3 是 v-if 大于 v-for
- `源码组织方式变化`：使用 TS 重写
- `Vue3` 的 template 模板支持多个根标签
- Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore
- Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例
- Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props
- 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下

---

---
url: /Interview/vue/pages/page2.md
---
# vue响应式原理是什么？vue3的响应式有何不同

Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。

Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。

Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？

判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。

监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？

我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。

---

---
url: /learning/vue/modules/page2.md
---
# vue的生命周期

* `beforeCreate`:**这个钩子在实例初始化之后、数据观测 (data observer) 和 event/watcher 事件配置之前被调用**,不过，在 Composition API 中，通常使用 setup() 函数来处理这一阶段的逻辑，因此这个钩子不常用。
* `created`：**在实例创建完成后立即调用**。在这个阶段，实例已经完成了数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。但是，挂载阶段还没开始，$el 属性目前不可见
* `beforeMount`：**在挂载开始之前被调用**：相关的 render 函数首次被调用。此时，虚拟 DOM 尚未渲染到真实 DOM 上
* `mounted`：**在 el 被新创建的 vm.$el 替换，并挂载到实例上后调用**。这时，组件已经被渲染到 DOM 中，可以访问 DOM 元素了。
* `beforeUpdate`：*在数据更新时，在虚拟 DOM 打补丁之前调用*\*。此时，可以获取更新前的状态，适合用来进行一些清理工作。
* `updated`：**在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用**。此时，组件 DOM 已经更新，可以执行依赖于 DOM 的操作。然而，避免在此期间改变状态，因为这可能会导致无限的更新循环
* `beforeUnmount（在 Vue 2 中为 beforeDestroy）`：**发生在实例销毁之前，在当前阶段实例完全可以被使用**。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。
* `unmounted（在 Vue 2 中为 destroyed）`:**卸载组件实例后调用**。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。

**activated 和 deactivated 是 Vue 中专门用于 < keep-alive> 缓存组件时的生命周期钩子**

* `activated`：**当组件被 < keep-alive> 缓存后，每次该组件被激活（显示）时调用**。可以在这里执行组件重新展示时需要的逻辑，比如重新获取数据、恢复动画、计时器等
* `deactivated`：**当组件被缓存后，离开当前视图（被切换出去）时调用**。可以在这里进行一些资源释放操作，比如清除定时器、取消事件监听、停止动画等，防止内存泄漏。

---

---
url: /Interview/vue/pages/page1.md
---
# vue的生命周期有哪些及每个生命周期做了什么

* `beforeCreate`是`new Vue()`之后触发的第一个钩子，在当前阶段`data、methods、computed以及watch`上的数据和方法都不能被访问。

* `created`在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。

* `beforeMount`发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。

* `mounted`在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。

* `beforeUpdate`发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。

* `updated`发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。

* `beforeDestroy`发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。

* `destroyed`发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

---

---
url: /Interview/vue/pages/page9.md
---
# Vue的路由实现, hash路由和history路由实现原理说一下

`location.hash`的值实际就是URL中`#`后面的东西。

history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。

---

---
url: /Interview/vue/pages/page8.md
---
# vue组件通信方式有哪些及原理

## 父传后代

> 后代拿到了父的数据

* `props`：父传子很方便，父传孙很麻烦（父=>子=>孙），这种方式子不能修改父组件的数据
* `$parent`: 这种方式子能修改父组件的数据
* `provide`&`inject`：依赖注入，优势父组件可以直接向某个后代传值，不用一级一级的传递,官方不推荐使用，但是写组件库时很常用
* `$attrs` &`$listeners`：透传属性/事件
  * `$attrs`：接收父组件非 props 的属性
  * `$listeners`：接收父组件所有事件监听器。
  ```vue
    <!-- 中间组件 -->
    <Grandchild v-bind="$attrs" v-on="$listeners" />
  ```

## 后代传父

> 父拿到了后代的数据

* 子组件传给父组件用 `this.$emit`
* 父组件直接拿子组件数据 `this.$refs.子组件ref`

## 兄弟间传值

* `eventBus`，实际上就是 `new Vue()`

## 其他

**Vuex**

---

---
url: /learning/vue/modules/page10.md
---
# watch vs watchEffect

在Vue 3中，`watch`和`watchEffect`都是用于监听数据变化并执行相应的副作用（side effects），但它们之间存在一些关键差异。理解这些差异对于前端面试来说非常重要。

### watch

* **基本用法**：`watch`需要明确指定要监听的数据源。它可以监听一个或多个响应式数据的变化。
* **惰性执行**：仅当被监听的数据发生变化时，回调函数才会被执行。这意味着初始渲染时不会自动触发回调。
* **支持清除副作用**：如果监听器的逻辑创建了可以清理的副作用（如定时器、事件监听器等），可以通过返回一个清理函数来实现。
* **异步支持**：可以直接在回调函数中使用异步操作，而无需额外的封装。

示例：

```javascript
import { ref, watch } from 'vue';

const count = ref(0);

watch(count, (newVal, oldVal) => {
  console.log(`count changed from ${oldVal} to ${newVal}`);
});
```

### watchEffect

* **自动追踪依赖**：不需要手动指定监听的数据源，而是根据函数体内使用的响应式数据自动追踪依赖。一旦这些依赖发生改变，回调就会重新执行。
* **立即执行**：与`watch`不同的是，`watchEffect`会在初次运行时立即执行一次，以捕获当前状态，并且之后每当依赖项更新时都会再次执行。
* **副作用清理**：类似于`watch`，如果在`watchEffect`内部创建了副作用，也可以通过返回一个函数来定义如何清理这些副作用。
* **同步执行**：默认情况下，`watchEffect`是同步执行的，但如果需要处理异步逻辑，则需要自行管理异步代码。

示例：

```javascript
import { ref, watchEffect } from 'vue';

const count = ref(0);

watchEffect(() => {
  console.log(`current count is: ${count.value}`);
});
```

### 主要区别

* **初始化执行**：`watch`不会在首次创建时立即执行回调，而`watchEffect`会。
* **依赖声明**：`watch`需要明确指出要监听的数据，而`watchEffect`会自动收集依赖。
* **使用场景**：如果你需要更细粒度地控制何时以及为何种数据变化触发回调，`watch`可能是更好的选择。而当你想要自动追踪任何在回调中使用的响应式数据的变化时，`watchEffect`则更加方便。

了解这两种监听机制的特点和适用场景，可以帮助你在实际开发中做出更好的决策，同时也能在面试中展示出对Vue 3深入的理解。

---

---
url: /Interview/vue/pages/page18.md
---
# watch 与 computed 的区别是什么以及他们的使用场景分别是什么

**区别：**

* 都是观察数据变化的（相同）
* 计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化；
* computed 有缓存，它依赖的值变了才会重新计算，watch 没有；
* watch 支持异步，computed 不支持；
* watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）
* watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；
* computed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）

**watch 的 参数：**

* deep：深度监听
* immediate ：组件加载立即触发回调函数执行

**computed 缓存原理：**

conputed本质是一个惰性的观察者；当计算数据存在于 data 或者 props里时会被警告；

vue 初次运行会对 computed 属性做初始化处理（initComputed），初始化的时候会对每一个 computed 属性用 watcher 包装起来 ，这里面会生成一个 dirty 属性值为 true；然后执行 defineComputed 函数来计算，计算之后会将 dirty 值变为 false，这里会根据 dirty 值来判断是否需要重新计算；如果属性依赖的数据发生变化，computed 的 watcher 会把 dirty 变为 true，这样就会重新计算 computed 属性的值。

---

---
url: /learning/engineering/modules/page3.md
---
# Webpack 和 Vite

## 🧩 一、基本介绍

### **Webpack**

* 类型：模块打包器（module bundler）
* 发布时间：2012 年
* 特点：
  * 支持代码分割、懒加载、热更新等高级功能。
  * 插件系统非常丰富，生态庞大。
  * 主要用于**传统构建流程**（如 React、Vue、Angular 等项目）。

### **Vite**

* 类型：新型前端构建工具
* 发布时间：2020 年（由 Vue.js 作者尤雨溪创建）
* 特点：
  * 基于原生 ES 模块（ESM），开发服务器启动快。
  * 支持 TypeScript、JSX、CSS 预处理器等无需配置即可开箱即用。
  * 构建速度极快，尤其适用于**现代浏览器和现代 JavaScript 开发**。

***

## ⚙️ 二、核心区别

| 特性 | Webpack | Vite |
|------|---------|------|
| 启动速度 | 较慢（需要打包所有文件） | 极快（利用浏览器原生 ESM，按需加载） |
| 生产构建 | 使用 webpack 打包输出优化后的 bundle | 使用 Rollup 进行生产环境打包 |
| 开发模式 | 编译后提供本地服务 | 利用浏览器原生支持 ES Modules |
| 配置复杂度 | 复杂，依赖大量插件 | 简洁，大部分默认配置已满足需求 |
| 热更新（HMR） | 支持，但较慢 | 支持，响应速度快 |
| 插件系统 | 基于 webpack 插件生态（庞大） | 基于 Rollup 插件系统（逐渐成熟） |
| 支持框架 | React、Vue、Angular 等主流框架 | Vue 3、React、Svelte 等现代框架 |
| CSS 预处理 | 需手动配置 loader（如 sass-loader） | 内置支持 `.scss`, `.less`, `.styl` 等 |
| TypeScript | 需要 `ts-loader` 或 `babel-loader` | 默认支持 `.ts` 文件 |
| JSX / Vue SFC | 需配置 Babel / vue-loader | 默认支持 |

***

## 📈 三、使用场景对比

### ✅ Webpack 更适合：

* 老旧项目或需要兼容 IE11 的项目。
* 需要高度定制化打包策略的大型应用。
* 需要兼容不支持 ES Module 的浏览器环境。
* 使用 Angular 的项目（目前 Angular CLI 仍基于 Webpack）。

### ✅ Vite 更适合：

* 现代浏览器环境下的新项目（ES6+）。
* 快速原型开发、小型到中型项目。
* 使用 Vue 3、React、Svelte 等现代框架。
* 需要极速的开发体验（尤其是 HMR）。

***

## 🔧 四、典型命令对比

### Webpack

```bash
# 安装
npm install --save-dev webpack webpack-cli

# 启动开发服务器
npx webpack serve

# 构建生产版本
npx webpack --mode production
```

### Vite

```bash
# 创建项目
npm create vite@latest my-app

# 启动开发服务器
npm run dev

# 构建生产版本
npm run build
```

***

## 🌱 五、生态系统与社区支持

| 方面 | Webpack | Vite |
|------|---------|------|
| 社区活跃度 | 非常高（长期维护） | 快速增长（Vue、React 社区支持强） |
| 插件数量 | 极其丰富 | 正在快速增长 |
| 文档质量 | 成熟且完整 | 清晰简洁，文档友好 |
| 兼容性 | 支持老旧浏览器 | 推荐用于现代浏览器 |

***

## 📊 六、性能对比示例

| 操作 | Webpack | Vite |
|------|---------|------|
| 初始启动时间 | 5~20 秒 | < 1 秒 |
| 修改文件后热更新 | 1~3 秒 | ~0.1 秒 |
| 生产构建时间 | 10~30 秒 | 5~10 秒（Rollup） |

***

## ✅ 七、总结建议

| 场景 | 推荐工具 |
|------|----------|
| 新项目、现代框架、追求开发效率 | ✅ Vite |
| 老项目、需要兼容 IE、高度定制化 | ✅ Webpack |
| 快速原型开发 | ✅ Vite |
| Angular 项目 | ✅ Webpack（目前主流） |
| 大型企业级应用 | 可以结合使用（Vite + 微前端架构） |

***

如果你正在开始一个新项目，并且不需要兼容老旧浏览器，**Vite 是首选**；而如果你在维护一个老项目，或者需要复杂的打包逻辑，**Webpack 仍然是可靠的选择**。

---

---
url: /learning/engineering/modules/page1.md
---
# Webpack 的构建流程

Webpack 是一个模块打包工具，它的核心功能是将项目中的各种资源（如 JavaScript、CSS、图片等）视为模块，并通过一系列流程将它们打包成优化后的静态资源。Webpack 的构建流程可以分为以下几个主要阶段：

### 一、初始化（Initialization）

1. **解析配置文件**：
   * Webpack 启动时会读取 `webpack.config.js` 或其他指定的配置文件。
   * 配置包括入口（entry）、输出（output）、加载器（loader）、插件（plugin）等。

2. **创建 Compiler 对象**：
   * Webpack 根据配置创建一个 `Compiler` 实例。
   * 这个对象控制整个构建流程，管理所有插件和选项。

***

### 二、编译（Compilation）

3. **执行 `run` 方法**：
   * 开始构建过程，触发 `beforeRun` 和 `run` 生命周期钩子。

4. **确定 Entry 入口文件**：
   * Webpack 从 entry 指定的文件开始分析依赖关系。

5. **创建 Compilation 对象**：
   * `Compilation` 负责实际的模块构建和打包工作。
   * 它记录了本次构建的所有模块、资源、变化和错误信息。

6. **调用 Loader 解析模块**：
   * Webpack 会根据配置中 `rules` 匹配的规则，使用对应的 loader 对模块进行转换。
   * 例如：使用 `babel-loader` 将 ES6+ 转换为 ES5；使用 `css-loader` 处理 CSS 文件。

7. **递归构建依赖图谱（Dependency Graph）**：
   * Webpack 从入口文件出发，递归地分析每一个模块的依赖关系。
   * 构建出一个完整的依赖图谱（Dependency Graph），包含所有需要打包的模块。

8. **处理异步模块（Code Splitting）**：
   * 如果使用了动态导入（`import()`）或路由懒加载，Webpack 会创建额外的 chunk。

***

### 三、优化（Optimization）

9. **执行优化策略**：
   * 合并重复模块（ModuleConcatenationPlugin）。
   * 去除无用代码（Tree Shaking）。
   * 分割代码（SplitChunksPlugin）。
   * 哈希命名（HashedModuleIdsPlugin）。
   * 插件可以在这一阶段介入，对 chunk 进行修改。

***

### 四、生成资源（Emit Assets）

10. **生成最终的 bundle 文件**：
    * Webpack 将模块内容按照 chunk 组织成最终的文件结构。
    * 使用模板（mainTemplate、chunkTemplate 等）生成可执行的 JS 文件。

11. **调用插件写入资源**：
    * 所有资源（JS、CSS、图片等）准备好后，通过 `emit` 钩子通知插件进行最后的处理。
    * 例如：`HtmlWebpackPlugin` 会生成 HTML 文件并自动引入打包好的 JS/CSS。

***

### 五、输出（Output）

12. **写入磁盘或内存（开发服务器）**：
    * 如果是生产环境，Webpack 会将资源写入到磁盘上的 `output.path` 目录。
    * 如果是开发环境（使用 `webpack-dev-server`），则资源保存在内存中，不写入磁盘。

13. **完成构建**：
    * 触发 `done` 钩子，表示一次完整的构建流程结束。

***

## 总结图示

```
初始化
  ↓
创建 Compiler
  ↓
读取配置 & 创建 Compilation
  ↓
从 Entry 开始解析模块、调用 Loader
  ↓
递归构建依赖图谱
  ↓
优化模块（Tree Shaking、SplitChunks）
  ↓
生成 Chunk & 最终 Bundle
  ↓
插件处理输出资源（HtmlWebpackPlugin 等）
  ↓
输出到磁盘 / 内存
  ↓
完成构建（done）
```

***

## 常见插件与生命周期钩子说明

| 阶段 | 插件作用 | 示例 |
|------|----------|------|
| 初始化 | 注册事件监听器 | `BannerPlugin` |
| 编译 | 分析模块、调用 loader | `BabelLoader` |
| 优化 | 拆分代码、去重、压缩 | `SplitChunksPlugin`, `TerserPlugin` |
| 输出 | 生成 HTML、清理目录 | `HtmlWebpackPlugin`, `CleanWebpackPlugin` |

---

---
url: /learning/category/modules/page2.md
---
# Webpack 相关

## 🧠 一、基础原理类

### 1. 什么是 Webpack？解决了什么问题？

**答：**
Webpack 是一个现代 JavaScript 应用的静态模块打包工具。它会从入口文件出发，递归解析项目所依赖的模块，然后打包成一个或多个 bundle 文件。
解决了前端模块化、依赖管理、资源整合和代码优化的问题。

***

### 2. Webpack 的核心概念有哪些？

**答：**

* **Entry（入口）**：打包的起点
* **Output（输出）**：打包结果输出位置
* **Loader**：用于处理非 JS 文件（如 CSS、图片、TS 等）
* **Plugins**：用于扩展 Webpack 的功能（如压缩、热更新）
* **Mode**：开发环境（development）和生产环境（production）
* **Module**：指项目中一切资源，JS、CSS、图片都是模块

***

### 3. Webpack 的构建流程？

**答：**

1. 初始化参数（合并配置）
2. 解析入口文件（entry）
3. 构建模块依赖图（递归）
4. 调用 Loader 转换模块
5. 调用 Plugin 执行扩展逻辑
6. 输出文件（bundle）

***

## 🔧 二、配置相关

### 4. 如何配置多个入口文件？

**答：**

```js
entry: {
  index: './src/index.js',
  admin: './src/admin.js',
}
```

***

### 5. Loader 和 Plugin 的区别？

**答：**

* **Loader**：用于模块转换（作用于某一类文件，如 Babel 处理 JS）
* **Plugin**：用于扩展 Webpack 的能力（如 HtmlWebpackPlugin、DefinePlugin）

***

### 6. 如何处理图片资源？

**答：**
使用 `asset/resource`、`asset/inline` 或使用 `file-loader`（Webpack 4）：

```js
{
  test: /\.(png|jpe?g|gif)$/,
  type: 'asset/resource'
}
```

***

### 7. 如何优化打包体积？

**答：**

* 使用 `mode: 'production'` 启用默认优化
* 压缩 JS（`TerserPlugin`）、CSS（`css-minimizer-webpack-plugin`）
* Tree Shaking（去除未使用代码）
* SplitChunks 拆分公共模块
* 动态导入（懒加载）
* 使用 CDN 加载第三方库

***

### 8. 如何实现代码分割（Code Splitting）？

**答：**

* 手动分割：使用 `import()` 动态引入模块
* 自动分割：配置 `optimization.splitChunks`
* 使用 `entry` 多入口实现分割

***

## ⚙️ 三、优化 & 高级用法

### 9. 什么是 Tree Shaking？

**答：**
Tree Shaking 是去除 JavaScript 中未使用代码的技术，依赖 ES Module 静态语法分析。Webpack 在 production 模式下默认启用。

***

### 10. 如何开启缓存机制提高打包速度？

**答：**

* 使用 `cache: { type: 'filesystem' }`
* 使用 `babel-loader` 时开启 `cacheDirectory: true`
* 使用 `HardSourceWebpackPlugin`（Webpack 4）

***

### 11. 如何实现热更新（HMR）？

**答：**

* 配置 `devServer: { hot: true }`
* 启用 `HotModuleReplacementPlugin`
* 使用 `module.hot.accept()` 在模块中手动处理更新逻辑（仅限模块级）

***

### 12. 如何配置生产环境与开发环境的不同构建？

**答：**
通过 `webpack-merge` 拆分配置文件：

```bash
webpack.common.js
webpack.dev.js
webpack.prod.js
```

然后使用 `webpack --config webpack.dev.js` 启动。

***

## 🌐 四、常见插件

| 插件名                  | 作用                              |
| -------------------- | ------------------------------- |
| HtmlWebpackPlugin    | 自动生成 HTML 文件并引入打包资源             |
| DefinePlugin         | 定义全局变量（如：process.env.NODE\_ENV） |
| MiniCssExtractPlugin | 抽离 CSS 成单独文件                    |
| CleanWebpackPlugin   | 打包前清空 `dist`                    |
| CopyWebpackPlugin    | 拷贝静态文件                          |

***

## ❓五、常见问题

### 13. Webpack 和 Vite 的区别？

**答：**

* Webpack 是基于 **打包构建**，Vite 是基于 **原生 ES Module 的按需加载**
* Webpack 构建慢，启动慢；Vite 利用 `esbuild` 启动快
* Vite 更适合现代前端项目，Webpack 更适合高度定制化项目

***

### 14. Webpack 的性能优化手段有哪些？

**答：**

* 缓存（模块缓存、Loader 缓存）
* 多线程构建（如 `thread-loader`, `parallel-webpack`）
* DLLPlugin 提前打包第三方库
* 减少模块体积（Tree Shaking、按需引入）
* 避免过度嵌套依赖

好的，以下是为 **Webpack 面试题口述练习** 专门设计的一套【题目卡片】，每张卡片包含：
👉 **题目**
👉 **答题提示（关键词）**
👉 **示例回答（适合口头表达）**

## 🧩 Webpack

***

### 🧠 卡片 1

**Q：什么是 Webpack？它解决了什么问题？**
🔑提示词：模块打包、入口、依赖、构建
🎙️**示例回答：**
Webpack 是一个现代前端项目的静态模块打包工具。它从入口文件出发，分析模块之间的依赖关系，然后打包成一个或多个 bundle 文件。它帮助我们管理各种资源（比如 JS、CSS、图片等），统一构建流程，解决了模块化、依赖管理和性能优化的问题。

***

### 🧠 卡片 2

**Q：Webpack 的核心概念有哪些？**
🔑提示词：entry、output、loader、plugin、module、mode
🎙️**示例回答：**
Webpack 有几个核心概念，包括：

* **Entry**：入口文件，Webpack 从这开始打包；
* **Output**：输出配置，决定打包生成的文件；
* **Loader**：用于处理非 JS 的资源，比如用 babel-loader 处理 ES6；
* **Plugin**：扩展 Webpack 能力，比如生成 HTML 文件；
* **Module**：一切资源都是模块；
* **Mode**：开发环境和生产环境的不同优化策略。

***

### 🧠 卡片 3

**Q：Loader 和 Plugin 有什么区别？**
🔑提示词：文件转换、功能扩展、处理阶段
🎙️**示例回答：**
Loader 是用来处理模块的，比如把 Sass 转换成 CSS、把 JSX 转成 JS。而 Plugin 是在 Webpack 的生命周期中扩展功能的，比如生成 HTML 文件、清理目录或者定义环境变量。Loader 关注的是某一类文件的转换，Plugin 更像是执行一些打包的“钩子”逻辑。

***

### 🧠 卡片 4

**Q：Webpack 的打包流程是怎样的？**
🔑提示词：入口、依赖图、Loader、Plugin、输出
🎙️**示例回答：**
Webpack 的打包流程大致是：

1. 从 entry 开始解析模块；
2. 构建依赖图（Module Graph）；
3. 对模块使用对应的 Loader 处理；
4. 在合适的阶段触发 Plugin 的钩子逻辑；
5. 最终输出打包好的 bundle 文件。

***

### 🧠 卡片 5

**Q：如何实现代码分割（Code Splitting）？**
🔑提示词：动态 import、SplitChunksPlugin、按需加载
🎙️**示例回答：**
可以通过三种方式实现代码分割：

1. 使用 `import()` 实现懒加载；
2. 使用 Webpack 的 `SplitChunksPlugin` 自动拆分公共模块；
3. 设置多个 `entry`，手动拆分。
   这样可以提升首屏速度、减少不必要的资源加载。

***

### 🧠 卡片 6

**Q：什么是 Tree Shaking？它的前提条件是什么？**
🔑提示词：去除未使用、ESM、静态分析
🎙️**示例回答：**
Tree Shaking 是指移除代码中没有用到的部分，减少 bundle 体积。它依赖于 ES Module 的静态结构，Webpack 会在构建时分析哪些导入没有被使用，然后剔除它们。前提是使用 ESM 语法，不能使用 CommonJS。

***

### 🧠 卡片 7

**Q：如何优化 Webpack 构建速度？**
🔑提示词：缓存、thread-loader、多入口、exclude
🎙️**示例回答：**
可以从多个维度优化构建速度：

* 启用 Loader 缓存，比如 babel-loader 开启 `cacheDirectory`；
* 使用多线程 loader，如 `thread-loader`；
* 合理配置 `include/exclude`，避免无用文件参与编译；
* 使用文件系统缓存 `cache: { type: 'filesystem' }`；
* 依赖预编译，比如使用 DLLPlugin（Webpack 4）。

***

### 🧠 卡片 8

**Q：Webpack 的开发模式和生产模式有何区别？**
🔑提示词：devtool、压缩、Tree Shaking、优化
🎙️**示例回答：**
开发模式（development）下会保留完整的 SourceMap、未压缩的代码，利于调试；
而生产模式（production）下会默认开启压缩、Tree Shaking、Scope Hoisting 等优化，用于减少体积和提升性能。

***

### 🧠 卡片 9

**Q：如何处理静态资源（如图片、字体）？**
🔑提示词：asset modules、file-loader、url-loader
🎙️**示例回答：**
Webpack 5 引入了 `asset/resource`、`asset/inline`、`asset` 等类型来统一处理静态资源。
例如使用：

```js
{
  test: /\.(png|jpg|gif|svg)$/,
  type: 'asset/resource'
}
```

Webpack 4 可以使用 `file-loader` 和 `url-loader` 来处理这些资源。

***

### 🧠 卡片 10

**Q：你如何在项目中区分开发和生产环境配置？**
🔑提示词：webpack-merge、process.env、mode
🎙️**示例回答：**
通常会将配置拆分为三份：

* `webpack.common.js`：公共配置；
* `webpack.dev.js`：开发环境；
* `webpack.prod.js`：生产环境。
  然后通过 `webpack-merge` 合并，并在 package.json 中配置不同的构建命令。还可以通过 `DefinePlugin` 注入 `process.env.NODE_ENV` 实现环境判断。

---

---
url: /learning/browserNetwork/modules/page7.md
---
# WebSocket

> WebSocket 是一种网络通信协议，它在客户端和服务器之间提供**全双工通信通道**。这意味着一旦建立连接，双方都可以随时发送数据，而不需要像传统的 HTTP 请求那样每次都要重新发起请求。WebSocket 通常用于需要实时交互的应用场景，例如在线聊天、实时游戏、股票交易、协同编辑等。

## 一、WebSocket 的基本概念

#### 1. 协议简介

* WebSocket 是 HTML5 开始支持的一种协议。
* 它使用 `ws://`（不加密）或 `wss://`（加密）作为协议前缀。
* WebSocket 建立在 TCP 协议之上，握手阶段使用 HTTP 协议升级到 WebSocket 协议。

#### 2. 握手过程（HTTP Upgrade）

WebSocket 连接的建立始于一次普通的 HTTP 请求，客户端发送一个带有 `Upgrade: websocket` 头的请求：

```http
GET /chat HTTP/1.1
Host: example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

服务器响应如下：

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

之后，连接就从 HTTP 切换为 WebSocket 协议。

***

## 二、WebSocket 的特点

| 特性 | 描述 |
|------|------|
| **双向通信** | 客户端和服务器都可以主动发送消息，无需轮询 |
| **低延迟** | 数据可以即时传输，适合实时应用 |
| **轻量级协议头** | 比 HTTP 更高效，减少传输开销 |
| **兼容性好** | 支持主流浏览器（现代浏览器都支持） |
| **跨域支持** | 可以跨域通信（需服务器设置 CORS） |

***

## 三、WebSocket 的应用场景

1. **在线聊天室**
2. **实时通知系统**（如邮件、消息提醒）
3. **多人在线游戏**
4. **股票行情推送**
5. **协同办公工具**（如 Google Docs 实时协作）
6. **远程控制与监控系统**

***

## 四、WebSocket 的 API（前端）

JavaScript 提供了 `WebSocket` 对象来使用该协议：

```javascript
const socket = new WebSocket('ws://example.com/socket');

// 连接建立成功
socket.addEventListener('open', function (event) {
    socket.send('Hello Server!');
});

// 接收到消息
socket.addEventListener('message', function (event) {
    console.log('Message from server ', event.data);
});

// 错误处理
socket.addEventListener('error', function (event) {
    console.log('WebSocket Error:', event);
});

// 连接关闭
socket.addEventListener('close', function (event) {
    console.log('WebSocket closed');
});
```

***

## 五、WebSocket 服务端实现（Node.js 示例）

使用 `ws` 库实现简单的 WebSocket 服务器：

```bash
npm install ws
```

```javascript
const WebSocket = require('ws');

const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function connection(ws) {
  console.log('Client connected');

  ws.on('message', function incoming(message) {
    console.log('Received:', message);
    ws.send(`Echo: ${message}`);
  });

  ws.send('Welcome to the WebSocket server!');
});
```

***

## 六、与 HTTP 长轮询的区别

| 特性 | HTTP 长轮询 | WebSocket |
|------|--------------|-----------|
| 连接方式 | 短连接，频繁请求 | 持久化连接 |
| 实时性 | 差（延迟高） | 强（毫秒级响应） |
| 资源消耗 | 高（频繁建立连接） | 低（单个连接复用） |
| 实现复杂度 | 相对简单 | 稍复杂，需维护连接状态 |

***

## 七、注意事项

* **防火墙/NAT**：某些公司或家庭网络可能限制 WebSocket 流量。
* **重连机制**：WebSocket 断开后应有自动重连机制。
* **安全**：使用 `wss://` 加密连接，防止中间人攻击。
* **负载均衡**：WebSocket 是长连接，负载均衡器需支持粘性会话或反向代理配置。

***

## 八、相关技术对比

| 技术 | 适用场景 | 说明 |
|------|----------|------|
| WebSocket | 实时性强 | 全双工通信，推荐首选 |
| SSE（Server-Sent Events） | 服务器推客户端 | 单向通信，适合只读更新 |
| HTTP/2 Server Push | 页面资源预加载 | 不适用于动态数据推送 |
| MQTT | IoT 设备通信 | 轻量级消息协议，适合物联网 |

## 九、WebSocket 的心跳机制

---

---
url: /learning/core/modules/page5.md
---
# 事件轮询 (Event Loop)

## 一、什么是事件轮询（Event Loop）？

事件轮询是 JavaScript 引擎处理异步操作的一种机制。它使得 JavaScript 在单线程的限制下依然可以处理并发任务，比如定时器、网络请求、用户交互等。

JavaScript 最初设计为单线程语言，主要是为了避免多线程带来的复杂性（如死锁）。但这也意味着同一时间只能执行一个任务。为了在不阻塞主线程的前提下处理异步任务，JavaScript 引入了 **事件轮询机制**。

## 二、事件轮询的核心组成部分

事件轮询依赖于几个关键的概念：

### 1. 调用栈（Call Stack）

* 是 JavaScript 执行代码的地方。
* 函数被调用时会被压入调用栈，执行完毕后弹出。

### 2. 消息队列（Callback Queue / Task Queue）

* 存放等待执行的回调函数。
* 比如：`setTimeout`、`setInterval`、`DOM 事件`触发后的回调。

### 3. 微任务队列（Microtask Queue）

* 存放优先级更高的任务，比如：
  * `Promise.then` / `catch` / `finally`
  * `MutationObserver`
  * `queueMicrotask`
* 微任务会在当前宏任务结束后立即执行所有微任务，然后再继续下一个宏任务。

### 4. 事件轮询（Event Loop）

* 不断检查调用栈是否为空。
* 如果为空，则从消息队列或微任务队列中取出第一个任务推入调用栈执行。

***

## 三、事件轮询的工作流程

1. 所有同步代码先执行，进入调用栈。
2. 遇到异步操作（如 setTimeout、Promise），交给浏览器其他线程（如定时器线程、网络线程）处理。
3. 当这些异步任务完成后，它们的回调会被放入相应的任务队列：
   * 宏任务 → 宏任务队列（如 setTimeout 回调）
   * 微任务 → 微任务队列（如 Promise.then 回调）
4. 当调用栈为空时，事件循环会：
   * 先清空微任务队列中的所有任务
   * 然后从宏任务队列中取一个任务执行
5. 这个过程不断重复，形成了“事件轮询”。

**执行顺序**

* 1、先执行主线程
* 2、遇到宏队列（macrotask）放到宏队列（macrotask）
* 3、遇到微队列（microtask）放到微队列（microtask）
* 4、主线程执行完毕
* 5、执行微队列（microtask），微队列（microtask）执行完毕
* 6、执行一次宏队列（macrotask）中的一个任务，执行完毕
* 7、执行微队列（microtask），执行完毕
* 8、依次循环。。。

## 四、宏任务 vs 微任务

| 类型     | 示例                              | 特点                                       |
|----------|-----------------------------------|--------------------------------------------|
| 宏任务   | setTimeout, setInterval, I/O      | 每次事件循环处理一个宏任务                 |
| 微任务   | Promise.then, MutationObserver    | 优先级更高，宏任务之后立即清空所有微任务   |

举个例子：

```js
console.log("Start");

setTimeout(() => {
  console.log("setTimeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise.then");
});

console.log("End");
```

输出顺序为：

```bash
Start
End
Promise.then
setTimeout
```

解释：

* 同步代码先执行（Start、End）
* setTimeout 是宏任务，Promise.then 是微任务
* 所以微任务先执行，宏任务最后执行

***

## 五、实际应用和常见问题

### 1. 避免长时间阻塞主线程

* 大量计算或长循环会影响页面渲染和响应用户交互，应使用 Web Worker 或分片执行。

### 2. 微任务过多可能影响性能

* 如果微任务链太长，可能会导致 UI 渲染延迟，因为微任务会在每个宏任务之间全部执行完。

### 3. Vue/React 中的 nextTick/Microtask 使用

* Vue 的 `$nextTick()` 和 React 的某些更新机制都利用了微任务来确保 DOM 更新完成后再执行回调。

***

## 六、总结

事件轮询是 JavaScript 实现异步编程的核心机制，理解它有助于我们写出更高效、无阻塞的代码。其核心在于：

* JavaScript 是单线程的
* 异步任务由浏览器其他线程处理
* 回调进入任务队列
* 事件轮询负责将任务推入调用栈执行
* 微任务优先于宏任务执行

---

---
url: /Interview/js/pages/page11.md
---
# 事件轮询（Event Loop）

## 🧠 简要定义

> JavaScript 是一门单线程语言，为了不阻塞主线程，它采用了一种叫做事件轮询（Event Loop）的机制来处理异步操作。简单来说，`事件轮询就是 JavaScript 引擎中用来协调代码执行、处理事件和回调函数的一种机制`。

> js代码执行流程是：同步执行完了，才会走到事件轮询，进入到事件轮询：请求、事件、宏任务
> 事件轮询中包含：宏任务、微任务

## 🧱 基本组成与流程

我们可以将 Event Loop 拆解为几个核心部分来理解：

**1. 调用栈（Call Stack）**

* JavaScript 主线程中的一个数据结构，用于记录当前正在执行的函数。
* 后进先出（LIFO）结构。

**2. 堆（Heap）**
存放对象等动态数据的地方。

**3. 队列（Callback Queue）**

* 包括：
  * 宏任务队列（Macro Task Queue）如 setTimeout, setInterval, I/O 等。
  * 微任务队列（Micro Task Queue）如 Promise.then, MutationObserver, queueMicrotask 等。

::: details {open}

* 宏任务： script （主代码块）、setTimeout 、setInterval 、setImmediate 、I/O 、UI rendering
* 微任务：process.nextTick（Nodejs） 、Promise 、Object.observe 、MutationObserver
  :::
  **4. 事件循环本身（Event Loop）**

负责监听调用栈是否为空，一旦为空就从队列中取出任务放入调用栈执行。

## 🔁 事件轮询的工作流程

* 所有同步代码首先在调用栈中执行完毕。
* 遇到异步操作（如 setTimeout, fetch, DOM 事件），交给浏览器其他线程处理。
* 当这些异步任务完成时，它们的回调会被放入相应的任务队列中：
  * 宏任务 → 宏任务队列
  * 微任务 → 微任务队列
* 当调用栈清空后，事件循环会：
  * 先检查微任务队列，全部执行完；
  * 然后从宏任务队列中取出一个任务执行；
  * 重复这个过程。

## ⚠️ 关键点：微任务优先于宏任务

举个例子说明一下：

```js
console.log('Start');

setTimeout(() => {
  console.log('Timeout');
}, 0);

Promise.resolve().then(() => {
  console.log('Promise');
});

console.log('End');
```

输出顺序是：

```js
Start
End
Promise
Timeout
```

解释：

```js
Promise.then 是微任务，会在本轮事件循环结束前执行；
setTimeout 是宏任务，会在下一轮事件循环中执行。

```

## ✅ 总结

> 事件轮询是 JavaScript 实现异步非阻塞编程的核心机制。理解宏任务与微任务的区别，以及它们的执行顺序，对于写出高性能、无阻塞的应用至关重要。

---

---
url: /Interview/js/pages/page7.md
---
# 事件轮询（Event Loop）

事件触发线程管理的任务队列是如何产生的呢？事实上这些任务就是从JS引擎线程本身产生的，主线程在运行时会产生执行栈，栈中的代码调用某些异步API时会在任务队列中添加事件，栈中的代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制。JS中有两种任务类型：微任务（microtask）和宏任务（macrotask），在ES6中，microtask称为 jobs，macrotask称为 task：

* **宏任务**： script （主代码块）、setTimeout 、setInterval 、setImmediate 、I/O 、UI rendering
* **微任务**：process.nextTick（Nodejs） 、Promise 、Object.observe 、MutationObserver

Node.js中Event Loop和浏览器中Event Loop有什么区别？

Node.js中宏任务分成了几种类型，并且放在了不同的task queue里。不同的task queue在执行顺序上也有区别，微任务放在了每个task queue的末尾：

* setTimeout/setInterval 属于 timers 类型；
* setImmediate 属于 check 类型；
* socket 的 close 事件属于 close callbacks 类型；
* 其他 MacroTask 都属于 poll 类型。
* process.nextTick 本质上属于 MicroTask，但是它先于所有其他 MicroTask 执行；
* 所有 MicroTask 的执行时机在不同类型的 MacroTask 切换后。
* idle/prepare 仅供内部调用，我们可以忽略。
* pending callbacks 不太常见，我们也可以忽略。

---

---
url: /learning/browserNetwork/modules/page2.md
---
# 事件轮询（Event Loop）

### 一、整体概述

> **一句话总结**：
> 事件轮询是 JavaScript 引擎用来协调代码执行、处理异步任务的一种机制，确保主线程不会被阻塞，并保证异步操作能按顺序执行。

JavaScript 是单线程语言，意味着同一时间只能做一件事。为了实现异步非阻塞的能力，JavaScript 引擎通过 **调用栈（Call Stack）**、**消息队列（Callback Queue）** 和 **事件循环机制** 来管理任务调度。

***

### 二、核心组成部分与工作流程

#### 1. 调用栈（Call Stack）

* JS 引擎用来记录当前正在执行的函数调用。
* 函数调用时入栈，执行完成后出栈。

#### 2. 浏览器 API（Web APIs）

* 包括 `setTimeout`、`setInterval`、`DOM 事件`、`fetch` 等浏览器原生功能。
* 当这些异步操作完成时，它们会将回调函数交给“消息队列”。

#### 3. 消息队列（Callback Queue）

* 存放已经完成异步操作的回调函数。
* 例如：`setTimeout` 到时间后，其回调会被放入这个队列。

#### 4. 事件循环（Event Loop）

* 不断检查调用栈是否为空，如果空了，就从消息队列取出第一个回调推入调用栈执行。
* 这就是事件循环的核心逻辑。

***

### 三、宏任务 & 微任务（Microtask）

这是理解事件循环的关键点之一。

| 类型 | 示例 | 特点 |
|------|------|------|
| 宏任务（Macro Task） | `setTimeout`, `setInterval`, `I/O`, `UI 渲染`, `script` 整体代码 | 每次事件循环执行一个宏任务 |
| 微任务（Micro Task） | `Promise.then/catch/finally`, `MutationObserver`, `queueMicrotask` | 在当前宏任务结束后立即执行，优先于下一个宏任务 |

#### ✅ 执行顺序规则：

1. 执行同步代码（整个 script 是宏任务）
2. 同步代码执行完，清空微任务队列
3. 取出一个宏任务执行，重复上述过程

#### 🧪 示例说明：

```js
console.log('start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(() => {
  console.log('promise then');
});

console.log('end');

// 输出顺序：
// start → end → promise then → setTimeout
```

***

### 四、实际应用和常见问题

#### 1. 为什么 Promise 比 setTimeout 快？

* 因为 `Promise.then` 是微任务，会在当前宏任务结束后立即执行；
* 而 `setTimeout` 是宏任务，必须等到下一轮事件循环才会执行。

#### 2. 微任务堆积问题

* 如果有大量微任务（如递归调用 `Promise.then`），会导致页面无法渲染（因为渲染是宏任务），造成“饥饿”现象。
* 应避免无限递归微任务。

#### 3. DOM 更新延迟

* DOM 的更新通常发生在宏任务之间，所以即使你修改了 DOM，也可能不会立刻反映到界面上，直到当前宏任务结束。

***

### 五、总结归纳（适合结尾）

> 我可以用一句话总结事件轮询：
> “**事件轮询负责协调调用栈、消息队列和微任务队列，确保 JavaScript 在单线程下依然可以高效地处理异步操作。**”

掌握事件循环不仅可以帮助我们写出更高效的异步代码，还能解释很多看似奇怪的行为，比如为什么 `Promise.then` 总比 `setTimeout` 先执行，以及如何避免微任务堆积等问题。

***

## 🧠 延伸建议（加分项）

如果你在面试中能提到以下内容，会让你脱颖而出：

* Node.js 中的事件循环与浏览器的区别（Node 有多个阶段的宏任务队列）
* 使用 `queueMicrotask()` 或 `MutationObserver` 实现异步更新
* 如何利用微任务实现“异步安全”的状态更新（Vue.next(), React 的 flushSync）

***

## 📝 延申问题

1. `setTimeout(fn, 0)` 和 `Promise.then(fn)` 有什么区别？
2. 如何判断一个任务是宏任务还是微任务？
3. 什么是事件循环的 tick？
4. 为什么不能在微任务中频繁操作 DOM？
5. 微任务队列和回调队列的关系？

---

---
url: /Interview/vue/pages/page25.md
---
# 你的接口请求一般放在哪个生命周期中？为什么要这样做？

接口请求可以放在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。

但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

能更快获取到服务端数据，减少页面 loading 时间
SSR 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于代码的一致性

created 是在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。如果在 mounted 钩子函数中请求数据可能导致页面闪屏问题

---

---
url: /Interview/js/pages/page6.md
---
# 你知道null和undefined有什么区别么

作者在哦设计js 的时候先都是先设计的 null（为什么设计了null：最初设计js 的时候借鉴了 Java）

null会被隐式的转换成 0，很不容易发现错误

先有null 后有 undefined，出来 undefined  是为了填补之前的坑

具体区别是：

JavaScript的最初被是这样区分的：null是一个表示 “无”的对象（空对象指针），转为数值时为 0，undefined 是表示 一个“无”的原始值，转为数值时为 NaN

---

---
url: /Interview/js/pages/page4.md
---
# 你能说说缓存吗

## 一、从缓存的概念谈起（建立基础）

> 缓存是一种将数据临时存储再更快访问位置的技术，目的是为了提高系统的响应速度和性能。在前端开发中，缓存主要分为客户端缓存（浏览器缓存）和服务端缓存，其中客户端缓存是我们更常接触的部分。

## 二、重点讲浏览器缓存（体现专业性）

**继续深入：**

> “浏览器缓存主要分为两大类：强缓存和协商缓存。”

**1. 强缓存（不请求服务器）**

* 使用 HTTP 头字段 Expires 和 Cache-Control
* Cache-Control: max-age=3600 表示资源可以在本地缓存一个小时，期间不会发起任何请求
* 优点是速度快，完全不需要网络请求

**2. 协商缓存（需要请求服务器，但可能返回 304）**

* 使用 Last-Modified / If-Modified-Since 或 ETag / If-None-Match
* 浏览器会向服务器发送请求，服务器根据资源是否变化决定是否返回新内容
* 如果没有变化，返回状态码 304 Not Modified

> 我还会结合项目经验举例说明如何设置合适的缓存策略，比如静态资源（如 JS/CSS/图片）设置较长的强缓存时间，而 HTML 文件通常使用协商缓存，以确保用户能获取最新的页面入口。

## 三、谈谈 CDN 缓存（体现架构思维）

**继续扩展：**

> “除了浏览器缓存之外，CDN 缓存也是前端优化的重要手段。通过将资源部署到离用户更近的边缘节点，CDN 可以大幅减少加载延迟，并利用其全局缓存能力提升访问效率。”

## 四、再说本地存储相关的缓存技术（体现多方面理解）

“此外，我们还可以利用浏览器提供的本地存储机制来实现缓存功能，例如：”

* LocalStorage / SessionStorage：适合缓存一些用户数据或接口结果，提升用户体验
* Service Worker + Cache API：实现离线缓存和 PWA 应用的关键技术
* IndexedDB：用于缓存大量结构化数据，适合复杂应用的数据持久化

> 我会在实际项目中使用这些技术来减少重复请求，提升首屏加载速度，同时处理好版本更新和缓存失效的问题。

## 五、最后总结缓存的价值与注意事项（体现全面思考）

“总的来说，合理使用缓存可以显著提升网页性能、降低服务器压力、改善用户体验。但在使用过程中也要注意以下几点：”

* 缓存更新策略（比如上线新版本时如何让旧缓存失效）
* 不同类型资源的缓存策略差异（HTML、JS、CSS、图片等）
* 用户隐私与安全问题（避免敏感信息被缓存）
* 缓存穿透、缓存雪崩等问题的预防措施（虽然更多属于后端范畴，但前端也应有基本认知）

> 在我之前参与的某个项目中，我们通过合理设置 Cache-Control 和 ETag，使首页加载速度提升了 40%，同时也减少了服务器带宽消耗。

## 总结

> 所以我认为，缓存不仅是性能优化的核心手段之一，更是构建高质量 Web 应用不可或缺的一部分。

✅ 推荐组合方案（优雅又实用）
| 资源类型	|策略|
|--------:|--------:|
|HTML 页面|	设置 Cache-Control: no-cache|
|JS/CSS/图片|	使用 \[name].\[contenthash].ext 命名|
|版本控制|	客户端配合 localStorage 标记|
|CDN 加速|	启用缓存，但基于文件名 hash 控制更新|

---

---
url: /learning/other/page.md
---
# 其它

* 大文件上传方案

* 移动端适配

* 大屏适配

---

---
url: /learning/core/modules/page4.md
---
# 函数柯里化

> 函数柯里化（Currying）是一种函数式编程中的技术，它将一个接受多个参数的函数转换成一系列接受单个参数的函数。换句话说，**柯里化是一个将多参数函数转化为一系列单参数函数的过程**。

### 一、什么是函数柯里化？

举个例子：

```javascript
function add(a, b, c) {
  return a + b + c;
}
```

这个函数接受三个参数。使用柯里化后，可以变成这样：

```javascript
const curriedAdd = curry(add);

curriedAdd(1)(2)(3); // 6
```

或者：

```javascript
curriedAdd(1)(2)(3); // 等价于 add(1, 2, 3)
```

***

### 二、柯里化的实现原理

我们可以手动写一个通用的 `curry` 函数来实现柯里化：

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}
```

#### 示例：

```javascript
function sum(a, b, c) {
  return a + b + c;
}

const curriedSum = curry(sum);

console.log(curriedSum(1)(2)(3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1)(2, 3)); // 6
```

***

### 三、柯里化的作用和优势

1. **参数复用**：

   * 柯里化允许你提前传入部分参数，生成一个新函数。
   * 这样可以避免重复传参。

   ```javascript
   const add = (a, b) => a + b;
   const add10 = curry(add)(10);
   console.log(add10(5)); // 15
   ```

2. **提高函数可组合性**：
   * 在函数式编程中，柯里化使得函数更容易组合。

3. **延迟执行**：
   * 参数可以分多次传入，最终执行时才计算结果。

4. **增强代码可读性和表达力**：
   * 可以写出更具语义的链式调用。

***

### 四、可能的问题点

#### 1. 手写一个柯里化函数

* 要求你能写出上面提到的 `curry` 函数。
* 注意处理 `this` 的绑定。
* 考察对闭包、递归的理解。

#### 2. 柯里化与偏函数的区别？

| 特征 | 柯里化 | 偏函数 |
|------|--------|---------|
| 目标 | 多参数函数 → 单参数函数链 | 固定部分参数，返回新函数 |
| 参数顺序 | 从左到右依次传入 | 可固定任意位置参数 |
| 实现方式 | 通常通过递归或闭包 | 使用 bind 或封装 |

#### 3. 柯里化在实际开发中的应用

* React 中的事件处理函数优化
* 工具函数库如 Lodash 中的 `_.curry`
* 高阶组件（HOC）设计思想类似柯里化

***

### 五、扩展：自动柯里化工具函数（Lodash）

```javascript
const _ = require('lodash');

const add = _.curry(function(a, b, c) {
  return a + b + c;
});

add(1)(2)(3); // 6
```

***

### 六、总结一句话

> **函数柯里化是把一个多参数函数拆分成一系列单参数函数的技术，目的是让函数更灵活、更易于复用和组合。**

::: details {open}
当然可以！以下是一段“面试官问你函数柯里化”的完整模拟问答，适用于前端/JavaScript 高级开发岗位的面试场景：

***

🎤【面试官提问】：

> **面试官**：我看你在简历中提到了函数式编程相关经验，那我来问一下，你能说说什么是函数柯里化吗？

***

💬【你的回答】：

> **候选人**：好的。函数柯里化（Currying）是一种函数式编程中的技术，它将一个接受多个参数的函数转换成一系列依次接受单个参数的函数。

举个例子，比如我们有一个函数 `add(a, b, c)`，正常调用是 `add(1, 2, 3)`，而通过柯里化之后，我们可以这样调用：`curriedAdd(1)(2)(3)`。

它的核心思想是：**每次调用只传入一个参数，返回一个新的函数，直到所有参数都被传入为止，最后执行原始函数并返回结果**。

***

🎤【面试官追问】：

> **面试官**：那你能不能手写一个通用的柯里化函数呢？

***

💬【你的回答】：

> **候选人**：当然可以。下面是一个简单的通用柯里化函数实现：

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      // 参数已满足，执行原函数
      return fn.apply(this, args);
    } else {
      // 参数不足，返回新函数继续接收参数
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}
```

使用示例：

```javascript
function sum(a, b, c) {
  return a + b + c;
}

const curriedSum = curry(sum);

console.log(curriedSum(1)(2)(3));       // 6
console.log(curriedSum(1, 2)(3));       // 6
console.log(curriedSum(1)(2, 3));       // 6
```

这个实现的关键在于利用了闭包和递归来逐步收集参数，直到满足原始函数所需的参数数量后才真正执行。

***

🎤【面试官再问】：

> **面试官**：柯里化有什么实际应用？在项目中你会在哪种场景下使用它？

***

💬【你的回答】：

> **候选人**：柯里化有几个非常实用的场景：

1. **参数复用**：
   * 比如我可以把某个常用参数提前固定下来，生成一个更专用的函数。
   * 示例：`const formatMoney = formatCurrency('USD')`，后面只需要传金额即可。

2. **高阶组件设计思想类似柯里化**（React 场景）：
   * React 中的 HOC（高阶组件）本质上就是一种偏函数或柯里化的体现，比如：
     ```jsx
     const withLoading = (Component) => (props) => (
       <Suspense fallback="Loading..."><Component {...props} /></Suspense>
     );
     ```

3. **链式调用、逻辑清晰**：
   * 柯里化可以让代码更具可读性，例如在处理数据流时，逐步传参让意图更明确。

4. **函数组合（Function Composition）**：
   * 在函数式编程中，很多库（如 Ramda、Lodash）都提供了柯里化版本的工具函数，方便进行函数组合。

***

🎤【面试官总结性提问】：

> **面试官**：那你说说，柯里化和偏函数的区别是什么？

***

💬【你的回答】：

> **候选人**：这是一个很好的问题。

| 特征 | 柯里化 | 偏函数 |
|------|--------|---------|
| 定义 | 将多参数函数转换为一系列单参数函数 | 固定部分参数，返回剩余参数的新函数 |
| 调用方式 | `f(a)(b)(c)` | `f(a, b, c)` 或 `f.bind(null, a)` |
| 参数顺序 | 通常从左到右依次传入 | 可以固定任意位置的参数 |
| 实现方式 | 多数基于递归和闭包 | 一般通过 `bind` 或封装函数 |

简单来说，**柯里化是按顺序一步步传参，偏函数是预先填一部分参数，剩下的继续一次性传完**。

***

🎤【面试官点头】

> **面试官**：嗯，理解得挺深入的，不错 👍

***

✅ 总结建议：

这段问答展示了你对函数柯里化的理解深度，包括：

* 基本定义
* 手动实现
* 实际应用场景
* 与偏函数的对比

:::

---

---
url: /Interview/old/pages/page6.md
---
# 前端事件轮询

## 一、什么是事件轮询（Event Loop）？

事件轮询是 JavaScript 引擎处理异步操作的一种机制。它使得 JavaScript 在单线程的限制下依然可以处理并发任务，比如定时器、网络请求、用户交互等。

JavaScript 最初设计为单线程语言，主要是为了避免多线程带来的复杂性（如死锁）。但这也意味着同一时间只能执行一个任务。为了在不阻塞主线程的前提下处理异步任务，JavaScript 引入了 **事件轮询机制**。

## 二、事件轮询的核心组成部分

事件轮询依赖于几个关键的概念：

### 1. 调用栈（Call Stack）

* 是 JavaScript 执行代码的地方。
* 函数被调用时会被压入调用栈，执行完毕后弹出。

### 2. 消息队列（Callback Queue / Task Queue）

* 存放等待执行的回调函数。
* 比如：`setTimeout`、`setInterval`、`DOM 事件`触发后的回调。

### 3. 微任务队列（Microtask Queue）

* 存放优先级更高的任务，比如：
  * `Promise.then` / `catch` / `finally`
  * `MutationObserver`
  * `queueMicrotask`
* 微任务会在当前宏任务结束后立即执行所有微任务，然后再继续下一个宏任务。

### 4. 事件轮询（Event Loop）

* 不断检查调用栈是否为空。
* 如果为空，则从消息队列或微任务队列中取出第一个任务推入调用栈执行。

***

## 三、事件轮询的工作流程

1. 所有同步代码先执行，进入调用栈。
2. 遇到异步操作（如 setTimeout、Promise），交给浏览器其他线程（如定时器线程、网络线程）处理。
3. 当这些异步任务完成后，它们的回调会被放入相应的任务队列：
   * 宏任务 → 宏任务队列（如 setTimeout 回调）
   * 微任务 → 微任务队列（如 Promise.then 回调）
4. 当调用栈为空时，事件循环会：
   * 先清空微任务队列中的所有任务
   * 然后从宏任务队列中取一个任务执行
5. 这个过程不断重复，形成了“事件轮询”。

**执行顺序**

* 1、先执行主线程
* 2、遇到宏队列（macrotask）放到宏队列（macrotask）
* 3、遇到微队列（microtask）放到微队列（microtask）
* 4、主线程执行完毕
* 5、执行微队列（microtask），微队列（microtask）执行完毕
* 6、执行一次宏队列（macrotask）中的一个任务，执行完毕
* 7、执行微队列（microtask），执行完毕
* 8、依次循环。。。

## 四、宏任务 vs 微任务

| 类型     | 示例                              | 特点                                       |
|----------|-----------------------------------|--------------------------------------------|
| 宏任务   | setTimeout, setInterval, I/O      | 每次事件循环处理一个宏任务                 |
| 微任务   | Promise.then, MutationObserver    | 优先级更高，宏任务之后立即清空所有微任务   |

举个例子：

```js
console.log("Start");

setTimeout(() => {
  console.log("setTimeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise.then");
});

console.log("End");
```

输出顺序为：

```bash
Start
End
Promise.then
setTimeout
```

解释：

* 同步代码先执行（Start、End）
* setTimeout 是宏任务，Promise.then 是微任务
* 所以微任务先执行，宏任务最后执行

***

## 五、实际应用和常见问题

### 1. 避免长时间阻塞主线程

* 大量计算或长循环会影响页面渲染和响应用户交互，应使用 Web Worker 或分片执行。

### 2. 微任务过多可能影响性能

* 如果微任务链太长，可能会导致 UI 渲染延迟，因为微任务会在每个宏任务之间全部执行完。

### 3. Vue/React 中的 nextTick/Microtask 使用

* Vue 的 `$nextTick()` 和 React 的某些更新机制都利用了微任务来确保 DOM 更新完成后再执行回调。

***

## 六、总结

事件轮询是 JavaScript 实现异步编程的核心机制，理解它有助于我们写出更高效、无阻塞的代码。其核心在于：

* JavaScript 是单线程的
* 异步任务由浏览器其他线程处理
* 回调进入任务队列
* 事件轮询负责将任务推入调用栈执行
* 微任务优先于宏任务执行

---

---
url: /Interview/js/pages/page1.md
---
# 前端内存泄漏

**什么是存泄漏**

> 前端内存泄漏指的是 JavaScript 中已分配的内存，由于代码逻辑或引用关系的问题，不再需要却无法被垃圾回收机制回收的情况。随着时间推移，泄漏的内存不断累积，会导致页面性能下降、卡顿、崩溃，甚至影响整个浏览器或设备的稳定性。

**以下是前端开发中常见的内存泄漏原因和场景**

## 1、未清理的定时器 或 回调

* setInterval() 或 setTimeout() 被调用后，如果其回调函数引用了外部变量（尤其是 DOM 元素或大型对象），并且没有在适当的时候（如组件卸载、页面离开时）使用 clearInterval() 或 clearTimeout() 清除，那么这些定时器会一直存在，其引用的对象也无法被回收。

* `示例`： 在单页应用(SPA)的组件中启动定时器更新状态，但在组件卸载时忘记清除。

## 2、未移除的事件监听器

* 使用 addEventListener() 给 DOM 元素（特别是 window, document 等全局对象或动态创建的元素）添加了事件监听器，但在元素被移除（removeChild, innerHTML 清空等）或不再需要时（如组件卸载），没有使用 removeEventListener() 移除监听器。

* `示例`： 给一个按钮添加点击事件，当这个按钮所在的模态框被关闭并从 DOM 中移除时，如果没有移除监听器，那么监听器函数和它可能引用的外部作用域变量（包括被移除的按钮本身！）都会泄漏。在 SPA 中给全局对象添加监听器，切换路由时忘记移除是常见原因。

## 3、滥用闭包

* 闭包是 JavaScript 的核心特性，它使得内部函数可以访问外部函数的变量。如果闭包（例如一个事件处理函数、定时器回调、异步操作回调）持有了对外部函数作用域中某个大对象（如 DOM 元素、数组、对象）的引用，并且这个闭包的生命周期很长（比如被挂载到全局变量、DOM 事件上），那么即使外部函数执行完毕，它引用的外部变量也无法被 GC 回收。

* `示例`： 一个函数内部定义了一个事件处理函数（闭包），这个处理函数引用了函数内部的一个大数组。将事件处理函数绑定到 DOM 元素上，那么该大数组会一直存在，直到事件被移除且没有其他引用

## 4、游离的 DOM 引用

* 在 JavaScript 中保存了对某个 DOM 元素的引用（例如 let element = document.getElementById('myElement');），即使后来这个元素从实际的 DOM 树中被移除了（element.parentNode.removeChild(element);），只要 JavaScript 变量 element 还存在（例如保存在某个数组、对象或全局变量中），那么这个被移除的 DOM 元素及其关联的事件监听器和子元素占用的内存就不会被释放。

* `示例`： 维护一个数组来缓存已创建的列表项 DOM 元素，当从页面删除某些项时，只从 DOM 树中移除了，但没有从缓存数组中删除对应的引用。

## 5、意外的全局变量

* 意外创建的全局变量（如在函数内部忘记写 var, let, const）或故意将大对象赋值给全局变量（window.myHugeData = ...;）。全局变量存在于全局作用域，贯穿整个应用的生命周期，永远不会被 GC 回收。

* `示例`： function foo() { bar = 'oops'; } (创建了全局变量 bar)。或者 window.cache = {}; 并且不断往里面塞数据而不清理。

## 6、console.log 持有引用

* 在开发过程中，console.log 打印大型对象、数组或 DOM 元素。浏览器控制台为了便于开发者检查（例如可以展开对象），会保留对这些被打印对象的引用，阻止其被回收。虽然在生产环境 console.log 通常会被移除，但遗漏的 console.log 在生产环境也可能造成泄漏（尤其是在打印大对象时）。

## 7、第三方库使用或管理不当

* 使用第三方库（如图表库、地图库、富文本编辑器）时，如果库本身存在内存泄漏问题。

* 更常见的是，没有按照库的要求在实例不再需要时调用其销毁/清理方法（如 destroy(), dispose(), unmount()）。库内部可能创建了 DOM、事件监听器、Web Workers、WebSockets 等资源，如果不主动销毁，这些资源及其关联的 JS 对象就会泄漏。

## 8、未关闭的连接和未取消的订阅 (WebSockets, Observables, Event Emitters)

* 创建了 WebSocket 连接、订阅了 RxJS Observable、或者使用了 EventEmitter 模式，但在不再需要时（组件卸载、页面离开）没有关闭连接（websocket.close()）或取消订阅（subscription.unsubscribe()）。这些连接或订阅的回调函数可能持有对组件或其他对象的引用，导致泄漏。

## 9、缓存管理不当

* 实现自定义缓存机制时，如果没有设置合理的过期策略或大小限制，缓存的数据会无限增长，占用越来越多的内存

## 如何排查和避免内存泄漏

使用浏览器开发者工具 (`Chrome DevTools`):

`Performance Monitor`: 实时监控 JS Heap Size、DOM Nodes 等指标，观察是否有持续增长的趋势。

**Memory Profiler(内存分析):**

`Heap Snapshots`: 在不同操作（如打开/关闭组件）前后拍摄堆快照，对比查找持续增长或未被释放的对象及其引用链。

`Allocation instrumentation on timeline`: 实时跟踪内存分配，定位频繁分配且未被回收的对象。

`Performance Recordings`: 记录性能时间线，观察内存使用趋势，并与用户操作关联。

**良好的编码习惯：**

`及时清理`： 对定时器、事件监听器、第三方库实例、订阅、WebSocket 连接等，在它们不再需要时（componentWillUnmount / useEffect cleanup / beforeDestroy / onPageHide 等生命周期或事件中）主动清除、移除、销毁、取消订阅、关闭。

`谨慎使用闭包`： 注意闭包引用了哪些外部变量，评估其生命周期。必要时可以手动解除引用（如将引用置为 null）。

`管理 DOM 引用`： 当 DOM 元素被移除后，确保删除所有指向它的 JavaScript 引用（将其置为 null 或从数组中移除）。

`避免全局变量`： 尽量使用模块作用域、函数作用域或块级作用域变量 (let, const)。必须使用全局状态时，考虑使用状态管理库（如 Redux, Vuex）并注意清理。

`清理 console.log`: 在提交代码前移除或注释掉不必要的 console.log，尤其是打印大型对象时。

`遵循第三方库规范`： 仔细阅读库的文档，了解其资源管理要求，务必在适当时机调用清理方法。

`使用 WeakMap / WeakSet`： 当需要存储对对象的弱引用（即引用不阻止 GC）时，可以使用 WeakMap 和 WeakSet。这常用于存储与对象关联的元数据，而不会阻止对象被回收。

`代码审查`： 在团队协作中，代码审查是发现潜在内存泄漏模式（如忘记清理监听器、定时器）的好方法。

`自动化测试 (可选但推荐)`： 使用类似 Puppeteer 或 Playwright 的工具编写 E2E 测试，结合 DevTools 的 Memory API 或 Performance Monitor，在关键用户流（如多次打开/关闭模态框、导航页面）后检查内存是否稳定。

`总结：` 前端内存泄漏的核心在于 “不需要的对象因为意外的引用而无法被回收”。解决的关键在于意识（了解常见泄漏点）、习惯（及时清理资源、谨慎管理引用）和工具（善用 DevTools 进行检测和分析）。尤其是在构建复杂的单页应用时，内存管理至关重要。

---

---
url: /Interview/old/pages/page4.md
---
# 前端内存泄漏

**什么是存泄漏**

> 前端内存泄漏指的是 JavaScript 中已分配的内存，由于代码逻辑或引用关系的问题，不再需要却无法被垃圾回收机制回收的情况。随着时间推移，泄漏的内存不断累积，会导致页面性能下降、卡顿、崩溃，甚至影响整个浏览器或设备的稳定性。

**以下是前端开发中常见的内存泄漏原因和场景**

## 1、未清理的定时器 或 回调

* setInterval() 或 setTimeout() 被调用后，如果其回调函数引用了外部变量（尤其是 DOM 元素或大型对象），并且没有在适当的时候（如组件卸载、页面离开时）使用 clearInterval() 或 clearTimeout() 清除，那么这些定时器会一直存在，其引用的对象也无法被回收。

* `示例`： 在单页应用(SPA)的组件中启动定时器更新状态，但在组件卸载时忘记清除。

## 2、未移除的事件监听器

* 使用 addEventListener() 给 DOM 元素（特别是 window, document 等全局对象或动态创建的元素）添加了事件监听器，但在元素被移除（removeChild, innerHTML 清空等）或不再需要时（如组件卸载），没有使用 removeEventListener() 移除监听器。

* `示例`： 给一个按钮添加点击事件，当这个按钮所在的模态框被关闭并从 DOM 中移除时，如果没有移除监听器，那么监听器函数和它可能引用的外部作用域变量（包括被移除的按钮本身！）都会泄漏。在 SPA 中给全局对象添加监听器，切换路由时忘记移除是常见原因。

## 3、滥用闭包

* 闭包是 JavaScript 的核心特性，它使得内部函数可以访问外部函数的变量。如果闭包（例如一个事件处理函数、定时器回调、异步操作回调）持有了对外部函数作用域中某个大对象（如 DOM 元素、数组、对象）的引用，并且这个闭包的生命周期很长（比如被挂载到全局变量、DOM 事件上），那么即使外部函数执行完毕，它引用的外部变量也无法被 GC 回收。

* `示例`： 一个函数内部定义了一个事件处理函数（闭包），这个处理函数引用了函数内部的一个大数组。将事件处理函数绑定到 DOM 元素上，那么该大数组会一直存在，直到事件被移除且没有其他引用

## 4、游离的 DOM 引用

* 在 JavaScript 中保存了对某个 DOM 元素的引用（例如 let element = document.getElementById('myElement');），即使后来这个元素从实际的 DOM 树中被移除了（element.parentNode.removeChild(element);），只要 JavaScript 变量 element 还存在（例如保存在某个数组、对象或全局变量中），那么这个被移除的 DOM 元素及其关联的事件监听器和子元素占用的内存就不会被释放。

* `示例`： 维护一个数组来缓存已创建的列表项 DOM 元素，当从页面删除某些项时，只从 DOM 树中移除了，但没有从缓存数组中删除对应的引用。

## 5、意外的全局变量

* 意外创建的全局变量（如在函数内部忘记写 var, let, const）或故意将大对象赋值给全局变量（window.myHugeData = ...;）。全局变量存在于全局作用域，贯穿整个应用的生命周期，永远不会被 GC 回收。

* `示例`： function foo() { bar = 'oops'; } (创建了全局变量 bar)。或者 window.cache = {}; 并且不断往里面塞数据而不清理。

## 6、console.log 持有引用

* 在开发过程中，console.log 打印大型对象、数组或 DOM 元素。浏览器控制台为了便于开发者检查（例如可以展开对象），会保留对这些被打印对象的引用，阻止其被回收。虽然在生产环境 console.log 通常会被移除，但遗漏的 console.log 在生产环境也可能造成泄漏（尤其是在打印大对象时）。

## 7、第三方库使用或管理不当

* 使用第三方库（如图表库、地图库、富文本编辑器）时，如果库本身存在内存泄漏问题。

* 更常见的是，没有按照库的要求在实例不再需要时调用其销毁/清理方法（如 destroy(), dispose(), unmount()）。库内部可能创建了 DOM、事件监听器、Web Workers、WebSockets 等资源，如果不主动销毁，这些资源及其关联的 JS 对象就会泄漏。

## 8、未关闭的连接和未取消的订阅 (WebSockets, Observables, Event Emitters)

* 创建了 WebSocket 连接、订阅了 RxJS Observable、或者使用了 EventEmitter 模式，但在不再需要时（组件卸载、页面离开）没有关闭连接（websocket.close()）或取消订阅（subscription.unsubscribe()）。这些连接或订阅的回调函数可能持有对组件或其他对象的引用，导致泄漏。

## 9、缓存管理不当

* 实现自定义缓存机制时，如果没有设置合理的过期策略或大小限制，缓存的数据会无限增长，占用越来越多的内存

## 如何排查和避免内存泄漏

使用浏览器开发者工具 (`Chrome DevTools`):

`Performance Monitor`: 实时监控 JS Heap Size、DOM Nodes 等指标，观察是否有持续增长的趋势。

**Memory Profiler(内存分析):**

`Heap Snapshots`: 在不同操作（如打开/关闭组件）前后拍摄堆快照，对比查找持续增长或未被释放的对象及其引用链。

`Allocation instrumentation on timeline`: 实时跟踪内存分配，定位频繁分配且未被回收的对象。

`Performance Recordings`: 记录性能时间线，观察内存使用趋势，并与用户操作关联。

**良好的编码习惯：**

`及时清理`： 对定时器、事件监听器、第三方库实例、订阅、WebSocket 连接等，在它们不再需要时（componentWillUnmount / useEffect cleanup / beforeDestroy / onPageHide 等生命周期或事件中）主动清除、移除、销毁、取消订阅、关闭。

`谨慎使用闭包`： 注意闭包引用了哪些外部变量，评估其生命周期。必要时可以手动解除引用（如将引用置为 null）。

`管理 DOM 引用`： 当 DOM 元素被移除后，确保删除所有指向它的 JavaScript 引用（将其置为 null 或从数组中移除）。

`避免全局变量`： 尽量使用模块作用域、函数作用域或块级作用域变量 (let, const)。必须使用全局状态时，考虑使用状态管理库（如 Redux, Vuex）并注意清理。

`清理 console.log`: 在提交代码前移除或注释掉不必要的 console.log，尤其是打印大型对象时。

`遵循第三方库规范`： 仔细阅读库的文档，了解其资源管理要求，务必在适当时机调用清理方法。

`使用 WeakMap / WeakSet`： 当需要存储对对象的弱引用（即引用不阻止 GC）时，可以使用 WeakMap 和 WeakSet。这常用于存储与对象关联的元数据，而不会阻止对象被回收。

`代码审查`： 在团队协作中，代码审查是发现潜在内存泄漏模式（如忘记清理监听器、定时器）的好方法。

`自动化测试 (可选但推荐)`： 使用类似 Puppeteer 或 Playwright 的工具编写 E2E 测试，结合 DevTools 的 Memory API 或 Performance Monitor，在关键用户流（如多次打开/关闭模态框、导航页面）后检查内存是否稳定。

`总结：` 前端内存泄漏的核心在于 “不需要的对象因为意外的引用而无法被回收”。解决的关键在于意识（了解常见泄漏点）、习惯（及时清理资源、谨慎管理引用）和工具（善用 DevTools 进行检测和分析）。尤其是在构建复杂的单页应用时，内存管理至关重要。

![图片](../1.png)

---

---
url: /learning/optimization/modules/page4.md
---
# 前端内存泄漏

**什么是存泄漏**

> 前端内存泄漏指的是 JavaScript 中已分配的内存，由于代码逻辑或引用关系的问题，不再需要却无法被垃圾回收机制回收的情况。随着时间推移，泄漏的内存不断累积，会导致页面性能下降、卡顿、崩溃，甚至影响整个浏览器或设备的稳定性。

**以下是前端开发中常见的内存泄漏原因和场景**

## 1、未清理的定时器 或 回调

* setInterval() 或 setTimeout() 被调用后，如果其回调函数引用了外部变量（尤其是 DOM 元素或大型对象），并且没有在适当的时候（如组件卸载、页面离开时）使用 clearInterval() 或 clearTimeout() 清除，那么这些定时器会一直存在，其引用的对象也无法被回收。

* `示例`： 在单页应用(SPA)的组件中启动定时器更新状态，但在组件卸载时忘记清除。

## 2、未移除的事件监听器

* 使用 addEventListener() 给 DOM 元素（特别是 window, document 等全局对象或动态创建的元素）添加了事件监听器，但在元素被移除（removeChild, innerHTML 清空等）或不再需要时（如组件卸载），没有使用 removeEventListener() 移除监听器。

* `示例`： 给一个按钮添加点击事件，当这个按钮所在的模态框被关闭并从 DOM 中移除时，如果没有移除监听器，那么监听器函数和它可能引用的外部作用域变量（包括被移除的按钮本身！）都会泄漏。在 SPA 中给全局对象添加监听器，切换路由时忘记移除是常见原因。

## 3、滥用闭包

* 闭包是 JavaScript 的核心特性，它使得内部函数可以访问外部函数的变量。如果闭包（例如一个事件处理函数、定时器回调、异步操作回调）持有了对外部函数作用域中某个大对象（如 DOM 元素、数组、对象）的引用，并且这个闭包的生命周期很长（比如被挂载到全局变量、DOM 事件上），那么即使外部函数执行完毕，它引用的外部变量也无法被 GC 回收。

* `示例`： 一个函数内部定义了一个事件处理函数（闭包），这个处理函数引用了函数内部的一个大数组。将事件处理函数绑定到 DOM 元素上，那么该大数组会一直存在，直到事件被移除且没有其他引用

## 4、游离的 DOM 引用

* 在 JavaScript 中保存了对某个 DOM 元素的引用（例如 let element = document.getElementById('myElement');），即使后来这个元素从实际的 DOM 树中被移除了（element.parentNode.removeChild(element);），只要 JavaScript 变量 element 还存在（例如保存在某个数组、对象或全局变量中），那么这个被移除的 DOM 元素及其关联的事件监听器和子元素占用的内存就不会被释放。

* `示例`： 维护一个数组来缓存已创建的列表项 DOM 元素，当从页面删除某些项时，只从 DOM 树中移除了，但没有从缓存数组中删除对应的引用。

## 5、意外的全局变量

* 意外创建的全局变量（如在函数内部忘记写 var, let, const）或故意将大对象赋值给全局变量（window.myHugeData = ...;）。全局变量存在于全局作用域，贯穿整个应用的生命周期，永远不会被 GC 回收。

* `示例`： function foo() { bar = 'oops'; } (创建了全局变量 bar)。或者 window.cache = {}; 并且不断往里面塞数据而不清理。

## 6、console.log 持有引用

* 在开发过程中，console.log 打印大型对象、数组或 DOM 元素。浏览器控制台为了便于开发者检查（例如可以展开对象），会保留对这些被打印对象的引用，阻止其被回收。虽然在生产环境 console.log 通常会被移除，但遗漏的 console.log 在生产环境也可能造成泄漏（尤其是在打印大对象时）。

## 7、第三方库使用或管理不当

* 使用第三方库（如图表库、地图库、富文本编辑器）时，如果库本身存在内存泄漏问题。

* 更常见的是，没有按照库的要求在实例不再需要时调用其销毁/清理方法（如 destroy(), dispose(), unmount()）。库内部可能创建了 DOM、事件监听器、Web Workers、WebSockets 等资源，如果不主动销毁，这些资源及其关联的 JS 对象就会泄漏。

## 8、未关闭的连接和未取消的订阅 (WebSockets, Observables, Event Emitters)

* 创建了 WebSocket 连接、订阅了 RxJS Observable、或者使用了 EventEmitter 模式，但在不再需要时（组件卸载、页面离开）没有关闭连接（websocket.close()）或取消订阅（subscription.unsubscribe()）。这些连接或订阅的回调函数可能持有对组件或其他对象的引用，导致泄漏。

## 9、缓存管理不当

* 实现自定义缓存机制时，如果没有设置合理的过期策略或大小限制，缓存的数据会无限增长，占用越来越多的内存

## 如何排查和避免内存泄漏

使用浏览器开发者工具 (`Chrome DevTools`):

`Performance Monitor`: 实时监控 JS Heap Size、DOM Nodes 等指标，观察是否有持续增长的趋势。

**Memory Profiler(内存分析):**

`Heap Snapshots`: 在不同操作（如打开/关闭组件）前后拍摄堆快照，对比查找持续增长或未被释放的对象及其引用链。

`Allocation instrumentation on timeline`: 实时跟踪内存分配，定位频繁分配且未被回收的对象。

`Performance Recordings`: 记录性能时间线，观察内存使用趋势，并与用户操作关联。

**良好的编码习惯：**

`及时清理`： 对定时器、事件监听器、第三方库实例、订阅、WebSocket 连接等，在它们不再需要时（componentWillUnmount / useEffect cleanup / beforeDestroy / onPageHide 等生命周期或事件中）主动清除、移除、销毁、取消订阅、关闭。

`谨慎使用闭包`： 注意闭包引用了哪些外部变量，评估其生命周期。必要时可以手动解除引用（如将引用置为 null）。

`管理 DOM 引用`： 当 DOM 元素被移除后，确保删除所有指向它的 JavaScript 引用（将其置为 null 或从数组中移除）。

`避免全局变量`： 尽量使用模块作用域、函数作用域或块级作用域变量 (let, const)。必须使用全局状态时，考虑使用状态管理库（如 Redux, Vuex）并注意清理。

`清理 console.log`: 在提交代码前移除或注释掉不必要的 console.log，尤其是打印大型对象时。

`遵循第三方库规范`： 仔细阅读库的文档，了解其资源管理要求，务必在适当时机调用清理方法。

`使用 WeakMap / WeakSet`： 当需要存储对对象的弱引用（即引用不阻止 GC）时，可以使用 WeakMap 和 WeakSet。这常用于存储与对象关联的元数据，而不会阻止对象被回收。

`代码审查`： 在团队协作中，代码审查是发现潜在内存泄漏模式（如忘记清理监听器、定时器）的好方法。

`自动化测试 (可选但推荐)`： 使用类似 Puppeteer 或 Playwright 的工具编写 E2E 测试，结合 DevTools 的 Memory API 或 Performance Monitor，在关键用户流（如多次打开/关闭模态框、导航页面）后检查内存是否稳定。

`总结：` 前端内存泄漏的核心在于 “不需要的对象因为意外的引用而无法被回收”。解决的关键在于意识（了解常见泄漏点）、习惯（及时清理资源、谨慎管理引用）和工具（善用 DevTools 进行检测和分析）。尤其是在构建复杂的单页应用时，内存管理至关重要。

![图片](./1.png)

---

---
url: /guide/start.md
---
# 前端前沿

---

---
url: /Interview.md
---
# 前端开发面试题完整答案（含代码示例）

## JavaScript 基础

### 原型和原型链

JavaScript 是基于原型的语言。每个对象（除了null）都有一个内部属性 `[[Prototype]]`（可通过 `__proto__` 访问），指向其构造函数的 `prototype` 对象。多个对象通过原型层层连接形成“原型链”，用于实现继承与共享方法。

```js
function Person() {}
Person.prototype.say = function () {
  console.log("Hello");
};

const p = new Person();
p.say(); // 从原型链上找到 say 方法
```

***

### 事件循环

JavaScript 是单线程语言，事件循环机制确保异步任务有序执行。

流程如下：

1. 执行全局同步代码；
2. 清空微任务队列（Promise.then、MutationObserver）；
3. 执行宏任务（setTimeout、setInterval、I/O）；
4. 循环往复。

```js
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Microtask");
});

console.log("End");

// 输出顺序: Start -> End -> Microtask -> Timeout
```

***

### 箭头函数和普通函数的区别

| 特性           | 箭头函数                          | 普通函数                  |
|----------------|-----------------------------------|---------------------------|
| `this` 指向    | 外层作用域                        | 调用者                    |
| `arguments`    | 不支持                            | 支持                      |
| `new` 调用     | 不可作为构造函数                  | 可以                      |
| `prototype` 属性 | 无                                | 有                        |
| `super`        | 不支持                            | 支持                      |

***

### 闭包

闭包是指有权访问另一个函数作用域中变量的函数。常用于封装私有变量、计数器等。

```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}

const counter = outer();
counter(); // 1
counter(); // 2
```

***

### 深拷贝和浅拷贝

* **浅拷贝**：只复制对象的第一层属性。
* **深拷贝**：递归复制对象的所有层级属性。

```js
// 浅拷贝示例
const obj = { a: 1, b: { c: 2 } };
const shallowCopy = Object.assign({}, obj);
shallowCopy.b.c = 3;
console.log(obj.b.c); // 3（原对象被修改）

// 深拷贝示例
function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj)); // 简单实现
}
```

***

### 防抖和节流

* **防抖**：在事件被触发后等待一段时间，若没有再次触发才执行。
* **节流**：保证函数在一定时间间隔内只执行一次。

```js
// 防抖
function debounce(fn, delay) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 节流
function throttle(fn, delay) {
  let last = 0;
  return (...args) => {
    const now = Date.now();
    if (now - last > delay) {
      fn.apply(this, args);
      last = now;
    }
  };
}
```

***

### 怎么实现一个深拷贝，思路

```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== "object") return obj;
  if (hash.has(obj)) return hash.get(obj); // 处理循环引用
  const clone = Array.isArray(obj) ? [] : {};
  hash.set(obj, clone);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], hash);
    }
  }
  return clone;
}
```

***

### 内存泄漏是什么，怎么导致的

**内存泄漏**：程序申请内存后未能释放，造成内存浪费。常见原因：

* 全局变量未清理；
* 闭包引用外部变量；
* 未清除的定时器；
* 事件监听未解绑；
* DOM 引用未释放。

***

### Promise介绍和实现原理

```js
class MyPromise {
  constructor(executor) {
    // 初始化状态为 pending
    this.state = "pending";
    // 保存成功值
    this.value = undefined;
    // 保存失败原因
    this.reason = undefined;
    // 存储成功回调队列
    this.onFulfilledCallbacks = [];
    // 存储失败回调队列
    this.onRejectedCallbacks = [];

    // 定义 resolve 函数
    const resolve = (value) => {
      if (this.state === "pending") {
        this.state = "fulfilled"; // 更新状态为 fulfilled
        this.value = value; // 保存成功值
        // 异步执行所有成功回调
        this.onFulfilledCallbacks.forEach((fn) => fn());
      }
    };

    // 定义 reject 函数
    const reject = (reason) => {
      if (this.state === "pending") {
        this.state = "rejected"; // 更新状态为 rejected
        this.reason = reason; // 保存失败原因
        // 异步执行所有失败回调
        this.onRejectedCallbacks.forEach((fn) => fn());
      }
    };

    try {
      // 立即执行 executor，并传入 resolve 和 reject
      executor(resolve, reject);
    } catch (e) {
      // 如果 executor 同步抛出异常，直接 reject
      reject(e);
    }
  }

  then(onFulfilled, onRejected) {
    // 默认值处理：onFulfilled 不存在时返回 identity 函数
    onFulfilled =
      typeof onFulfilled === "function"
        ? onFulfilled
        : (v) => v;
    // 默认值处理：onRejected 不存在时抛出异常
    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : (e) => {
            throw e;
          };

    // 创建新 Promise 支持链式调用
    const promise2 = new MyPromise((resolve, reject) => {
      if (this.state === "fulfilled") {
        // 如果当前 Promise 已 fulfilled，异步执行 onFulfilled
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value);
            resolve(x); // 将结果传递给新 Promise
          } catch (e) {
            reject(e); // 如果 onFulfilled 抛出异常，新 Promise 被 reject
          }
        }, 0);
      }

      if (this.state === "rejected") {
        // 如果当前 Promise 已 rejected，异步执行 onRejected
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            resolve(x); // 将结果传递给新 Promise
          } catch (e) {
            reject(e); // 如果 onRejected 抛出异常，新 Promise 被 reject
          }
        }, 0);
      }

      if (this.state === "pending") {
        // 如果当前 Promise 仍 pending，先将回调加入队列
        this.onFulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value);
              resolve(x);
            } catch (e) {
              reject(e);
            }
          }, 0);
        });

        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onRejected(this.reason);
              resolve(x);
            } catch (e) {
              reject(e);
            }
          }, 0);
        });
      }
    });

    return promise2;
  }
}
```

***

### 如何实现一个 new

```js
function myNew(constructor, ...args) {
  const obj = Object.create(constructor.prototype);
  const result = constructor.apply(obj, args);
  return typeof result === "object" && result !== null ? result : obj;
}
```

***

### this指向问题

**this 的指向取决于调用方式，而不是定义方式。**

| 调用方式                | `this` 指向                              |
|-------------------------|------------------------------------------|
| 普通函数调用            | 全局对象（非严格模式）或 `undefined`（严格模式） |
| 对象方法调用            | 调用该方法的对象                         |
| 箭头函数                | 定义时外层作用域的 `this`                |
| 构造函数（`new`）       | 新创建的实例对象                         |
| `call`/`apply`/`bind`   | 显式传入的对象                           |
| 事件监听器（普通函数）  | 触发事件的 DOM 元素                      |
| 事件监听器（箭头函数）  | 外层作用域的 `this`                      |

```js
const obj = {
  name: "Alice",
  say: function () {
    console.log(this.name);
  },
};

obj.say(); // Alice (this 指向 obj)

const say = obj.say;
say(); // undefined (this 指向 window/global)

const boundSay = obj.say.bind({ name: "Bob" });
boundSay(); // Bob
```

***

### js有哪些数据类型

**原始类型**：`number`、`string`、`boolean`、`null`、`undefined`、`symbol`、`bigint`\
**引用类型**：`object`（包括 `Array`、`Function`、`Date`、`RegExp` 等）

***

### 大文件上传怎么做

#### 一、实现思路

大文件上传的核心思想是**分片上传**（Chunked Upload）：

1. **文件切片**：将大文件按固定大小（如5MB）拆分成多个小块
2. **并行上传**：逐个或并发上传这些分片
3. **服务端合并**：所有分片上传完成后，由服务端合并成完整文件
4. **断点续传**：通过记录已上传分片，支持中断后继续上传

***

#### 二、代码实现与注释

```javascript
/**
 * 大文件上传主函数
 * @param {File} file - 浏览器File对象
 */
async function uploadLargeFile(file) {
  // 1. 设置分片大小（5MB）
  const chunkSize = 5 * 1024 * 1024; // 5MB
  // 2. 计算总分片数（向上取整）
  const totalChunks = Math.ceil(file.size / chunkSize);
  // 3. 创建分片数组
  const chunks = [];

  // 4. 文件切片处理
  for (let i = 0; i < totalChunks; i++) {
    const start = i * chunkSize; // 当前分片起始位置
    const end = Math.min(start + chunkSize, file.size); // 当前分片结束位置
    // 使用File.slice()方法切割分片（兼容性：File API标准）
    chunks.push(file.slice(start, end));
  }

  // 5. 顺序上传分片（可改为并发上传优化速度）
  for (let i = 0; i < chunks.length; i++) {
    await uploadChunk(chunks[i], i, totalChunks); // 等待每个分片上传完成
  }
}

/**
 * 单个分片上传函数
 * @param {Blob} chunk - 分片内容
 * @param {number} index - 分片序号（从0开始）
 * @param {number} total - 总分片数
 */
async function uploadChunk(chunk, index, total) {
  // 6. 创建FormData对象用于上传
  const formData = new FormData();
  // 7. 添加分片文件（名称需与服务端接收参数一致）
  formData.append("file", chunk);
  // 8. 添加分片元数据
  formData.append("index", index);  // 当前分片序号
  formData.append("total", total);  // 总分片数

  // 9. 发送POST请求上传分片
  await fetch("/upload", {
    method: "POST",
    body: formData,
    // 可选：添加进度监听
    // onUploadProgress: (progressEvent) => {
    //   console.log(`上传进度: ${Math.round(
    //     (progressEvent.loaded * 100) / progressEvent.total
    //   )}%`);
    // }
  });
}
```

***

#### 三、关键实现点说明

##### 1. **分片大小选择**

* 5MB 是常见选择（HTTP请求最大推荐大小）
* 根据网络带宽和服务器配置可调整（建议2-10MB）

##### 2. **文件切片技术**

* 使用 `File.slice()` 方法（浏览器原生API）
* 兼容性：现代浏览器均支持（IE10+）

##### 3. **上传策略**

* **顺序上传**：当前实现保证分片顺序，但较慢
* **并发上传**：可用 `Promise.all()` 并发处理
* **断点续传**：需服务端记录已上传分片

##### 4. **服务端要求**

* 需支持接收分片并记录分片信息
* 最终需提供合并接口（如 `/merge`）
* 示例响应格式：
  ```json
  {
    "status": "success",
    "chunkIndex": 3,
    "totalChunks": 20
  }
  ```

***

#### 四、优化建议

##### 1. **并发上传优化**

```javascript
// 替换顺序上传为并发上传
await Promise.all(chunks.map((chunk, i) => 
  uploadChunk(chunk, i, totalChunks)
));
```

##### 2. **断点续传实现**

1. 首次上传前请求 `/check-chunks`
2. 服务端返回已存在的分片索引
3. 客户端跳过已存在的分片

##### 3. **上传进度追踪**

```javascript
// 在fetch中添加进度监听
const controller = new AbortController();
const upload = fetch("/upload", {
  signal: controller.signal,
  //...
});

// 监听进度
upload.then(() => {
  console.log(`分片 ${index} 上传完成`);
});
```

#### 4. **错误重试机制**

```javascript
// 添加重试逻辑
async function uploadChunkWithRetry(...args) {
  const MAX_RETRIES = 3;
  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      return await uploadChunk(...args);
    } catch (error) {
      if (i === MAX_RETRIES - 1) throw error;
      console.log(`重试第 ${i + 1} 次...`);
    }
  }
}
```

***

#### 五、完整工作流程

```
[客户端]          [服务端]
1. 文件切片        ← 接收分片请求
2. 顺序/并发上传    → 接收分片并存储
3. 收到全部分片    ← 请求合并分片
4. 调用 /merge 接口 → 合并文件
5. 返回最终文件URL
```

***

#### 六、注意事项

1. **CORS配置**：确保服务端允许跨域上传
2. **文件类型校验**：上传前应验证MIME类型
3. **文件大小限制**：服务端需设置合理的上传大小限制
4. **安全性**：建议添加上传凭证（token）和签名验证
5. **清理机制**：未完成的分片需要定时清理

```js
async function uploadLargeFile(file) {
  const chunkSize = 5 * 1024 * 1024; // 5MB
  const totalChunks = Math.ceil(file.size / chunkSize);
  const chunks = [];

  for (let i = 0; i < totalChunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    chunks.push(file.slice(start, end));
  }

  for (let i = 0; i < chunks.length; i++) {
    await uploadChunk(chunks[i], i, totalChunks);
  }
}

async function uploadChunk(chunk, index, total) {
  const formData = new FormData();
  formData.append("file", chunk);
  formData.append("index", index);
  formData.append("total", total);

  await fetch("/upload", {
    method: "POST",
    body: formData,
  });
}
```

***

### 首屏优化怎么做

1. **减少请求数量**：合并 CSS/JS、使用雪碧图；
2. **图片懒加载**：使用 `loading="lazy"`；
3. **静态资源 CDN**；
4. **启用 Gzip 压缩**；
5. **SSR 或预渲染**；
6. **骨架屏**；
7. **Tree Shaking 削减冗余代码**；
8. **Webpack Code Splitting 按需加载**。

***

### 浏览器输入 URL 到渲染过程

[PDF查看详细流程](../.vitepress/theme/pdf/1.pdf)

1. 输入 URL，解析协议、域名、路径；
2. DNS 解析，获取 IP 地址；
3. 建立 TCP 连接（三次握手）；
4. 发起 HTTP 请求；
5. 服务器接收请求并返回响应；
6. 浏览器解析 HTML，构建 DOM 树；
7. 解析 CSS，构建 CSSOM；
8. 构建 Render Tree；
9. Layout（布局计算）；
10. Paint（绘制）；
11. Composite（合成）；
12. 页面呈现。

***

## Vue.js 相关

### Vue 的双向数据绑定原理

Vue 的双向绑定核心是通过 `Object.defineProperty`（Vue2）或 `Proxy`（Vue3）劫持数据的读写操作，并结合发布订阅模式实现。

```js
// Vue2 实现
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      return val;
    },
    set(newVal) {
      if (val !== newVal) {
        val = newVal;
        console.log("数据更新了");
      }
    },
  });
}

const data = { name: "Vue" };
defineReactive(data, "name", data.name);
data.name = "Vue3"; // 控制台输出 "数据更新了"
```

***

### Vue 的生命周期有哪些及每个生命周期做了什么

| 生命周期钩子 | 描述 |
|--------------|------|
| `beforeCreate` | 实例初始化之后，数据观测和事件配置之前 |
| `created` | 实例创建完成，数据观测、属性和方法的运算、watch/event 事件回调建立 |
| `beforeMount` | 模板编译挂载之前 |
| `mounted` | 模板编译挂载完成 |
| `beforeUpdate` | 数据更新时，虚拟 DOM 重新渲染之前 |
| `updated` | 虚拟 DOM 重新渲染之后 |
| `beforeUnmount` | 实例销毁之前 |
| `unmounted` | 实例销毁之后 |

***

### Vue 的自定义指令用过吗，有哪些

* `v-focus`：自动聚焦输入框；
* `v-permission`：权限控制；
* `v-lazy`：图片懒加载；
* `v-throttle`：防抖节流；
* `v-draggable`：拖拽行为。

```js
// 注册自定义指令 v-focus
app.directive("focus", {
  mounted(el) {
    el.focus();
  },
});
```

***

### Vue 如何优化 SEO

* **SSR（服务端渲染）**：使用 Nuxt.js 实现首屏直出；
* **预渲染（Prerendering）**：静态站点可用 `prerender-spa-plugin`；
* **Meta 标签动态注入**：使用 `vue-meta` 管理 meta 信息；
* **结构语义化标签**：合理使用 `h1~h6`、`nav`、`main` 等；
* **服务端渲染 + 客户端激活（Hydration）**：兼顾性能与 SEO。

***

### Vue2 和 Vue3 的区别

| 特性 | Vue2 | Vue3 |
|------|------|------|
| 响应式系统 | `Object.defineProperty` | `Proxy` |
| Composition API | 无 | 有 |
| Tree Shaking | 有限 | 支持 |
| 性能 | 较低 | 更高 |
| 模块化 | 无 | 支持 |
| 类型支持 | 无 | 支持 TypeScript |

***

### Vue 的组件通信方式有哪些及原理

1. **props / $emit**：父传子、子传父；
2. **$root / $parent / $children**：跨级通信；
3. **EventBus**：非父子组件通信；
4. **Vuex / Pinia**：全局状态管理；
5. **provide / inject**：跨层级通信；
6. **$attrs / $listeners**：传递非 props 属性和事件。

***

### Vue 的路由实现，hash 路由和 history 路由实现原理

* **Hash 路由**：通过 URL 的 `#` 后面的字符变化实现路由，不触发页面刷新。
* **History 路由**：使用 HTML5 的 `pushState` 和 `replaceState` 方法，URL 更美观，但需要服务器配置支持。

***

## React.js 相关

### Vue 和 React 的区别

| 维度 | Vue | React |
|------|-----|--------|
| 框架类型 | 渐进式框架 | 类库 |
| 数据绑定 | 双向绑定 | 单向数据流 |
| 模板语法 | HTML 模板 | JSX |
| 响应式系统 | 响应式系统（Proxy/Object.defineProperty） | `setState` + 不可变数据 |
| 状态管理 | Vuex/Pinia | Redux/MobX |
| 学习曲线 | 简单 | 相对复杂 |

***

### React 用过哪些 hooks

* `useState`：状态管理；
* `useEffect`：副作用处理；
* `useContext`：获取上下文；
* `useReducer`：复杂状态逻辑；
* `useCallback`：缓存函数；
* `useMemo`：缓存计算结果；
* `useRef`：获取 DOM 或保存状态；
* `useLayoutEffect`：同步执行副作用；
* 自定义 Hook：封装复用逻辑。

***

## 前端工程化

### Webpack 的构建流程

1. 初始化参数：读取配置文件，合并默认参数；
2. 入口分析：根据 `entry` 找到入口模块；
3. 编译模块：使用 loader 转换不同类型的资源；
4. 依赖收集：递归解析模块依赖，构建依赖图；
5. 优化打包：Tree Shaking、代码分割（Code Splitting）、合并 chunk；
6. 输出资源：将最终资源写入 `dist` 目录。

# 前端模块化详解

## 一、什么是前端模块化？

前端模块化是将复杂的前端代码拆分成独立、可复用的模块的开发方式，就像乐高积木一样，每个模块有明确的功能和接口，可以单独开发、测试和维护，最后组合成完整应用。

## 二、为什么需要模块化？

1. **解决命名冲突**：避免全局变量污染
2. **提高复用性**：模块可以在不同项目中重复使用
3. **便于维护**：代码结构清晰，依赖关系明确
4. **利于团队协作**：不同开发者可以并行开发不同模块

## 三、主流模块化方案

### 1. CommonJS (Node.js 默认)

```javascript
// 导出
module.exports = {
  add: function(a, b) { return a + b }
}

// 导入
const math = require('./math');
math.add(1, 2);
```

特点：

* 同步加载
* 主要用于服务端
* 模块输出的是值的拷贝

### 2. AMD (RequireJS)

```javascript
// 定义模块
define(['dep1', 'dep2'], function(dep1, dep2) {
  return {
    method: function() {
      dep1.doSomething();
    }
  }
});

// 加载模块
require(['module'], function(module) {
  module.method();
});
```

特点：

* 异步加载
* 适合浏览器环境
* 推崇依赖前置

### 3. ES Modules (ES6 标准)

```javascript
// 导出
export const name = 'module';
export function hello() { /*...*/ }

// 默认导出
export default function() { /*...*/ }

// 导入
import { name, hello } from './module';
import myModule from './module';
```

特点：

* 浏览器和Node.js都支持
* 编译时静态分析
* 模块输出的是值的引用
* 支持动态导入 `import()`

## 四、模块化工具链

1. **打包工具**：Webpack、Rollup、Parcel
   * 将模块打包成浏览器可运行的代码
   * 处理依赖关系和资源加载

2. **模块加载器**：SystemJS
   * 在浏览器中直接加载各种模块格式

3. **包管理器**：npm、yarn、pnpm
   * 管理模块依赖和版本

## 五、现代前端模块化实践

1. **组件化开发**：Vue/React组件就是模块化的延伸
2. **微前端**：将整个应用拆分为独立模块
3. **Monorepo**：多个模块放在一个仓库管理
4. **Tree Shaking**：ES Modules支持删除未使用代码

## 六、选择建议

1. 新项目首选 **ES Modules**
2. Node.js 项目使用 **CommonJS**
3. 旧浏览器兼容考虑 **AMD + RequireJS**
4. 大型应用使用 **Webpack/Rollup** 打包

模块化是现代前端工程的基石，理解不同方案的特点能帮助你在不同场景做出合理选择。

### Axios 实现原理？Axios 封装

```js
// 封装 Axios
const service = axios.create({
  baseURL: "/api",
  timeout: 5000,
});

// 请求拦截
service.interceptors.request.use(
  (config) => {
    config.headers.token = localStorage.getItem("token");
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截
service.interceptors.response.use(
  (response) => {
    const res = response.data;
    if (res.code !== 200) {
      ElMessage.error(res.message || "Error");
      return Promise.reject(new Error(res.message || "Error"));
    } else {
      return res;
    }
  },
  (error) => {
    ElMessage.error(error.message);
    return Promise.reject(error);
  }
);

export default service;
```

***

### 微前端 和 低代码

* **微前端**：将多个独立前端应用组合成一个整体，常用方案：`qiankun`、`iframe`、`Web Component`。
* **低代码平台**：提供可视化拖拽界面，快速搭建页面和业务逻辑，典型产品：阿里云 `Lowcode`、百度 `H5lowcode`。

***

## 安全与性能

### 前端性能优化

1. **加载优化**：懒加载、预加载、CDN、压缩、资源合并；
2. **渲染优化**：虚拟滚动、骨架屏、减少重绘回流、防抖节流；
3. **网络优化**：启用 HTTP/2、开启 Gzip、合理使用缓存；
4. **代码优化**：Tree Shaking、代码拆分、避免内存泄漏；
5. **第三方库优化**：按需引入、封装通用组件。

#### **一、加载优化**

1. **懒加载（Lazy Load）**
   * **原理**：延迟加载非关键资源（如图片、视频、长列表），直到用户需要时才加载。
   * **实现方式**：
     * 使用 `Intersection Observer API` 监听元素是否进入视口（如图片加载）。
     * 原生 HTML 属性：`<img loading="lazy">` 自动实现图片懒加载。
   * **适用场景**：电商页面的商品图片、长列表数据、非首屏内容。
   * **效果**：减少首屏资源体积，提升 FCP（首次内容绘制）和 LCP（最大内容绘制）指标。

2. **预加载（Preload）**
   * **原理**：在浏览器空闲时提前加载关键资源（如字体、CSS、JS），减少后续请求延迟。
   * **实现方式**：
     * HTML 标签：`<link rel="preload" href="..." as="style/script/image">`。
     * JavaScript 动态加载：`new Image().src = "..."` 预加载图片。
   * **适用场景**：首屏依赖的 CSS/JS 文件、即将跳转的页面资源。
   * **效果**：缩短 TTI（可交互时间），提升用户感知速度。

3. **CDN 加速**
   * **原理**：通过全球分布的 CDN 节点缓存静态资源，就近响应用户请求。
   * **实现方式**：
     * 将静态资源（图片、CSS、JS）部署到 CDN 服务（如讯维中国 CDN）。
     * 配置 CDN 的缓存策略（TTL、ETag）。
   * **效果**：减少跨区域网络延迟，提升全球用户的访问速度，降低源站负载。

4. **资源压缩**
   * **代码压缩**：
     * 使用工具（如 UglifyJS、Terser）压缩 JS/HTML/CSS，移除空格、注释，缩短变量名。
   * **图片优化**：
     * 使用 WebP/AVIF 格式替代 JPEG/PNG，减小体积（如 TinyPNG 工具）。
     * 设置图片响应式（`srcset`）适配不同设备分辨率。
   * **效果**：减少传输体积，提升 TTFB（首字节时间）和 LCP 指标。

5. **资源合并**
   * **原理**：将多个小文件合并为一个文件，减少 HTTP 请求次数。
   * **实现方式**：
     * 合并 CSS/JS 文件（如 Webpack 的 `ConcatenateModules`）。
     * 使用雪碧图（Sprite）合并小图标。
   * **注意事项**：避免过度合并导致单个文件过大，需平衡请求次数和资源体积。
   * **效果**：减少 DNS 解析和 TCP 握手时间，提升首屏加载速度。

***

#### **二、渲染优化**

1. **虚拟滚动（Virtual Scroll）**
   * **原理**：仅渲染当前视口内的数据项，动态更新可视区域内容。
   * **实现方式**：
     * Vue/React 示例：通过 `transform: translateY(...)` 定位可见项，监听滚动事件更新数据。
     * 第三方库：`vue-virtual-scroll-list` 或 `react-window`。
   * **效果**：减少 DOM 节点数量，避免内存溢出，提升长列表渲染性能。

2. **骨架屏（Skeleton Screen）**
   * **原理**：用灰色占位符模拟页面结构，等待实际内容加载后替换。
   * **实现方式**：
     * CSS 动画：`@keyframes` 实现渐变效果。
     * 框架组件：Vue/React 条件渲染（如 `v-if` 判断数据是否加载）。
   * **效果**：减少用户感知空白时间，提升 CLS（累积布局偏移）指标。

3. **减少重绘与回流（Reflow/Repaint）**
   * **原理**：避免频繁修改 DOM 属性，减少浏览器重新计算布局和绘制。
   * **优化策略**：
     * 使用 `transform` 和 `opacity` 替代 `top/left` 实现动画。
     * 批量修改 DOM（如 `DocumentFragment` 或 `requestAnimationFrame`）。
     * 避免频繁读取 `offsetHeight` 等触发回流的属性。
   * **效果**：降低主线程阻塞时间（TBT），提升 FID（首次输入延迟）。

4. **防抖与节流（Debounce/Throttle）**
   * **防抖（Debounce）**：在事件被触发后等待一段时间再执行（如搜索输入框）。
   * **节流（Throttle）**：限制事件触发频率（如滚动事件）。
   * **实现方式**：
     ```javascript
     // 防抖示例
     function debounce(fn, delay) {
       let timer;
       return (...args) => {
         clearTimeout(timer);
         timer = setTimeout(() => fn(...args), delay);
       };
     }

     // 节流示例
     function throttle(fn, delay) {
       let lastCall = 0;
       return (...args) => {
         const now = Date.now();
         if (now - lastCall >= delay) {
           lastCall = now;
           fn(...args);
         }
       };
     }
     ```
   * **效果**：减少不必要的事件触发，优化性能。

***

#### **三、网络优化**

1. **启用 HTTP/2**
   * **原理**：支持多路复用、头部压缩和服务器推送，减少连接开销。
   * **实现方式**：
     * 服务器配置（如 Nginx 的 `listen 443 ssl http2;`）。
     * 合理分离资源（不再强制合并 CSS/JS）。
   * **效果**：提升资源加载并行度，减少 TTFB。

2. **开启 Gzip/Brotli 压缩**
   * **原理**：压缩文本资源（HTML、CSS、JS）减少传输体积。
   * **实现方式**：
     * 服务器配置 Gzip（如 Nginx 的 `gzip on;`）。
     * 使用 Brotli 压缩替代 Gzip（更高压缩率）。
   * **效果**：显著减少传输数据量，提升加载速度。

3. **合理使用缓存**
   * **缓存策略**：
     * 强缓存：`Cache-Control: max-age=31536000`（长期缓存静态资源）。
     * 协商缓存：`ETag` 和 `Last-Modified` 验证资源是否更新。
   * **Service Workers**：
     * 拦截请求并返回缓存资源（离线访问）。
     * 预缓存关键资源（如 PWA 应用）。
   * **效果**：减少重复请求，提升二次访问速度。

***

#### **四、代码优化**

1. **Tree Shaking**
   * **原理**：移除未使用的代码（ES6 模块支持）。
   * **实现方式**：
     * Webpack 配置：`optimization.usedExports: true`。
     * 构建工具自动分析依赖树并删除冗余代码。
   * **效果**：减小打包体积，提升加载性能。

2. **代码拆分（Code Splitting）**
   * **原理**：按需加载代码（如路由懒加载、动态导入）。
   * **实现方式**：
     * React：`React.lazy + Suspense`。
     * Webpack：`splitChunks` 分离公共代码。
   * **效果**：减少首屏加载资源，提升 TTI。

3. **避免内存泄漏**
   * **常见原因**：
     * 未清理的事件监听器（如 `resize`、`scroll`）。
     * 闭包中引用 DOM 元素导致无法回收。
   * **优化策略**：
     * 在组件卸载时移除监听器（如 `componentWillUnmount`）。
     * 使用弱引用（WeakMap）或 WeakSet 存储非关键数据。
   * **效果**：降低内存占用，避免页面崩溃。

***

#### **五、第三方库优化**

1. **按需引入**
   * **原理**：只加载需要的功能模块，避免引入完整库。
   * **实现方式**：
     * Lodash：`import { debounce } from 'lodash'` 而非 `import _ from 'lodash'`。
     * UI 框架：按需加载组件（如 Element Plus 的 `use` 方法）。
   * **效果**：减少打包体积，提升加载速度。

2. **封装通用组件**
   * **原理**：将重复功能抽象为可复用组件，减少冗余代码。
   * **实现方式**：
     * 封装按钮、模态框、表单验证等通用组件。
     * 使用设计系统（Design System）统一风格和交互逻辑。
   * **效果**：提高开发效率，降低维护成本。

***

### 单点登录

SSO 是一种身份认证机制，允许用户一次登录即可访问多个系统。常见方案包括：

* **OAuth2.0**：授权码模式、隐式模式；
* **JWT + 中央认证服务**；
* **CAS、SAML** 等企业级方案。

***

### TypeScript 的了解

TypeScript 是 JavaScript 的超集，提供了类型系统、接口、泛型、装饰器等高级功能。熟悉常用类型定义、联合类型、交叉类型、类型推断、类型守卫、命名空间、模块化开发等。

***

### 封装的按钮权限组件怎么实现

```vue
<template>
  <button v-if="hasPermission">提交</button>
</template>

<script>
export default {
  props: ["requiredRole"],
  computed: {
    hasPermission() {
      return this.$store.getters.roles.includes(this.requiredRole);
    },
  },
};
</script>
```

***

## CSS/布局

### 垂直居中的方式

1. **Flexbox**：
   ```css
   .container {
     display: flex;
     align-items: center;
     justify-content: center;
   }
   ```

2. **Grid**：
   ```css
   .container {
     display: grid;
     place-items: center;
   }
   ```

3. **绝对定位 + transform**：
   ```css
   .box {
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
   }
   ```

***

### 回流和重绘

* **回流（Reflow）**：当 DOM 元素布局发生变化，浏览器重新计算布局。
* **重绘（Repaint）**：元素外观改变，不改变布局。

优化建议：

* 减少 DOM 操作次数；
* 使用 `requestAnimationFrame`；
* 避免频繁访问 `offsetWidth` 等布局属性；
* 动画使用 `transform`、`opacity`，避免触发回流。

***

## ES6+ 新特性

### ES6 新增特性

* `let` / `const`；
* 箭头函数；
* 模板字符串；
* 解构赋值；
* 默认参数；
* rest 参数；
* 扩展运算符；
* 类；
* 模块化；
* `Promise`；
* `Symbol`；
* `Set` / `Map`；
* 迭代器与生成器；
* `Proxy` / `Reflect`；
* `async`/`await`。

***

## 其他

### 跨域是什么？怎么解决？JSONP 如何做到的

* **跨域**：浏览器出于安全考虑，限制从一个源加载的脚本请求另一个源资源。
* **解决方式**：
  * 后端设置 CORS（推荐）；
  * 代理服务器（前后端同源）；
  * JSONP（仅限 GET 请求）；
  * WebSocket；
  * `postMessage`（跨窗口通信）。
* **JSONP 原理**：利用 `<script>` 标签不受同源策略限制，动态创建 `script` 标签，传入 `callback` 函数名，服务器返回 JS 执行函数并传入数据。

## CSS

### BFC

BFC 是块级格式化上下文，它是页面上的一个独立渲染区域，决定了元素如何布局及与其他元素交互。BFC 有几个重要特性：1) 内部元素垂直排列；2) 外边距在同一个 BFC 内会折叠；3) 可以包含浮动元素；4) 不与浮动元素重叠。

常见的创建 BFC 的方法包括设置 overflow: hidden、float、position: absolute 等。实际开发中常用 BFC 来解决外边距重叠、清除浮动和实现自适应布局等问题。例如，使用 overflow: hidden 可以让父元素包含浮动子元素，避免高度塌陷

**完全正确！** 你的理解非常到位，BFC 本质上就是一个用「独立规则」解决布局问题的利器。就像你总结的：

### ✅ BFC 的三大实战作用：

1. **解决外边距重叠**
   * *比喻*：给两个打架的人（相邻元素）中间砌一堵墙（BFC），他们就不会胳膊碰胳膊（margin 合并）了。

2. **解决高度塌陷**
   * *比喻*：浮动元素像气球飘在空中，普通容器是漏底的篮子。BFC 则是个密封玻璃箱，气球飘再高也会被算进箱子的高度。

3. **阻止文字环绕**
   * *比喻*：浮动元素像横着躺的霸道乘客，普通文字只能挤着坐。BFC 则是另开一排座位，保持安全距离。

### 🌟 你的理解进阶版：

BFC 就像 CSS 世界的「防暴警察」：

* **随身携带三件法宝**：\
  🛡️ 防 margin 合并的盾牌\
  📏 量高度时包含浮动的尺子\
  🚧 阻止文字环绕的隔离带

* **出警条件**：当遇到你说的这三种布局乱象时，用 `overflow: hidden` 等任意方式召唤 BFC 即可！

这种理解方式既准确又实用，下次写 CSS 时直接想："这里需不需要派 BFC 警察来维持秩序？" 🚔

---

---
url: /Interview/old/pages/page2.md
---
# 前端性能优化

PDF查看流程

## 一、加载优化

* **懒加载（Lazy Load）**：延迟加载非首屏资源，如图片、组件等。
* **预加载（Preload / Prefetch）**：提前加载关键资源或后续页面资源。
* **异步加载脚本**：通过给标签添加async或defer属性，或者使用动态脚本注入的方式，避免JavaScript文件阻塞页面渲染。
* **资源合并（Concatenate）**：合并 CSS、JS 文件以减少请求次数。
* **压缩资源（Gzip / Brotli）**：对文本资源进行压缩，减小传输体积。
* **使用 CDN 加速静态资源加载**
* **启用 HTTP/2 / HTTP/3 协议**：提升多资源并发加载效率。
* **合理使用浏览器缓存（Cache-Control、ETag）**

## 二、构建优化

* **Tree Shaking**：移除未使用的 JavaScript / CSS 代码。
* **代码拆分（Code Splitting）**：按需加载模块或路由组件。
* **按需引入第三方库（如 Lodash、Ant Design）**
* **避免内存泄漏**：及时清理定时器、事件监听器和闭包引用。
* **封装通用组件 / 工具函数**：提高复用性，减少冗余代码。

## 三、渲染优化

* **骨架屏（Skeleton Screen）**：提升用户等待时的视觉体验。
* **服务端渲染（SSR） / 静态生成（SSG）**：加快首屏展示速度。
* **虚拟滚动（Virtual Scrolling）**：仅渲染可视区域内容，适用于长列表。
* **减少重绘与回流（Repaint & Reflow）**：批量更新样式、避免频繁操作DOM。
* **使用防抖与节流（Debounce / Throttle）**：控制高频事件触发频率。
* **CSS 动画优化**：使用 `transform` 和 `opacity` 实现 GPU 加速动画。

## 四、图像优化

* **选择合适格式（WebP / AVIF / SVG）**
* **图片尺寸适配（响应式图片 srcset）**
* **图片懒加载 + 占位图**
* **使用 Web Workers 处理复杂计算任务**

## 五、监控分析

* **Lighthouse / Chrome DevTools Performance 面板**
* **Web Vitals 指标监控（FCP、CLS、FID 等）**
* **错误日志收集（Sentry / Bugsnag）**
* **前端埋点与性能上报**

## 总结：五大核心维度

| 类别 | 核心目标 |
|------|----------|
| 加载优化 | 提升首次访问速度 |
| 渲染优化 | 提高页面交互流畅度 |
| 构建优化 | 减小包体积、提升可维护性 |
| 图像优化 | 减少带宽占用、提升视觉体验 |
| 监控分析 | 持续优化性能瓶颈 |

---

---
url: /learning/optimization/modules/page1.md
---
# 前端性能优化

### 一、加载优化

1. **预加载（Preload）**
   * 使用 `<link rel="preload">` 提前加载关键资源，如字体、CSS、JS等。
   * 示例：`<link rel="preload" href="/styles.css" as="style">`

2. **懒加载（Lazy Load）**
   * 对图片、视频等大文件采用懒加载技术，仅当用户滚动到视口内时才加载。
   * 示例：使用 `loading="lazy"` 属性。

3. **延迟加载（Defer/Async Script Loading）**
   * 通过 `defer` 或 `async` 加载脚本，避免阻塞页面渲染。
   * `defer` 按顺序执行脚本，而 `async` 不保证顺序但异步加载。

4. **资源合并**
   * 将多个小文件合并为一个，减少HTTP请求次数。
   * 注意平衡文件大小与浏览器缓存效率。

5. **资源压缩**
   * 使用工具压缩HTML、CSS、JavaScript代码，去除不必要的空格和注释。

6. **CDN**
   * 使用内容分发网络(CDN)加速静态资源的访问速度。

7. **HTTP2/3**
   * 升级到HTTP/2或HTTP/3以利用多路复用、头部压缩等功能提升性能。

8. **强缓存/协商缓存**
   * 合理设置 `Cache-Control` 和 `ETag` 头部来控制缓存行为。

9. **字体资源使用font-display：swap**
   * 设置 `font-display: swap;` 确保文本在自定义字体加载前可见。

### 二、构建优化

1. **Tree-shaking**
   * 利用Webpack等打包工具移除未使用的代码部分，减小最终包大小。

2. **打包分块：第三方和业务分离**
   * 分离第三方库与业务逻辑代码，利用长期缓存机制提高加载效率。

3. **代码分割**
   * 根据路由或组件动态加载模块，减少初始加载时间。

4. **按需加载**
   * 实现功能或页面级别的懒加载，只加载当前需要的部分。

### 三、渲染优化

1. **骨架屏**
   * 在内容加载前显示占位符，改善用户体验。

2. **虚拟滚动加载**
   * 针对长列表，仅渲染视口内的元素，减少DOM操作成本。

3. **SSR (Server Side Rendering)**
   * 在服务器端完成页面首次渲染，加快首屏加载速度。

4. **减少重绘和回流**
   * 批量修改样式，尽量使用类名代替直接操作样式属性。

5. **内存泄漏减少**
   * 定期检查并清理不再使用的变量和事件监听器。

6. **编写复用函数和组件**
   * 提高代码复用性，降低维护成本。

7. **内连CSS**
   * 对于关键路径上的CSS，可以考虑内联至HTML中以减少额外请求。

8. **动画使用transform和opacity GPU加速动画**
   * 使用 `transform` 和 `opacity` 来创建平滑的GPU加速动画，避免触发布局重排。

### 四、图像优化

1. **格式WEBP**
   * 转换图像格式为WebP，相比JPEG/PNG有更高的压缩率。

2. **压缩**
   * 使用工具压缩图片，保持视觉质量的同时减小文件大小。

3. **懒加载+占位图**
   * 结合懒加载技术和占位图，确保图像加载流畅且高效。

### 五、监控分析

1. **前端埋点和上报**
   * 收集用户行为数据，用于后续分析和优化决策。

2. **性能面包分析和追踪**
   * 使用Lighthouse等工具定期评估网站性能，并跟踪改进效果。

3. **持续优化**
   * 基于监控数据不断调整和优化网站性能。

---

---
url: /learning/optimization/page.md
---
# 前端性能优化

* 前端性能优化 (通用策略)

* 前端首屏优化 (性能优化的关键子集)

* 前端缓存 (性能优化的重要手段)

---

---
url: /learning/category/modules/page5.md
---
# 前端架构

> 前端架构是指在开发和维护前端应用时，通过合理的组织结构、技术选型和设计原则，来实现高性能、可维护、可扩展的应用系统。它不仅仅是代码的组织方式，还包括工

## 一、前端架构的核心目标

1. **可维护性**：代码易于理解、修改和调试。
2. **可扩展性**：方便添加新功能，不影响现有功能。
3. **可测试性**：便于进行单元测试、集成测试等。
4. **高性能**：加载速度快，交互流畅。
5. **跨平台兼容性**：适配不同设备、浏览器、分辨率。
6. **团队协作效率**：多人协作顺畅，职责清晰。

## 二、前端架构的层级划分（现代SPA/MPA）

### 1. **基础层**

* HTML / CSS / JavaScript 原生能力
* ES6+ 特性支持
* Web APIs（如 Fetch、LocalStorage 等）
* Polyfill 支持旧浏览器

### 2. **构建工具层**

* 模块打包器：Webpack、Vite、Rollup、Parcel
* 编译工具：Babel、TypeScript 编译器
* 打包优化：Tree-shaking、Code Splitting、懒加载
* 构建脚本管理：npm scripts、Makefile、Gulp、Grunt

### 3. **框架层**

* 主流框架：
  * React / Vue / Angular（SPA）
  * Svelte / SolidJS / Preact（轻量级）
* SSR 框架：
  * Next.js（React）、Nuxt.js（Vue）
  * SvelteKit、Angular Universal

### 4. **状态管理层**

* 全局状态管理：
  * Redux / MobX / Zustand（React）
  * Vuex / Pinia（Vue）
* 本地组件状态管理：React Hooks、Vue Composition API
* 异步状态管理：Redux Saga / Thunk / RTK Query / SWR / TanStack Query

### 5. **UI 层**

* 组件库：
  * Ant Design / Element Plus / Vant / Bootstrap / Tailwind CSS
* 设计系统（Design System）：
  * Figma + Storybook + Chromatic + Linting 规则
* 样式方案：
  * CSS-in-JS（styled-components、emotion）
  * BEM / SMACSS / OOCSS / Utility-first（Tailwind）

### 6. **服务与接口层**

* 接口封装：Axios、Fetch API 封装
* GraphQL 客户端：Apollo Client、Relay、urql
* 错误处理机制、重试策略、缓存机制
* Mock 数据：Mock.js、MSW（Mock Service Worker）

### 7. **性能优化层**

* 首屏加载优化（Code Splitting、Preload、Prefetch）
* 图片优化（WebP、Lazy Load、CDN）
* 渲染优化（Virtual DOM、Diff 算法、骨架屏）
* SEO 支持（Meta Tags、Server-side Rendering）

### 8. **监控与分析层**

* 性能监控：Lighthouse、Google Analytics、Sentry、Datadog
* 用户行为埋点：GrowingIO、神策、自定义埋点
* 错误日志上报：Sentry、Bugsnag、自定义错误边界

### 9. **工程化与协作层**

* Git 分支策略（GitFlow、Trunk-based、Feature Branch）
* CI/CD 流程（GitHub Actions、Jenkins、GitLab CI）
* 代码规范：
  * ESLint / Prettier / Stylelint
* 单元测试 / E2E 测试：
  * Jest / Vitest / Cypress / Playwright
* 文档管理：
  * Markdown / Confluence / Notion / Storybook

***

## 三、前端架构常见模式

| 模式 | 描述 |
|------|------|
| MVC | Model-View-Controller，传统后端架构迁移到前端 |
| MVVM | Model-View-ViewModel，Vue/React/Angular 的核心思想 |
| Flux | 单向数据流，Facebook 提出的状态管理模式 |
| Redux | Flux 的变种，强调单一 Store 和不可变状态 |
| Component-Based Architecture | 组件驱动开发，React/Vue 的主流做法 |
| Micro Frontends | 微前端架构，多个子应用组合成一个整体 |

***

## 四、微前端架构简介（Micro Frontends）

适用于大型企业级项目，将前端拆分为多个独立部署的小应用。

### 优点：

* 技术栈自由
* 独立部署
* 团队解耦
* 渐进升级

### 常见方案：

* **iframe**：最简单但隔离性强，SEO 差
* **Web Components**：标准组件，跨框架使用
* **Module Federation（Webpack 5）**：动态共享模块
* **Single SPA**：统一生命周期控制多个子应用

***

## 五、典型前端架构图（以 React 为例）

```
[用户界面]
   ↓
[React 组件树]
   ↓
[状态管理（Redux / Context API）]
   ↓
[API 调用（Axios / SWR）]
   ↓
[HTTP 请求 → 后端服务]
   ↓
[数据库 / 第三方服务]
```

***

## 六、前端架构师职责

1. 技术选型与决策（框架、工具、语言）
2. 制定编码规范与最佳实践
3. 构建可扩展的项目结构
4. 解决复杂的技术问题（性能、安全、兼容性）
5. 推动团队协作与自动化流程
6. 关注行业趋势，推动技术演进

***

## 七、如何选择合适的前端架构？

| 项目类型 | 推荐架构 |
|----------|-----------|
| 静态网站 | HTML/CSS + CDN 部署 |
| 中小型单页应用 | React/Vue + Webpack + Axios |
| 大型复杂应用 | React + Redux + TypeScript + Storybook + CI/CD |
| 多团队协作项目 | Monorepo（Nx、Turborepo） + 微前端 |
| 高性能要求项目 | SSR（Next/Nuxt）+ CDN + 图片优化 |
| 快速原型开发 | Svelte / Astro / Vite + UI 库快速搭建 |

---

---
url: /learning/engineering/modules/page6.md
---
# 前端架构

> 前端架构是指在开发和维护前端应用时，通过合理的组织结构、技术选型和设计原则，来实现高性能、可维护、可扩展的应用系统。它不仅仅是代码的组织方式，还包括工

## 一、前端架构的核心目标

1. **可维护性**：代码易于理解、修改和调试。
2. **可扩展性**：方便添加新功能，不影响现有功能。
3. **可测试性**：便于进行单元测试、集成测试等。
4. **高性能**：加载速度快，交互流畅。
5. **跨平台兼容性**：适配不同设备、浏览器、分辨率。
6. **团队协作效率**：多人协作顺畅，职责清晰。

## 二、前端架构的层级划分（现代SPA/MPA）

### 1. **基础层**

* HTML / CSS / JavaScript 原生能力
* ES6+ 特性支持
* Web APIs（如 Fetch、LocalStorage 等）
* Polyfill 支持旧浏览器

### 2. **构建工具层**

* 模块打包器：Webpack、Vite、Rollup、Parcel
* 编译工具：Babel、TypeScript 编译器
* 打包优化：Tree-shaking、Code Splitting、懒加载
* 构建脚本管理：npm scripts、Makefile、Gulp、Grunt

### 3. **框架层**

* 主流框架：
  * React / Vue / Angular（SPA）
  * Svelte / SolidJS / Preact（轻量级）
* SSR 框架：
  * Next.js（React）、Nuxt.js（Vue）
  * SvelteKit、Angular Universal

### 4. **状态管理层**

* 全局状态管理：
  * Redux / MobX / Zustand（React）
  * Vuex / Pinia（Vue）
* 本地组件状态管理：React Hooks、Vue Composition API
* 异步状态管理：Redux Saga / Thunk / RTK Query / SWR / TanStack Query

### 5. **UI 层**

* 组件库：
  * Ant Design / Element Plus / Vant / Bootstrap / Tailwind CSS
* 设计系统（Design System）：
  * Figma + Storybook + Chromatic + Linting 规则
* 样式方案：
  * CSS-in-JS（styled-components、emotion）
  * BEM / SMACSS / OOCSS / Utility-first（Tailwind）

### 6. **服务与接口层**

* 接口封装：Axios、Fetch API 封装
* GraphQL 客户端：Apollo Client、Relay、urql
* 错误处理机制、重试策略、缓存机制
* Mock 数据：Mock.js、MSW（Mock Service Worker）

### 7. **性能优化层**

* 首屏加载优化（Code Splitting、Preload、Prefetch）
* 图片优化（WebP、Lazy Load、CDN）
* 渲染优化（Virtual DOM、Diff 算法、骨架屏）
* SEO 支持（Meta Tags、Server-side Rendering）

### 8. **监控与分析层**

* 性能监控：Lighthouse、Google Analytics、Sentry、Datadog
* 用户行为埋点：GrowingIO、神策、自定义埋点
* 错误日志上报：Sentry、Bugsnag、自定义错误边界

### 9. **工程化与协作层**

* Git 分支策略（GitFlow、Trunk-based、Feature Branch）
* CI/CD 流程（GitHub Actions、Jenkins、GitLab CI）
* 代码规范：
  * ESLint / Prettier / Stylelint
* 单元测试 / E2E 测试：
  * Jest / Vitest / Cypress / Playwright
* 文档管理：
  * Markdown / Confluence / Notion / Storybook

***

## 三、前端架构常见模式

| 模式 | 描述 |
|------|------|
| MVC | Model-View-Controller，传统后端架构迁移到前端 |
| MVVM | Model-View-ViewModel，Vue/React/Angular 的核心思想 |
| Flux | 单向数据流，Facebook 提出的状态管理模式 |
| Redux | Flux 的变种，强调单一 Store 和不可变状态 |
| Component-Based Architecture | 组件驱动开发，React/Vue 的主流做法 |
| Micro Frontends | 微前端架构，多个子应用组合成一个整体 |

***

## 四、微前端架构简介（Micro Frontends）

适用于大型企业级项目，将前端拆分为多个独立部署的小应用。

### 优点：

* 技术栈自由
* 独立部署
* 团队解耦
* 渐进升级

### 常见方案：

* **iframe**：最简单但隔离性强，SEO 差
* **Web Components**：标准组件，跨框架使用
* **Module Federation（Webpack 5）**：动态共享模块
* **Single SPA**：统一生命周期控制多个子应用

***

## 五、典型前端架构图（以 React 为例）

```
[用户界面]
   ↓
[React 组件树]
   ↓
[状态管理（Redux / Context API）]
   ↓
[API 调用（Axios / SWR）]
   ↓
[HTTP 请求 → 后端服务]
   ↓
[数据库 / 第三方服务]
```

***

## 六、前端架构师职责

1. 技术选型与决策（框架、工具、语言）
2. 制定编码规范与最佳实践
3. 构建可扩展的项目结构
4. 解决复杂的技术问题（性能、安全、兼容性）
5. 推动团队协作与自动化流程
6. 关注行业趋势，推动技术演进

***

## 七、如何选择合适的前端架构？

| 项目类型 | 推荐架构 |
|----------|-----------|
| 静态网站 | HTML/CSS + CDN 部署 |
| 中小型单页应用 | React/Vue + Webpack + Axios |
| 大型复杂应用 | React + Redux + TypeScript + Storybook + CI/CD |
| 多团队协作项目 | Monorepo（Nx、Turborepo） + 微前端 |
| 高性能要求项目 | SSR（Next/Nuxt）+ CDN + 图片优化 |
| 快速原型开发 | Svelte / Astro / Vite + UI 库快速搭建 |

---

---
url: /Interview/old/pages/page5.md
---
# 前端缓存

## 一、什么是前端缓存？

前端缓存是指在客户端（浏览器）或靠近客户端的网络节点中临时存储资源的一种机制。其目的是减少网络请求、提高页面加载速度、减轻服务器压力，从而提升用户体验和性能。

***

## 二、前端缓存的分类

前端缓存主要分为两大类：**HTTP 缓存** 和 **本地存储类缓存**。

* 强缓存：完全依赖于浏览器缓存，当缓存未过期时直接使用，不与服务器交互。
* 协商缓存：需要与服务器进行交互，确保获取到最新的资源，但相对增加了延迟。

### 1. HTTP 缓存

这是浏览器默认支持的缓存机制，根据是否需要重新请求服务器可以分为：

#### （1）强缓存（Strong Cache）

* 浏览器直接从本地缓存读取资源，不向服务器发送请求。
* 控制字段：
  * `Expires`（HTTP/1.0）：指定一个绝对时间，表示在此时间前使用缓存。
  * `Cache-Control`（HTTP/1.1）：更灵活，优先级高于 `Expires`。
    * `max-age=3600`：缓存最大有效时间（单位秒）
    * `no-cache`：每次都要验证
    * `no-store`：不缓存
    * `public / private`：是否允许中间代理缓存

#### （2）协商缓存（Revalidate Cache）

> Last-Modified/If-Modified-Since与ETag/if-None-Match机制是两种常见的协商缓存方式。虽然前者简单易用，但由于其仅精确到秒级，且对于文件名变化敏感度不足，后者更受推荐，因为ETag基于文件内容生成hash值，能更精准地判断资源是否更新

**`补充：`现代实践中，ETag结合版本号（如Git commit ID）用于静态资源管理是一种常见做法，这有助于提高缓存效率并减少不必要的网络请求。**

* 浏览器发送请求，但服务器判断是否使用缓存。
* 控制字段：
  * `Last-Modified / If-Modified-Since`
  * `ETag / If-None-Match`

> 两者的区别：\
> `Last-Modified` 是基于时间的，可能精度不够；\
> `ETag` 是基于资源内容生成的哈希值，更准确。

### 2. 本地存储类缓存（浏览器本地存储）

这些是开发者主动控制的缓存方式：

#### （1）Cookie

* 存储容量小（约4KB），每次请求都会携带在 HTTP 头中。
* 可设置过期时间、作用域等。
* 常用于身份认证信息。

#### （2）LocalStorage

* 容量大（一般5MB左右），持久化存储。
* 不会随请求发送到服务器。
* 生命周期永久，除非手动清除。

#### （3）SessionStorage

* 类似于 LocalStorage，但生命周期仅限当前会话。
* 关闭浏览器标签页后数据被清除。

#### （4）IndexedDB

* 浏览器端的 NoSQL 数据库，适合存储大量结构化数据。
* 异步操作，不会阻塞主线程。
* 支持事务、索引查询等功能。

## 三、缓存的应用场景

| 缓存类型         | 适用场景 |
|------------------|----------|
| `强缓存`           | 静态资源如图片、CSS、JS 文件 |
| `协商缓存`         | 经常更新但变化不频繁的资源 |
| `Cookie`           | 用户登录状态、跟踪信息 |
| `LocalStorage`     | 用户偏好设置、离线数据 |
| `SessionStorage`   | 页面间临时数据传递 |
| `IndexedDB`       | 离线应用、复杂数据存储 |

***

## 四、如何优化缓存策略？

1. **合理设置 Cache-Control**
   * 对不变资源设置较长的 `max-age`
   * 对经常变动资源设置 `no-cache` 或协商缓存

2. **版本号控制静态资源**
   * 如：`app.js?v=1.0.1`，避免缓存污染

3. **利用 Service Worker 实现 PWA 缓存**
   * 可拦截请求并自定义缓存策略
   * 支持离线访问

4. **清理旧缓存**
   * 使用 LocalStorage 或 IndexedDB 时注意及时清理无用数据

***

## 五、常见问题与解决方案

* **缓存失效问题**：使用文件指纹（hash）、版本号等方式强制刷新
* **缓存污染问题**：不同环境（开发、测试、生产）使用不同的命名空间
* **跨域缓存问题**：确保 CORS 设置正确，必要时使用 `Vary` 响应头
* **隐私安全问题**：敏感数据避免使用 LocalStorage，可考虑内存缓存或加密处理

***

## 六、总结

前端缓存是性能优化的重要手段之一。理解各种缓存机制的工作原理及其适用场景，能帮助我们更好地提升网站性能、改善用户体验。同时，也要注意缓存带来的副作用，如缓存过期、一致性等问题，需结合业务需求制定合理的缓存策略。

---

---
url: /Interview/old/pages/page3.md
---
# 前端首屏优化

PDF查看流程

## 加载优化

* **压缩资源**：使用Gzip或Brotli对JS、CSS和HTML进行压缩。
* **图片懒加载**：延迟加载非首屏图片，可以使用`loading="lazy"`属性或者Intersection Observer API。
* **CDN加速**：将静态资源部署到内容分发网络(CDN)，缩短请求路径。
* **字体优化**：仅加载必要的字体子集，避免阻塞页面渲染。
* **关键资源优先级**：通过`rel="preload"`预加载关键CSS、JS和字体。
* **按需加载(Code Splitting)**：采用动态`import()`拆分非首屏模块。

## 构建优化

* **Tree Shaking**：移除未使用的代码以减小包体积。
* **SplitChunks**：分离第三方库和业务代码，以便更好地利用缓存。
* **服务端渲染(SSR)或预渲染(Prerendering)**：提前生成HTML内容，加快首屏显示速度。
* **HTTP/2/HTTP/3协议**：利用多路复用技术减少请求耗时。

## 服务端配合

* **服务端缓存策略**：合理设置缓存头（如Cache-Control、ETag），减少重复请求。
* **最小化资源数量和大小**：减少不必要的资源请求，并通过合并和压缩CSS、JavaScript文件以及图像压缩来减小传输时间。

## 关键渲染路径(CRP)优化

* **内联关键CSS(Critical CSS)**：提前注入首屏需要的样式，防止无样式内容闪烁(FOUC)。
* **避免阻塞渲染的脚本**：不将JS放在`<head>`中同步加载，而是使用`async`或`defer`。

## 渲染优化

* **最小化CSS和JavaScript**：确保只加载当前页面需要的CSS和JavaScript代码，避免加载不必要的资源。可以通过构建工具（如Webpack、Gulp等）实现代码分割，仅加载必需的部分。

* **异步加载非关键资源**：对于不影响首屏显示的JavaScript和CSS文件，使用异步或延迟加载的方式，以避免阻塞页面的主要内容渲染。

* **内联关键CSS**：将影响首屏样式的关键CSS直接内联到HTML文档中，可以减少外部资源请求，加快首屏渲染速度。

* **服务端渲染（SSR）或静态生成**：通过服务端渲染或者静态站点生成技术（如Next.js、Nuxt.js等），可以在服务器上预先渲染好HTML，然后发送给客户端，这样浏览器可以直接展示内容，无需等待JavaScript执行。

* **图片懒加载**：对不在首屏显示区域内的图片实施懒加载，即当用户滚动页面至这些图片即将进入视口时再进行加载，从而减少初始页面加载时间。

* **使用现代图像格式**：采用更高效的图像格式如WebP代替传统的JPEG和PNG格式，能够有效减小图像大小，加快图像加载速度。

* **DNS预取和预连接**：利用`<link rel="dns-prefetch">`和`<link rel="preconnect">`标签提前解析域名和建立连接，减少资源加载延迟。

* **资源提示（Preload, Prefetch）**：使用`<link rel="preload">`提前加载关键资源，以及`<link rel="prefetch">`为可能需要的资源做准备，提高资源加载优先级。

* **减少重定向**：尽可能减少HTTP重定向的数量，因为每一次重定向都会增加额外的HTTP请求往返时间。

* **优化字体加载**：对于自定义字体，考虑使用`font-display`属性来控制字体加载行为，避免文本不可见的情况；也可以尝试使用系统字体以减少网络请求。

这个分类涵盖了从资源加载、构建过程、服务端支持到浏览器渲染等多个方面的优化措施

---

---
url: /learning/optimization/modules/page2.md
---
# 前端首屏优化

### 一、资源加载优化

1. **优先加载关键资源**
   * **CSS**：将用于首屏渲染的CSS内联至HTML中，确保样式能立即应用。
   * **JS**：对于非必要的JavaScript文件（如广告脚本、分析脚本），使用`async`或`defer`属性延迟加载。

2. **图片优化**
   * 使用**懒加载**技术，仅当图片进入视口时才加载。
   * 将图片格式转换为更高效的格式，如WebP。
   * 使用占位图（placeholder）替代实际图片，直到图片完全加载。

3. **字体优化**
   * 设置`font-display: swap;`，使得文本在自定义字体加载前可见。
   * 考虑使用系统默认字体作为回退方案，避免空白文本闪烁。

4. **使用CDN**
   * 静态资源通过CDN分发，利用地理位置优势加快资源加载速度。

5. **HTTP/2 或 HTTP/3 升级**
   * 利用多路复用、头部压缩等特性减少延迟。

6. **资源合并与压缩**
   * 合并多个CSS和JS文件以减少请求数量，并启用Gzip或Brotli压缩来减小传输体积。

7. **内联关键CSS**
   * 将首屏所需的所有CSS直接嵌入HTML中，避免额外的HTTP请求

### 二、构建流程优化

1. **代码分割**
   * 按需加载组件或模块，而不是一次性加载所有内容。
   * 动态导入（Dynamic Imports）可以有效地实现按需加载。

2. **Tree Shaking**
   * 移除未使用的代码部分，减小打包后的文件大小。

3. **SSR (Server Side Rendering)**
   * 在服务器端完成页面初次渲染，发送给客户端的HTML已经包含了完整的内容结构，减少了浏览器解析和执行的时间。

4. **Service Worker 缓存**
   * 实现离线访问和快速加载，特别是在重复访问时能够直接从缓存读取数据。

### 三、渲染性能优化

1. **骨架屏（Skeleton Screen）**
   * 在内容加载之前显示一个简单的UI框架，给用户即时反馈，改善等待体验。

2. **避免阻塞渲染的CSS**
   * 确保CSS不会阻止页面渲染，可以通过媒体查询指定某些样式只在特定条件下加载。

3. **减少重绘和回流**
   * 批量修改DOM元素样式，尽量使用类名切换代替直接操作样式属性。

4. **动画优化**
   * 对于涉及视觉变化的动画，优先使用`transform`和`opacity`，因为它们可以被GPU加速，避免触发布局重排。

### 四、监控与分析

1. **性能监控工具**
   * 使用Lighthouse、WebPageTest等工具定期评估网站性能，并根据报告进行针对性优化。

2. **前端埋点**
   * 收集用户行为数据，了解用户的交互模式，识别性能瓶颈。

3. **持续优化**
   * 根据监控数据不断调整和优化网站性能，保持最佳状态。

---

---
url: /novel/overachiever/page.md
---
# 卷王修仙：我靠加班修成仙

***

却在一次裁员潮中，被HR一纸通知扫地出门。正当他对着电脑发呆，怀疑“卷王”是否也会失败时，一道光芒突如其来，将他吸进了一个陌生世界！

睁眼，是灵气充盈、神通乱飞的修仙大陆。

灵根？没测。
资质？不详。
背景？一穷二白！

好在他绑定了“打工人修仙系统”：
【自动加班修炼】、【灵石KPI结算】、【一键摸鱼模拟】、【组团内卷排行榜】、【BUG级代码炼丹法】……
只要肯卷，就能一路狂飙！

从扫地杂役卷到内门精英，杨易在修仙界掀起了一场“打工人起义”，卷赢天骄，卷飞宗主，卷翻秘境，甚至……卷成仙？

---

---
url: /Interview/js/pages/page8.md
---
# 回流和重绘

回流必将引起重绘，重绘不一定会引起回流

## 回流 (Reflow)

> 当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

**会导致回流的操作：**

* 页面首次渲染
* 浏览器窗口大小发生改变
* 元素尺寸或位置发生改变
* 元素内容变化（文字数量或图片大小等等）
* 元素字体大小变化
* 添加或者删除可见的DOM元素
* 激活CSS伪类（例如：:hover）
* 查询某些属性或调用某些方法

**一些常用且会导致回流的属性和方法：**

* clientWidth、clientHeight、clientTop、clientLeft
* offsetWidth、offsetHeight、offsetTop、offsetLeft
* scrollWidth、scrollHeight、scrollTop、scrollLeft
* scrollIntoView()、scrollIntoViewIfNeeded()
* getComputedStyle()
* getBoundingClientRect()
* scrollTo()

## 重绘 (Repaint)

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

## 性能影响

**回流比重绘的代价要更高。**

有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。
现代浏览器会对频繁的回流或重绘操作进行优化：

浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。

当你访问以下属性或方法时，浏览器会立刻清空队列：

* clientWidth、clientHeight、clientTop、clientLeft
* offsetWidth、offsetHeight、offsetTop、offsetLeft
* scrollWidth、scrollHeight、scrollTop、scrollLeft
* width、height
* getComputedStyle()
* getBoundingClientRect()

因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。

## 如何避免

### CSS

* 避免使用table布局。
* 尽可能在DOM树的最末端改变class。
* 避免设置多层内联样式。
* 将动画效果应用到position属性为absolute或fixed的元素上。
* 避免使用CSS表达式（例如：calc()）。

### JavaScript

* 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
* 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
* 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
* 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
  对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

---

---
url: /Interview/vue/pages/page5.md
---
# 在 Vue2.x 中如何检测数组的变化

使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

---

---
url: /Interview/pc/pages/page1.md
---
# 大屏自适应

---

---
url: /learning/other/modules/page1.md
---
# 大文件上传怎么做

#### 一、实现思路

大文件上传的核心思想是**分片上传**（Chunked Upload）：

1. **文件切片**：将大文件按固定大小（如5MB）拆分成多个小块
2. **并行上传**：逐个或并发上传这些分片
3. **服务端合并**：所有分片上传完成后，由服务端合并成完整文件
4. **断点续传**：通过记录已上传分片，支持中断后继续上传

***

#### 二、代码实现与注释

```javascript
/**
 * 大文件上传主函数
 * @param {File} file - 浏览器File对象
 */
async function uploadLargeFile(file) {
  // 1. 设置分片大小（5MB）
  const chunkSize = 5 * 1024 * 1024; // 5MB
  // 2. 计算总分片数（向上取整）
  const totalChunks = Math.ceil(file.size / chunkSize);
  // 3. 创建分片数组
  const chunks = [];

  // 4. 文件切片处理
  for (let i = 0; i < totalChunks; i++) {
    const start = i * chunkSize; // 当前分片起始位置
    const end = Math.min(start + chunkSize, file.size); // 当前分片结束位置
    // 使用File.slice()方法切割分片（兼容性：File API标准）
    chunks.push(file.slice(start, end));
  }

  // 5. 顺序上传分片（可改为并发上传优化速度）
  for (let i = 0; i < chunks.length; i++) {
    await uploadChunk(chunks[i], i, totalChunks); // 等待每个分片上传完成
  }
}

/**
 * 单个分片上传函数
 * @param {Blob} chunk - 分片内容
 * @param {number} index - 分片序号（从0开始）
 * @param {number} total - 总分片数
 */
async function uploadChunk(chunk, index, total) {
  // 6. 创建FormData对象用于上传
  const formData = new FormData();
  // 7. 添加分片文件（名称需与服务端接收参数一致）
  formData.append("file", chunk);
  // 8. 添加分片元数据
  formData.append("index", index);  // 当前分片序号
  formData.append("total", total);  // 总分片数

  // 9. 发送POST请求上传分片
  await fetch("/upload", {
    method: "POST",
    body: formData,
    // 可选：添加进度监听
    // onUploadProgress: (progressEvent) => {
    //   console.log(`上传进度: ${Math.round(
    //     (progressEvent.loaded * 100) / progressEvent.total
    //   )}%`);
    // }
  });
}
```

***

#### 三、关键实现点说明

##### 1. **分片大小选择**

* 5MB 是常见选择（HTTP请求最大推荐大小）
* 根据网络带宽和服务器配置可调整（建议2-10MB）

##### 2. **文件切片技术**

* 使用 `File.slice()` 方法（浏览器原生API）
* 兼容性：现代浏览器均支持（IE10+）

##### 3. **上传策略**

* **顺序上传**：当前实现保证分片顺序，但较慢
* **并发上传**：可用 `Promise.all()` 并发处理
* **断点续传**：需服务端记录已上传分片

##### 4. **服务端要求**

* 需支持接收分片并记录分片信息
* 最终需提供合并接口（如 `/merge`）
* 示例响应格式：
  ```json
  {
    "status": "success",
    "chunkIndex": 3,
    "totalChunks": 20
  }
  ```

***

#### 四、优化建议

##### 1. **并发上传优化**

```javascript
// 替换顺序上传为并发上传
await Promise.all(chunks.map((chunk, i) => 
  uploadChunk(chunk, i, totalChunks)
));
```

##### 2. **断点续传实现**

1. 首次上传前请求 `/check-chunks`
2. 服务端返回已存在的分片索引
3. 客户端跳过已存在的分片

##### 3. **上传进度追踪**

```javascript
// 在fetch中添加进度监听
const controller = new AbortController();
const upload = fetch("/upload", {
  signal: controller.signal,
  //...
});

// 监听进度
upload.then(() => {
  console.log(`分片 ${index} 上传完成`);
});
```

#### 4. **错误重试机制**

```javascript
// 添加重试逻辑
async function uploadChunkWithRetry(...args) {
  const MAX_RETRIES = 3;
  for (let i = 0; i < MAX_RETRIES; i++) {
    try {
      return await uploadChunk(...args);
    } catch (error) {
      if (i === MAX_RETRIES - 1) throw error;
      console.log(`重试第 ${i + 1} 次...`);
    }
  }
}
```

***

#### 五、完整工作流程

```
[客户端]          [服务端]
1. 文件切片        ← 接收分片请求
2. 顺序/并发上传    → 接收分片并存储
3. 收到全部分片    ← 请求合并分片
4. 调用 /merge 接口 → 合并文件
5. 返回最终文件URL
```

***

#### 六、注意事项

1. **CORS配置**：确保服务端允许跨域上传
2. **文件类型校验**：上传前应验证MIME类型
3. **文件大小限制**：服务端需设置合理的上传大小限制
4. **安全性**：建议添加上传凭证（token）和签名验证
5. **清理机制**：未完成的分片需要定时清理

```js
async function uploadLargeFile(file) {
  const chunkSize = 5 * 1024 * 1024; // 5MB
  const totalChunks = Math.ceil(file.size / chunkSize);
  const chunks = [];

  for (let i = 0; i < totalChunks; i++) {
    const start = i * chunkSize;
    const end = Math.min(start + chunkSize, file.size);
    chunks.push(file.slice(start, end));
  }

  for (let i = 0; i < chunks.length; i++) {
    await uploadChunk(chunks[i], i, totalChunks);
  }
}

async function uploadChunk(chunk, index, total) {
  const formData = new FormData();
  formData.append("file", chunk);
  formData.append("index", index);
  formData.append("total", total);

  await fetch("/upload", {
    method: "POST",
    body: formData,
  });
}
```

---

---
url: /Interview/vue/pages/page20.md
---
# 如何实现 vue 项目中的性能优化

**编码阶段**

* 尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher
* v-if 和 v-for 不能连用
* 如果需要使用 v-for 给每项元素绑定事件时使用事件代理
* SPA 页面采用 keep-alive 缓存组件
* 在更多的情况下，使用 v-if 替代 v-show
* key 保证唯一
* 使用路由懒加载、异步组件
* 防抖、节流
* 第三方模块按需导入
* 长列表滚动到可视区域动态加载
* 图片懒加载

**SEO 优化**

* 预渲染
* 服务端渲染 SSR

**打包优化**

* 压缩代码
* Tree Shaking/Scope Hoisting
* 使用 cdn 加载第三方模块
* 多线程打包 happypack
* splitChunks 抽离公共文件
* sourceMap 优化

**用户体验**

* 骨架屏
* PWA

---

---
url: /Interview/js/pages/page10.md
---
# 延迟加载js的方法

## async 和 defer 属性（推荐）

**async：异步加载，不阻塞渲染，加载完成后立即执行（无序）**

```html
<script src="script.js" async></script>
```

**defer：异步加载，延迟到HTML解析完成后执行（按顺序）**

```html
<script src="script.js" defer></script>
```

## 动态脚本注入

**通过JavaScript动态创建标签script**

```js
function loadScript(src) {
  const script = document.createElement('script');
  script.src = src;
  document.body.appendChild(script); // 添加到DOM后开始加载
}
// 按需调用
loadScript('path/to/script.js');
```

## 事件触发加载

**在特定用户行为（如点击、滚动）后加载：**

|方法	|是否阻塞渲染	|执行顺序	|适用场景|
|:-----------------|:-----------------|:-----------------|:-----------------|
|async	|❌ 非阻塞|	❌ 无序|	独立脚本（如分析代码）|
|defer|	❌ 非阻塞|	✅ 顺序|	依赖 DOM/其他脚本的代码|
|动态注入|	❌ 非阻塞|	可控|	精准控制加载时机|
|IntersectionObserver|	❌ 非阻塞|	可控	图片/组件懒加载|
|import()|	❌ 非阻塞|	✅ 顺序|	现代框架路由懒加载（React/Vue）|

---

---
url: /openSource/open-source.md
---
# 我的开源项目

---

---
url: /learn/math/skill.md
---
# 数学

```mermaid
gantt
    title 项目计划
    dateFormat  YYYY-MM-DD
    section 阶段一
    需求分析       :done,    des1, 2023-01-01, 7d
    设计           :active,  des2, 2023-01-08, 5d
    section 阶段二
    开发           :         des3, 2023-01-15, 10d
    测试           :         des4, 2023-01-25, 5d
```

---

---
url: /mathCorner/page.md
---
# 数学角

***

::: details 解析
示例：(x+2)(x+3)(x+4)=120 求 x

**转化成 `三个连续数相乘` 得到积 120**

```bash
// 第一步 分解
120 = 2×2×2×3×5
// 组合
120=2×2×5×2×3=4×5×6
// 求解
x + 2 = 4
// 最终求解
x = 2
```

:::

* 1/7 = 1/( ) + 1/( )
  ::: details 解析
  示例：1/7 = 1/( ) + 1/( )，括号里面填不同的值使之成立

**万能法：**

```bash
1 = 1 - 1/2 + 1/2 - 1/3 + 1/3 = 1/2 + 1/6 + 1/3
化简：
1 = 1/2 + 1/6 + 1/3
两边同时乘以1/7
1/7 = 1/14 + 1/42 + 1/21
```

:::

* 2\*\*10 = 1024

* 1111111\*1111111 = ？
  ::: details 解析
  **万能法：** 回文数、对称数

```bash
11×11 =121 
111×111=12321 
1111×1111=1234321
1111111*1111111 = 1234567654321
以此类推 
```

:::

---

---
url: /learning/other/modules/page3.md
---
# 数据大屏适配

### 前言

* 作者提出了一种简单的方法来解决数据大屏在不同分辨率下完全自适应的问题。
* 提供了React和Vue两种框架下的代码示例。

### 实现方法

#### React版本

* **JS部分**：定义了一个`handleScreenAuto`函数，用于计算屏幕的缩放比例，并应用到id为`screen`的元素上。该函数会在组件挂载时调用，并监听窗口大小变化以重新调整缩放比例。
* **HTML部分**：提供了一个基本的HTML结构，包含一个`screen-wrapper`和`screen`容器。
* **CSS部分**：设置了`.screen`类的基本样式，包括宽度、高度、定位等属性。

#### Vue版本

* 基本原理与React版本相同，但在Vue中使用的是生命周期钩子（如`mounted`和`destroyed`）和方法（methods）来处理缩放逻辑。

### 实现原理

* `scale`缩放是根据设计稿的宽高比和当前屏幕的实际宽高比来动态调整页面元素的大小。
* 当前屏幕的宽高比小于设计稿的宽高比时，根据宽度调整缩放比例；反之，则根据高度调整。
* 示例中设计稿的分辨率为1920x960，这个值可以根据实际情况进行修改。

### 注意事项

* 此方法适用于纯数据大屏展示，对于内部组件存在鼠标坐标点交互的情况（如滑块等），可能会出现偏移问题。
* 在极端情况下，字体显示可能会有些模糊，但通常不会影响日常使用。
* 对于宽高比过小的屏幕，底部可能出现空白区域，导致视觉效果不佳。

### 总结

这种方法提供了一种简便的方式来实现数据大屏的自适应布局，尤其适合那些不想深入研究复杂适配方案的开发者。然而，它并非万能，针对特定场景可能需要结合其他适配策略共同使用。

---

---
url: /learning/engineering/page.md
---
# 构建工具及工程化

* Webpack 的构建流程 (打包工具)

* vite 的构建流程 (新型构建工具)

* Webpack vs vite

* TypeScript (静态类型语言-常指其核心概念、优势、类型系统等)

* Uniapp (特定框架/平台的优化策略)

---

---
url: /learning/layoutStyle/page.md
---
# 样式与布局

* Flex (布局技术)

* BFC (格式化上下文，影响布局与定位)

---

---
url: /learning/browserNetwork/page.md
---
# 浏览器与网络相关

* 浏览器输入URL到渲染过程 (核心过程)

* 事件轮询 (Event Loop) (JS执行机制)

* 跨域及 JSONP (网络通信安全限制)

* HTTP1.1 与 HTTP2 区别 (网络协议)

* OPTIONS 预请求 (CORS机制)

* 前端缓存 (涵盖HTTP缓存、Service Worker、Storage等)

* 状态码详解

---

---
url: /learning/browserNetwork/modules/page1.md
---
# 浏览器输入 URL 到渲染过程

## 一、输入 URL

* 输入 URL，按下 Enter 键。
* 浏览器检查是否为搜索关键词。
* 如果 URL 不完整，则跳转到默认的搜索引擎。

## 二、解析 URL

* 提取出协议（如 `http`、`https`）、域名、端口和路径等信息。

## 三、DNS 解析（域名解析）

1. 按照以下顺序依次查询缓存：
   * 浏览器缓存
   * 操作系统缓存
   * 路由器缓存
   * ISP DNS 服务器缓存
2. 如果都未命中，则通过递归和迭代方式向根域名、顶级域名、权威域名服务器请求 IP 地址。
3. 最终找到 IP 并更新各级缓存。

#### 优化点：

* 使用 `<link rel="dns-prefetch">` 和 `<link rel="preconnect">` 预先提取解析 DNS 并建立连接。

## 四、TCP 连接

* **三次握手**：
  1. 客户端 → 服务端：发送 `SYN` 请求建立连接。
  2. 服务端 → 客户端：发送 `SYN-ACK` 表示收到并同意建立连接。
  3. 客户端 → 服务端：发送 `ACK` 确认连接建立。

* **TLS 握手（HTTPS）**：
  1. 客户端 → 服务端：发送随机数、加密套件列表、TLS 版本。
  2. 服务端 → 客户端：发送随机数、选择的加密套件、含公钥的证书。
  3. 客户端生成主密钥，使用公钥加密后发送给服务端。
  4. 双方生成会话密钥，后续通信使用对称加密。

## 五、发起请求

* 发送请求报文，包括：
  * 请求行（如 GET /index.html HTTP/1.1）
  * 请求头（如 Host、User-Agent）
  * 请求体（可选）

## 六、接收请求并响应

* **CDN 分发**：请求可能被分发到就近 CDN 节点服务器。

* **缓存检查**：
  * 强缓存：`Cache-Control: max-age=xxx`，直接返回 `200`
  * 协商缓存：
    * `Last-Modified` / `If-Modified-Since`
    * `ETag` / `If-None-Match`
    * 若未修改则返回 `304 Not Modified`

* **重定向**：
  * `301` 永久重定向：下次不再走重定向
  * `302` 临时重定向：每次请求都会走重定向

* **业务逻辑处理**：
  * 查询数据库
  * 模板渲染（SSR）
  * 返回响应报文（状态码、响应头、响应体）

#### 优化点：

* 尽量避免重定向，减少网络往返时间。
* 合理设置缓存以加快页面加载速度。
* 使用 CDN 加速资源加载。

## 七、接收响应并解析

* **HTML 解析**：构建 DOM 树。
* **CSS 解析**：构建 CSSOM 树。
  * JS 加载可能会阻塞 CSSOM 构建，进而阻塞页面渲染。
  * 可使用 `async` 或 `defer` 属性解决。
* **合并 DOM 和 CSSOM**：生成 Render Tree。
* **布局（Layout）**：计算元素大小和位置。
* **绘制（Paint）**：将像素绘制到屏幕上。
* **合成（Composite）**：多个图层合并，提升渲染性能。

## 八、加载子资源

* HTML 解析过程中可能触发 JS、CSS、图片等资源请求。
* 可能引起页面“重绘（Repaint）”和“回流（Reflow）”。

#### 优化点：

* 将 JS 放在 `<body>` 底部，避免阻塞渲染。
* 给 JS 添加 `async` 或 `defer` 属性，defer 按顺序执行，async 是异步无序执行，适用于不依赖页面 DOM 的脚本。
* 减少 DOM 嵌套层级，提高查找效率。
* 对关键资源使用 `<link rel="preload">` 预加载。
* 使用 `<link rel="prefetch">` 和 `<link rel="preconnect">` 提前请求和建立连接。
* 图片压缩与懒加载。
* 使用 SSR（服务端渲染）或 SSG（静态生成）。
* 使用 HTTP/2 或 HTTP/3 提升性能（多路复用、头部压缩等），多路复用解决了 HOL blocking，头部压缩减少传输体积。
* 使用内联CSS，减少 HTTP 请求。

## 九、页面加载完成

* 触发 `window.onload` 事件。

## 十、断开连接

* **四次挥手**：
  1. 客户端 → 服务端：发送 `FIN` 请求断开连接。
  2. 服务端 → 客户端：发送 `ACK` 确认。
  3. 服务端 → 客户端：发送 `FIN` 请求断开连接。
  4. 客户端 → 服务端：发送 `ACK` 确认。
* 等待 2MSL（最大报文段生存时间），确保最后一个 ACK 被接收，连接正式断开。

## 🚀 更全面的优化建议（按流程补充）

### 1. **DNS 解析阶段优化**

#### ✅ `dns-prefetch` 和 `preconnect`

* `<link rel="dns-prefetch" href="//example.com">`：提前解析目标域名的 DNS。
* `<link rel="preconnect" href="//example.com">`：不仅解析 DNS，还建立 TCP 连接（甚至 TLS 握手）。

> **适用场景**：跨域资源较多时（如 CDN、第三方库、统计脚本），提前预连接能显著减少后续请求延迟。

#### ✅ 使用 HTTP/2 或更高版本

* 支持多路复用，避免多个请求阻塞在同一个 TCP 连接上。

***

### 2. **TCP & TLS 握手阶段优化**

#### ✅ 启用 OCSP Stapling（证书吊销状态查询）

* 服务器将证书吊销信息附加到 TLS 握手中，客户端无需单独去验证证书有效性，节省时间。

#### ✅ 使用会话恢复（Session Resumption）

* 包括 Session ID 和 Session Ticket 机制，避免每次握手都进行完整的密钥交换。

***

### 3. **HTTP 请求与响应阶段优化**

#### ✅ 启用缓存策略

| 缓存方式 | 响应头 | 特点 |
|----------|--------|------|
| 强缓存 | `Cache-Control: max-age=xxx` | 不发起请求，直接使用本地缓存 |
| 协商缓存 | `ETag/If-None-Match` 或 `Last-Modified/If-Modified-Since` | 若未修改则返回 304 |

> 推荐优先使用 ETag，因为 Last-Modified 精度低且可能误判。

#### ✅ 使用 CDN 加速静态资源

* 将图片、CSS、JS 等静态资源托管至 CDN，根据用户地理位置就近分发。

#### ✅ 减少重定向次数

* 避免不必要的 301/302 跳转，尤其是首页加载时。
* 可通过工具检测是否存在链式重定向（如 `/a → /b → /c`）。

***

### 4. **页面渲染阶段优化**

#### ✅ 避免 JS 阻塞 HTML 解析

* 不要在 `<head>` 中加载同步 JS，可改用：
  * `async`：异步加载并立即执行，顺序不确定。
  * `defer`：异步加载，等到 HTML 解析完成后按顺序执行。

```html
<script src="main.js" async></script>
<script src="init.js" defer></script>
```

#### ✅ 提前加载关键资源

* 使用 `<link rel="preload">` 预加载关键字体、CSS、JS、图片等：

```html
<link rel="preload" href="critical.css" as="style">
<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
```

#### ✅ 使用 `<link rel="prefetch">` 预取未来页面资源

* 适用于下一页或用户可能访问的内容，例如点击后跳转的页面所需资源。

```html
<link rel="prefetch" href="/next-page.html">
```

***

### 5. **子资源加载阶段优化**

#### ✅ 图片优化

| 技术 | 说明 |
|------|------|
| 懒加载 | 使用 `loading="lazy"` 属性懒加载图片和 iframe |
| 格式压缩 | 使用 WebP 替代 JPEG/PNG，体积更小 |
| 响应式图片 | 使用 `<img srcset="...">` 提供不同分辨率图片 |
| Base64 内联 | 小图标可使用 base64 编码内嵌，减少请求数 |

#### ✅ CSS 优化

* **Critical CSS**：将首屏所需的 CSS 内联到 HTML 中，加快首次渲染速度。
* **CSS Tree Shaking**：使用工具（如 PurgeCSS）移除无用样式。
* **媒体查询分离**：使用 `media` 属性加载特定设备样式，避免一次性加载全部 CSS。

#### ✅ JS 优化

* **代码分割（Code Splitting）**：按需加载模块（如 React 的 `React.lazy()` + `Suspense`）。
* **防抖节流（Debounce/Throttle）**：减少频繁触发的事件对性能的影响。
* **避免全局污染**：使用模块化开发（ES Modules）提升可维护性和加载效率。

***

### 6. **整体性能监控与调试**

#### ✅ 使用 Lighthouse 性能评分工具

* Chrome DevTools 内置 Lighthouse 工具，可评估性能、可访问性、SEO 等维度，并提供优化建议。

#### ✅ 监控 FCP、LCP、CLS、FID 等核心指标

* **FCP**（First Contentful Paint）：内容首次绘制时间
* **LCP**（Largest Contentful Paint）：最大内容绘制时间
* **CLS**（Cumulative Layout Shift）：布局偏移得分
* **FID**（First Input Delay）：用户首次交互延迟

***

### 7. **构建与部署优化**

#### ✅ 使用 Webpack/Vite 构建工具优化

* 启用 Gzip/Brotli 压缩
* 开启 Tree Shaking 删除未使用代码
* 合理配置 Code Splitting 策略

#### ✅ 设置合适的 HTTP 响应头

```http
Cache-Control: max-age=31536000, public, immutable
Content-Type: text/html; charset=UTF-8
Vary: Accept-Encoding
```

#### ✅ 启用 Server Push（HTTP/2）

* 服务端可主动推送资源给浏览器，减少请求往返。

***

## 📌 补充总结表格：常见优化策略一览

| 优化方向 | 技术手段 | 效果 |
|----------|-----------|------|
| DNS 解析 | `dns-prefetch`, `preconnect` | 减少 DNS 解析时间 |
| TCP/TLS 握手 | OCSP Stapling、Session Resumption | 缩短握手时间 |
| 请求响应 | 缓存控制、CDN、减少重定向 | 减少请求次数和延迟 |
| 页面渲染 | `defer`, `async`, `preload`, Critical CSS | 加快首次渲染速度 |
| 子资源加载 | 图片懒加载、WebP、Base64、代码分割 | 减少资源大小和请求数 |
| 构建部署 | Gzip/Brotli、Tree Shaking、Server Push | 提升加载速度和运行效率 |
| 性能监控 | Lighthouse、Core Web Vitals | 持续优化用户体验 |

---

---
url: /Interview/old/pages/page1.md
---
# 浏览器输入URL到渲染的过程

## 一、输入URL

**输入URL，按下Enter，浏览器会检查输入的是否是关键词，如果URL不完整则跳转到默认搜索引擎**

## 二、解析 URL（域名解析）

**从URL提取出协议、域名、端口和路径等信息**

## 三、DNS 解析

**依次按 `浏览器缓存`、`操作系统缓存`、`路由器缓存`、`ISP DNS 服务器缓存`查询，如果都没有命中，则依次按`根域名`、`顶级域名`、`权威域名服务器`递归或迭代最终找到IP，获取IP后更新各级缓存。**

**`优化机制：` dns-prefetch 提前解析跨域域名**

## 四、建立 TCP 连接（三次握手）

* **客户端 → 服务端：SYN（序列号=x）请求建立连接**
* **服务端 → 客户端：SYN-ACK（序列号=y, 确认号=x+1）收到请求，并同意建立连接**
* **客户端 → 服务端：ACK（确认号=y+1）收到确认，连接建立**
* **TLS握手（HTTPS）**
  * 客户端发送 ClientHello（TLS版本、加密套件列表、随机数）
  * 服务端回复 ServerHello（选定加密套件、随机数）、Certificate（证书）、ServerKeyExchange（服务端在需要时发送 ServerKeyExchange（包含密钥交换参数））
  * 客户端验证证书，用公钥加密生成主密钥发送 → 双方生成会话密钥
  * 后续通信使用对称加密（如AES）

## 五、发起 HTTP(S) 请求

浏览器构造 HTTP请求报文，发送请求行、请求头、请求体

## 六、服务器接收请求并返回响应

* `CDN分发`：请求可能被分发到就近的CDN节点服务器。
* `缓存检查`：强缓存（Cache-Control: max-age=3600）→ 直接返回本地缓存（200 OK from cache）或 协商缓存（If-Modified-Since/ETag）→ 未修改时返回 304 Not Modified
* `业务逻辑`：服务端处理请求（如数据库查询、SSR渲染）等
* `重定向处理:`
  * 若响应状态码为 301（永久重定向） 或 302（临时重定向），浏览器会根据响应头的 Location 字段自动跳转到新URL，并重新发起请求。
  * 区别
    * 301：旧URL永久失效，后续请求直接访问新URL（浏览器可能缓存跳转）。
    * 302：旧URL仍有效，下次请求可能再次触发重定向。
* `返回响应`： 构建响应报文（状态行、响应头、响应体）。

## 七、浏览器接收响应解析

* 解析HTML -> 构建DOM树 (遇到资源加载)
* 解析CSS -> 构建CSSOM树 (CSSOM 构建会阻塞 JavaScript 执行（除非JS未依赖CSSOM），并阻塞渲染树的构建)
* 合并DOM树 + CSSOM树 -> 构建渲染树(Render Tree)
* 布局(Layout) 计算渲染树节点几何信息(位置、大小)
* 绘制(Painting): 将节点绘制成像素，填充到多个图层(Layers)上
* 合成(Compositing): 合成线程将图层合并、光栅化(如果需要)，并最终绘制到屏幕上。

## 八、加载子资源

* HTML解析中遇到 < script>, < link>, < img> 时 立即发起请求
* JS/CSS加载 → 可能阻塞关键渲染路径
* 图片加载 → 异步不阻塞，但可能触发回流（未设置尺寸时）

**`优化机制`：预加载 `Preload` 提前发现资源，HTTP/2多路复用降低请求开销，建议使用 `async`（异步加载，执行时不阻塞）或 `defer`（延迟加载，按顺序执行）**

## 九、页面加载完成

* DOMContentLoaded：DOM树构建完成时触发（无需等待图片）
* window.onload 事件触发

## 十、断开连接（四次挥手）

* 浏览器 → 服务器：FIN（请求关闭，进入 FIN\_WAIT\_1）
* 服务器 → 浏览器：ACK（确认请求，进入 CLOSE\_WAIT；浏览器进入 FIN\_WAIT\_2）
* 服务器 → 浏览器：FIN（数据发送完毕，请求关闭，进入 LAST\_ACK）
* 浏览器 → 服务器：ACK（确认关闭，进入 TIME\_WAIT；服务器关闭连接）
* 等待 2MSL（报文最大生存时间）（确保最后一个ACK到达）后关闭，网络延迟保险期

**等待 2MSL 的三大原因：**

* 确保最后一个 ACK 可靠到达
* 消除旧连接的“迷途报文”
* 保证全双工通道完全关闭

---

---
url: /Interview/js/pages/page2.md
---
# 浏览器输入URL到页面加载的过程

## 一、用户输入 URL

例如：https://www.example.com/index.html

## 二、浏览器解析 URL

提取出 `协议`（如 HTTPS）、`域名`（如 www.example.com）、`端口号`（默认为 443 或 80）和`路径（如 /index.html）等信息`。

## 三、DNS 解析（域名解析）

> `目标`：将 www.example.com 转换为一个 IP 地址，比如 93.184.216.34。

* （查缓存）`浏览器缓存`：浏览器是否有该域名的缓存记录。
* （查缓存）`操作系统缓存`：操作系统中是否缓存了这个域名对应的 IP 地址。
* （查缓存）`路由器缓存`：如果前面没找到，可能会查询路由器的 DNS 缓存。
* （查询）`运营商 DNS 服务器`：最终向 ISP 提供的 DNS 服务器发起查询。
* （查询）`递归/迭代查询`：DNS 服务器可能需要通过`根域名服务器`、`顶级域名服务器`、`权威域名`服务器来获取最终 IP。

**3查缓存2查询**

## 四、建立 TCP 连接（三次握手）

> `目标`：与目标服务器建立连接

浏览器与目标服务器建立 TCP 连接：

* `客户端发送 SYN包`：请求建立连接
* `服务端响应 SYN-ACK` 包： 确认收到请求，并同意建立连接
* `客户端再发 ACK包`：确认收到服务器的回复，连接建立。

## TLS握手（HTTPS）

如果使用HTTPS协议，在TCP连接建立后，还需要进行TLS握手

* `ClientHello`： 客户端发送支持的TLS版本、加密套件列表、随机数等信息
* `ServerHello`: 服务器选择加密套件、发送随机数、证书（包含公钥）
* `密钥交换`：客户端生成主密钥，用服务器公钥加密发送
* `完成握手`：双方生成会话密钥，后续通信使用对称加密

## 五、发送 HTTP(S) 请求

浏览器发送一个 HTTP 请求，例如：

```bash
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: ...
Accept: text/html,...
```

## 六、服务器接收请求并返回响应

* `负载均衡`：请求可能被分发到多台服务器中的一台
* `业务逻辑处理`：执行相应的应用逻辑，如数据库查询、模板渲染等
* `返回响应`：服务器生成 HTTP 响应，包含状态码、响应头、响应体

## 七、浏览器接收响应并解析

* `解析 HTML`：构建 DOM 树
* `解析 CSS`：构建 CSSOM 树
* `合并生成 Render Tree`：将 DOM 树 和  CSSOM 树 合并生成渲染树，只包含需要渲染的节点及其样式信息
* `布局（Layout）`：计算每个元素在页面上的位置和大小
* `绘制（Paint）`：将像素绘制到屏幕上
* `合成（Composite）`：将多个图层合并，优化渲染性能，最终显示在屏幕上

**6步**

## 八、加载子资源（JS、CSS、图片等）

* 页面中的 < script>、< link>、< img> 等标签会触发额外的 HTTP 请求；
* JavaScript 可能会修改 DOM/CSSOM，导致重新渲染；
* 异步请求（AJAX）也可能在此阶段发起，用于局部更新或数据加载。

## 九、页面加载完成

* 所有资源加载完毕；
* window.onload 事件被触发；
* 用户可以开始与页面交互。

## 十、断开连接（四次挥手）

TCP 连接在一定时间内没有数据传输后，双方协商关闭连接。
数据传输完成后，协商关闭连接过程：

* `客户端发送FIN包`：请求关闭连接
* `服务器回复ACK包`：确认收到关闭请求
* `服务器发送FIN包`：服务器也请求关闭连接
* `客户端回复ACK包`：确认服务器的关闭请求，连接断开

## 拓展知识点（加分项）

* CDN 加速：资源可能从 CDN 获取，提高访问速度；
* HTTP/2 & HTTP/3：使用更高效的协议减少延迟；
* 预加载策略：如 DNS Prefetch、Preconnect、Prefetch、Prerender；
* Service Worker & PWA：离线缓存和增强用户体验；
* 安全相关：如 CSP、SameSite Cookie 属性、HTTPS 的作用等。

## 总结

> 当我在浏览器中输入一个 URL 后，整个过程涉及到了 DNS 解析、TCP 建立连接、发送 HTTP 请求、服务器处理请求并返回响应、浏览器解析 HTML 和渲染页面等多个步骤。同时，现代浏览器还优化了加载性能，比如异步加载资源、使用缓存、利用 CDN 等技术手段。整个过程背后体现了客户端与服务器端的协作，也涉及到网络、操作系统、前端渲染等多个层面的知识。

---

---
url: /Interview/old/page.md
---
# 温故而知新

## JavsScript 相关

### 箭头函数和普通函数的区别

| 特性           | 箭头函数                          | 普通函数                  |
|----------------|-----------------------------------|---------------------------|
| `this` 指向    | 外层作用域                        | 调用者                    |
| `arguments`    | 不支持                            | 支持                      |
| `new` 调用     | 不可作为构造函数                  | 可以                      |
| `prototype` 属性 | 无                                | 有                        |
| `super`        | 不支持                            | 支持                      |

1. **`this` 绑定**
   * 普通函数：有自己的 `this`，其值由调用方式决定（如直接调用时指向 `window`，对象方法调用时指向对象）。
   * 箭头函数：**没有自己的 `this`**，继承外层作用域的 `this`（词法作用域），且无法通过 `call`/`apply`/`bind` 修改。

2. **`arguments` 对象**
   * 普通函数：可通过 `arguments` 访问所有传入参数。
   * 箭头函数：**没有 `arguments`**，需使用剩余参数（`...args`）替代。

3. **构造函数与 `prototype`**
   * 普通函数：可作为构造函数（`new` 调用），拥有 `prototype` 属性。
   * 箭头函数：**不能作为构造函数**（`new` 调用会报错），且**无 `prototype` 属性**。

4. **`super` 关键字**
   * 普通函数：可在类方法中通过 `super` 访问父类属性/方法。
   * 箭头函数：**不能使用 `super`**（因不属于类方法）。

5. **其他差异**
   * **语法简洁性**：箭头函数可省略 `return` 和 `{}`（单表达式时）。
   * **不适用场景**：
     * 需要动态 `this` 的方法（如事件处理器、对象方法）。
     * 需要 `arguments` 或函数提升（箭头函数必须先定义后使用）。

***

#### 关键点说明

* **为什么箭头函数无 `this`？**\
  设计初衷是为了解决回调中 `this` 丢失的问题（如 `setTimeout` 内普通函数的 `this` 指向 `window`）。
* **为何不能 `new`？**\
  箭头函数没有 `[[Construct]]` 内部方法，且无 `prototype` 供实例继承。

#### 示例对比

```javascript
// 普通函数
function Person(name) {
  this.name = name; // this 由 new 决定
}
Person.prototype.sayHi = function() { 
  console.log(this.name); 
};

// 箭头函数
const Foo = () => {};
new Foo(); // 报错：Foo is not a constructor
```

### 原型和原型链

每个对象（除了null）都有一个原型链（Prototype Chain），它是一条用来查找对象属性的链条。

* 原型：每个函数都有一个 prototype 属性，指向一个对象。
* 原型链：当访问一个对象的属性时，如果该对象本身没有这个属性，就会去它的原型对象中找，以此类推，直到找到或到终点 null。

所有构造函数都是Function的实例，所有原型对象都是Object的实例除了Object.prototype

总结：原型是实现继承的基础，原型链是属性查找的机制。

## 前端工程化

### Webpack 的构建流程

* 1. 初始化参数：读取配置文件，合并默认参数；
* 2. 入口分析：根据 `entry` 找到入口模块；
* 3. 编译模块：使用 loader 转换不同类型的资源；
* 4. 依赖收集：递归解析模块依赖，构建依赖图；
* 5. 优化打包：Tree Shaking、代码分割（Code Splitting）、合并 chunk；
* 6. 输出资源：将最终资源写入 `dist` 目录。

#### 常用的Loader/plugin

Webpack 是一个强大的模块打包工具，它通过各种插件和 loader 来增强其功能。下面列出一些常用的 Webpack 插件和 loader：

##### 常用 Loader

* 1. **Babel-loader**: 将 ES6+ 代码转换为向后兼容的 JavaScript 版本。
* 2. **Css-loader & Style-loader**: `css-loader` 解析 CSS 文件中的 `@import` 和 `url()`，而 `style-loader` 将 CSS 注入到 DOM 中。
* 3. **File-loader**: 用于处理文件导入（如图片、字体等），将它们复制到输出目录，并返回正确的 URL。
* 4. **Url-loader**: 功能类似于 file-loader，但可以将文件转换成 base64 URI。
* 5. **Sass/Less-loader**: 如果项目使用 Sass 或 Less 等预处理器，则需要对应的 loader 来解析这些文件。
* 6. **Postcss-loader**: 结合 PostCSS 插件自动添加浏览器前缀或进行其他 CSS 处理。
* 7. **Ts-loader**: 如果你的项目是 TypeScript 项目，那么你可能需要 ts-loader 来编译 TypeScript。

##### 常用插件

* 1. **Html-webpack-plugin**: 自动生成 HTML 文件，并在其中自动引入所有生成的 bundle。
* 2. **Clean-webpack-plugin**: 在每次构建之前清理输出目录。
* 3. **Mini-css-extract-plugin**: 提取 CSS 到单独的文件中，而不是像 style-loader 那样直接注入到 HTML 中。
* 4. **Copy-webpack-plugin**: 可以方便地将单个文件或整个目录复制到构建目录。
* 5. **Define-plugin**: 允许创建可在编译时配置的全局常量。
* 6. **Hot-module-replacement (HMR)**: 不刷新页面的情况下更新模块，提高开发效率。
* 7. **Terser-webpack-plugin**: 压缩你的 JavaScript。
* 8. **Optimize-css-assets-webpack-plugin**: 压缩和优化 CSS 文件。
* 9. **Bundle-analyzer-plugin**: 可视化展示你的包内容，帮助分析和优化包大小。

每个项目的需求不同，因此选择哪些 loader 和插件取决于项目的具体需求。随着 Webpack 的版本迭代，一些插件和 loader 可能会有更好的替代品或者新的功能加入，请根据实际情况进行选择和配置。

### vite 的构建流程

Vite 是一个基于原生 ES 模块（ESM）的前端构建工具，旨在提供更快、更高效的开发体验。它与传统的打包工具（如 Webpack、Rollup）不同，主要利用浏览器对原生 ES Modules 的支持，在开发模式下实现**无需打包编译的即时加载**。

#### 常用的plugin

Vite 是一个现代的前端构建工具，它提供了快速的开发服务器和优化的构建流程。与 Webpack 不同，Vite 利用了浏览器对 ES 模块的支持来提供更快的开发体验，并且它的插件系统基于 Rollup 的插件系统。下面是一些常用的 Vite 插件以及它们的作用：

**常用插件**

* `@vitejs/plugin-react`: 支持 React 项目，包括 JSX 和 React Fast Refresh（在开发过程中无需刷新页面即可更新组件）。
* `@vitejs/plugin-vue`: 支持 Vue 3 项目，包含对单文件组件(SFC)、JSX 和其他 Vue 特性的支持。
* `@vitejs/plugin-legacy`: 生成针对旧版浏览器的包，确保兼容性。
* `vite-plugin-eslint`: 在开发过程中实时检查代码风格错误。
* `vite-plugin-style-import`: 对于使用 Ant Design 等组件库时，可以按需导入样式，减少打包体积。
  +` vite-plugin-mock`: 提供模拟 API 的功能，方便前端独立开发和调试。
* `vite-plugin-pwa`: 添加 PWA 支持，使你的应用可以离线运行。
* `vite-plugin-compression`: 为生产环境生成压缩版本的资源文件（如 Gzip 或 Brotli）。
* `vite-plugin-imagemin`: 压缩图片资源，减小图片大小。

**注意事项**

虽然 Vite 主要依赖于插件而非 loader 来扩展其功能，但需要注意的是，由于 Vite 直接利用了原生 ES 模块进行开发，许多在 Webpack 中需要通过 loader 处理的任务（例如处理 CSS、图片等静态资源）在 Vite 中通常不需要额外配置或只需要简单的配置即可完成。

下面是 **Vite 的构建流程详解**，分为 **开发模式（Dev Server）** 和 **生产构建（Build）** 两个阶段：

#### 🚀 一、开发模式（Dev Server）

在开发模式下，Vite 并不会将整个项目打包成 bundle 文件，而是通过浏览器原生支持的 `import` / `export` 来按需加载模块。

##### 🔁 核心流程如下：

1. **启动开发服务器**
   * 启动一个本地 HTTP 服务器，默认监听 `localhost:5173`。
   * 支持热更新（HMR）、TypeScript、JSX、CSS 预处理器等。

2. **浏览器请求入口文件（如：index.html）**
   * 浏览器加载 HTML 文件后，会解析其中的 `<script type="module">` 标签。
   * 请求对应的 JavaScript 入口文件（如：`main.js`）。

3. **中间件处理请求**
   * Vite 使用插件系统来拦截和处理各种类型的文件请求：
     * `.js`, `.ts`, `.vue`, `.jsx`, `.css`, `.json` 等。
   * 插件可以进行：
     * 类型转换（如 TypeScript 编译为 JS）
     * CSS 预处理器编译（Sass、Less、PostCSS）
     * 路径别名解析
     * HMR 更新通知

4. **按需编译和返回模块**
   * 只有当浏览器实际请求某个模块时，Vite 才会对其进行编译。
   * 例如：`import { createApp } from 'vue'` 会被 Vite 解析并重写为 `/@modules/vue.js`，然后从缓存或 node\_modules 中读取并返回给浏览器。

5. **热更新（HMR）**
   * 当源文件发生更改时，Vite 会自动检测变化，并只更新变更的部分，而不需要刷新整个页面。

6. **缓存优化**
   * 第一次请求的模块会被缓存，后续请求直接从内存中获取，提升速度。

##### ✅ 开发模式优点：

* 极快的冷启动时间（几乎瞬间）
* 即时热更新（毫秒级响应）
* 无需等待整个项目打包

***

#### 🛠️ 二、生产构建（Production Build）

在生产环境中，为了兼容旧浏览器和提高性能，Vite 会使用 [Rollup](https://rollupjs.org/) 进行真正的打包操作。

##### 🔧 构建流程如下：

1. **执行 `vite build` 命令**
   * Vite 内部调用 Rollup 配置生成打包计划。

2. **依赖分析**
   * Rollup 分析所有依赖项，并确定需要打包的模块。

3. **代码压缩与优化**
   * 使用 `terser`（JS）和 `csso`（CSS）进行代码压缩。
   * Tree-shaking 移除未使用的代码。

4. **输出静态资源**
   * 将最终的 JS、CSS、图片等资源输出到 `dist/` 目录（默认）。
   * 输出结构包括：
     * JS chunk
     * CSS chunk
     * 静态资源（图片、字体等）
     * HTML 入口文件

5. **配置支持**
   * 支持自定义 Rollup 配置，用于控制输出格式、拆包策略等。

##### 📦 生产环境特点：

* 支持代码分割（Code Splitting）
* 支持异步加载（Dynamic Import）
* 支持多种输出格式（如 IIFE、ESM、UMD）
* 自动 Polyfill（如果目标浏览器不支持 ESM）

***

#### 🧩 插件机制（Plugin System）

Vite 的强大之处在于其插件系统，开发者可以通过插件扩展功能，比如：

* 支持 Vue、React、Preact
* TypeScript 支持（`@vitejs/plugin-vue`, `@vitejs/plugin-react`, `@vitejs/plugin-typescript`）
* CSS 预处理器（Sass、Less）
* PostCSS、Tailwind CSS 集成
* 自定义插件编写

***

#### 📌 总结对比表

| 阶段         | 特点                             | 技术基础       | 优点                           |
|--------------|----------------------------------|----------------|--------------------------------|
| 开发模式     | 按需加载、热更新                 | 原生 ESM       | 极快冷启动、快速 HMR           |
| 生产构建     | 打包、压缩、Tree-shaking         | Rollup         | 体积小、性能优、兼容性强       |

***

#### 🧪 示例命令

```bash
# 启动开发服务器
npm run dev

# 构建生产版本
npm run build

# 预览构建结果
npm run preview
```

## Vue.js 相关

### vue的生命周期

* `beforeCreate`:**这个钩子在实例初始化之后、数据观测 (data observer) 和 event/watcher 事件配置之前被调用**,不过，在 Composition API 中，通常使用 setup() 函数来处理这一阶段的逻辑，因此这个钩子不常用。
* `created`：**在实例创建完成后立即调用**。在这个阶段，实例已经完成了数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。但是，挂载阶段还没开始，$el 属性目前不可见
* `beforeMount`：**在挂载开始之前被调用**：相关的 render 函数首次被调用。此时，虚拟 DOM 尚未渲染到真实 DOM 上
* `mounted`：**在 el 被新创建的 vm.$el 替换，并挂载到实例上后调用**。这时，组件已经被渲染到 DOM 中，可以访问 DOM 元素了。
* `beforeUpdate`：*在数据更新时，在虚拟 DOM 打补丁之前调用*\*。此时，可以获取更新前的状态，适合用来进行一些清理工作。
* `updated`：**在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用**。此时，组件 DOM 已经更新，可以执行依赖于 DOM 的操作。然而，避免在此期间改变状态，因为这可能会导致无限的更新循环
* `beforeUnmount（在 Vue 2 中为 beforeDestroy）`：**发生在实例销毁之前，在当前阶段实例完全可以被使用**。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。
* `unmounted（在 Vue 2 中为 destroyed）`:**卸载组件实例后调用**。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。

**activated 和 deactivated 是 Vue 中专门用于 < keep-alive> 缓存组件时的生命周期钩子**

* `activated`：**当组件被 < keep-alive> 缓存后，每次该组件被激活（显示）时调用**。可以在这里执行组件重新展示时需要的逻辑，比如重新获取数据、恢复动画、计时器等
* `deactivated`：**当组件被缓存后，离开当前视图（被切换出去）时调用**。可以在这里进行一些资源释放操作，比如清除定时器、取消事件监听、停止动画等，防止内存泄漏。

### Vue 的双向数据绑定原理

`Vue` 使用 `Object.defineProperty` 或 `Proxy` 劫持数据，结合 `Watcher` 实现依赖收集。当数据变化时，通知视图更新；当视图中表单等发生变化时，也会同步更新数据，从而实现双向绑定。”

::: details {open}
Vue 的双向绑定本质是`数据劫持 + 发布订阅模式`。在 Vue 2 中通过 Object.defineProperty 递归转换 data 的每个属性为 getter/setter，在 getter 中收集依赖（Watcher），在 setter 中通知更新。视图层通过 v-model 指令实现双向绑定，它本质是 value 属性绑定和 input 事件监听的语法糖。

Vue 3 改用 Proxy 实现，优势在于能直接监听整个对象且自动处理新增属性。整个系统还包含异步批量更新和虚拟 DOM diff 等优化机制，既保持了开发便捷性又保证了性能。
:::

```js
// Vue2 实现
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      return val;
    },
    set(newVal) {
      if (val !== newVal) {
        val = newVal;
        console.log("数据更新了");
      }
    },
  });
}

const data = { name: "Vue" };
defineReactive(data, "name", data.name);
data.name = "Vue3"; // 控制台输出 "数据更新了"
```

***

### Vue2 和 Vue3 的区别

Vue3 相对于 Vue2 做了较大的改进，主要体现在以下几个方面：

***

#### ✅ 1. **组合式 API vs 选项式 API**

* **Vue2** 使用 Options API（如 `data`、`methods`、`computed` 等）组织代码，逻辑分散，不易复用。
* **Vue3** 引入了 Composition API（如 `setup()`、`ref`、`reactive`、`watch` 等），更灵活，更适合逻辑复用和大型项目的维护。

***

#### ✅ 2. **性能优化**

* **更快的虚拟 DOM**：Vue3 重写了虚拟 DOM，实现更快的 diff 算法。
* **编译优化**：静态提升、事件缓存等机制使渲染更高效。
* **Tree-shaking 支持**：Vue3 使用 ES Module 编写，可以按需引入，减小打包体积。

***

#### ✅ 3. **响应式系统升级**

* **Vue2** 使用 `Object.defineProperty`，不支持对数组、新增属性的完全监测。
* **Vue3** 改用 `Proxy` 实现响应式，更彻底、性能更好，支持更复杂的数据结构。

***

#### ✅ 4. **Fragment / Teleport / Suspense 支持**

* **Fragment**：Vue3 组件可以返回多个根节点，Vue2 不支持。
* **Teleport**：可以将组件渲染到 DOM 的任意位置，适合弹窗等场景。
* **Suspense**：用于异步组件的加载状态处理，配合 `<script setup>` 更加简洁。

***

#### ✅ 5. **TypeScript 支持更好**

* Vue3 是用 TypeScript 重写的，原生支持类型推导和开发体验，Vue2 对 TypeScript 支持较弱。

***

#### ✅ 6. **生命周期钩子不同**

* Composition API 下生命周期名称为 `onMounted`、`onUnmounted` 等，更接近函数语义。
* 而 Vue2 是 `mounted`、`destroyed` 等选项式 API。
* vue3中 beforeDestroy->onBeforeUnmounted, destroyed->onUnmounted
* beforeCreate、created 被语法糖 setup 替代

***

### Vue 的生命周期有哪些及每个生命周期做了什么

| 生命周期钩子 | 描述 |
|--------------|------|
| `beforeCreate` | 实例初始化之后，数据观测和事件配置之前 |
| `created` | 实例创建完成，数据观测、属性和方法的运算、watch/event 事件回调建立 |
| `beforeMount` | 模板编译挂载之前 |
| `mounted` | 模板编译挂载完成 |
| `beforeUpdate` | 数据更新时，虚拟 DOM 重新渲染之前 |
| `updated` | 虚拟 DOM 重新渲染之后 |
| `beforeUnmount` | 实例销毁之前 |
| `unmounted` | 实例销毁之后 |

***

::: details {open}
Vue 的生命周期分为创建、挂载、更新和卸载四个阶段。

创建阶段：beforeCreate 时数据还未初始化，created 时可以访问数据但 DOM 未挂载。

挂载阶段：beforeMount 生成虚拟 DOM，mounted 时真实 DOM 已渲染完成。

更新阶段：数据变化时触发 beforeUpdate 和 updated，分别对应 DOM 更新前和更新后。

卸载阶段：beforeUnmount 可清理资源，unmounted 时实例已销毁。
此外，< keep-alive> 缓存的组件会触发 activated 和 deactivated。
实际开发中，我常在 created 请求数据，在 mounted 操作 DOM，在 beforeUnmount 移除事件监听。
:::

### Vue 的自定义指令用过吗，有哪些

* `v-focus`：自动聚焦输入框；
* `v-permission`：权限控制；
* `v-lazy`：图片懒加载；
* `v-throttle`：防抖节流；
* `v-draggable`：拖拽行为。

```js
// 注册自定义指令 v-focus
app.directive("focus", {
  mounted(el) {
    el.focus();
  },
});
```

***

### Vue 如何优化 SEO

* **SSR（服务端渲染）**：使用 Nuxt.js 实现首屏直出；
* **预渲染（Prerendering）**：静态站点可用 `prerender-spa-plugin`；
* **Meta 标签动态注入**：使用 `vue-meta` 管理 meta 信息；
* **结构语义化标签**：合理使用 `h1~h6`、`nav`、`main` 等；
* **服务端渲染 + 客户端激活（Hydration）**：兼顾性能与 SEO。

***

#### ✅ 7. **其他变化**

* 更简洁的模板编译器。
* 新的 `<script setup>` 语法糖让代码更清晰。
* 更强大的插件系统和更现代的架构设计。

| 特性 | Vue2 | Vue3 |
|------|------|------|
| 响应式系统 | `Object.defineProperty` | `Proxy` |
| Composition API | 无 | 有 |
| Tree Shaking | 有限 | 支持 |
| 性能 | 较低 | 更高 |
| 模块化 | 无 | 支持 |
| 类型支持 | 无 | 支持 TypeScript |

***

### Vue 的组件通信方式有哪些及原理

1. **props / $emit**：父传子、子传父；
2. **$root / $parent / $children**：跨级通信；
3. **EventBus**：非父子组件通信；
4. **Vuex / Pinia**：全局状态管理；
5. **provide / inject**：跨层级通信；
6. **$attrs / $listeners**：传递非 props 属性和事件。

***

### Vue 的路由实现，hash 路由和 history 路由实现原理

* **Hash 路由**：通过 URL 的 `#` 后面的字符变化实现路由，不触发页面刷新。
* **History 路由**：使用 HTML5 的 `pushState` 和 `replaceState` 方法，URL 更美观，但需要服务器配置支持。

### keep-alive的实现原理和常用属性

`<keep-alive>` 是 Vue.js 中的一个抽象组件，它用于缓存动态组件实例，从而避免重复渲染和销毁过程，提高用户体验和性能。下面是 `<keep-alive>` 的一些常用属性及其简要说明：

#### 常用属性

1. **include**：字符串或正则表达式。只有名称匹配的组件会被缓存。
2. **exclude**：字符串或正则表达式。任何名称匹配的组件都不会被缓存。
3. **max**：数字。定义缓存组中可以保存的最大组件实例数量。

示例：

```vue
<keep-alive :include="['a', 'b']" :exclude="['c']" :max="10">
  <component :is="currentView"></component>
</keep-alive>
```

在这个例子中，仅当 `currentView` 是组件 `a` 或 `b` 时，它们才会被缓存，并且缓存的组件总数不会超过 10 个。

#### 实现原理

`<keep-alive>` 组件的工作原理主要依赖于 Vue 的生命周期钩子以及内部的状态管理机制。以下是其大致工作流程：

1. 当一个组件被包裹在 `<keep-alive>` 标签内并且开始渲染时，Vue 会检查该组件是否符合 `include` 和 `exclude` 规则（如果设置了的话）。符合条件的组件将进入缓存逻辑处理。

2. 如果组件已经被缓存过，则 `<keep-alive>` 不会重新创建一个新的实例，而是直接从缓存中取出并激活这个组件实例。这通过调用组件的 `deactivated` 生命周期钩子来暂停组件，而再次进入可视状态时调用 `activated` 钩子来恢复组件。

3. 对于新的组件或者不在缓存中的组件，Vue 将正常地挂载这些组件。一旦这些组件离开可视区域，它们的状态（包括 DOM 结构、组件实例等）会被存储在一个 LRU (Least Recently Used) 缓存中。

4. 如果设置了 `max` 属性，当达到最大缓存限制时，最近最少使用的组件实例将会被移除以腾出空间给新的组件实例。

通过这种方式，`<keep-alive>` 能够有效地管理组件的状态和生命周期，提升应用性能，特别是在需要频繁切换显示不同视图的情况下非常有用。

### Vue 的 computed 的实现原理

Vue 的 `computed` 属性实现的核心在于依赖追踪和响应式系统。简要来说，其实现原理包括以下几个关键点：

* 1. **依赖收集**：当一个计算属性（computed property）被访问时，Vue 会自动追踪在这个过程中哪些响应式数据（reactive data）被访问了。这是通过 Vue 的响应式系统来完成的，该系统会在读取响应式数据时进行依赖收集。

* 2. **缓存机制**：计算属性的结果会被缓存起来，并且只有在其依赖的数据发生变化时才会重新计算。这意味着如果相关依赖未发生改变，多次访问同一个计算属性将会立即返回缓存的结果，而不会重复执行计算逻辑。

* 3. **响应更新**：一旦某个计算属性所依赖的数据发生了变化，Vue 就会知道需要重新计算这个计算属性的值，并更新相应的视图。这种更新是自动的，开发者不需要手动干预。

* 4. **惰性求值**：计算属性采用惰性求值策略，即仅在访问计算属性时才执行计算逻辑，而不是在定义时就立即执行。这样可以避免不必要的计算，提高性能。

综上所述，Vue 的 `computed` 利用了依赖追踪、缓存机制以及响应式更新等特性，使得它能够高效地管理复杂状态逻辑，同时简化了代码的编写和维护工作。

### vue3性能提升的地方

Vue 3 在多个方面实现了显著的性能提升，这些改进不仅提高了框架本身的效率，也为开发者提供了更多的优化手段。以下是

**Vue 3 性能提升的主要点：**

* 1. **响应式系统升级**：
     Vue 3 使用了 ES6 的 `Proxy` 对象来实现响应式数据绑定，取代了 Vue 2 中使用的 `Object.defineProperty` 方法。`Proxy` 能够拦截对对象的所有基本操作（如属性访问、赋值等），并且能够监听到新增和删除的属性以及数组的变化 。这使得 Vue 3 的响应式系统更加灵活和高效。

* 2. **编译时优化**：
     Vue 3 的编译器能够在编译阶段将模板中的静态节点与动态节点分离，并通过 Patch Flag 标识哪些部分是动态的，从而在渲染时只更新有变动的部分 。这种优化减少了不必要的 DOM 操作，提升了渲染速度。

* 3. **Tree Shaking 支持**：
     Vue 3 采用了模块化架构，各个功能都是按需引入的，支持现代构建工具（如 Vite、Rollup、Webpack）进行 Tree Shaking，即未使用的代码不会被打包进最终产物中，从而减小了打包体积并加快了加载速度 。

* 4. **虚拟 DOM 重写**：
     Vue 3 对其虚拟 DOM 算法进行了重写，使其更加轻量和高效。新的算法包括 block tree 结构，它有助于减少需要创建的虚拟节点数量，降低虚拟 DOM diff 的压力 。

* 5. **更好的 TypeScript 支持**：
     Vue 3 是用 TypeScript 重写的，这不仅提升了开发体验，也间接地增强了项目的可维护性和运行时的安全性 。

* 6. **组件初始化性能**：
     Vue 3 在组件实例初始化时做了优化，使用扁平化的结构减少了依赖追踪对象的创建开销。此外，`setup()` 函数替代了传统的 `data`、`methods`、`computed` 等选项，在组件创建过程中可以更快地构建状态 。

* 7. **新特性带来的性能优势**：
     新增的 `Fragment`、`Teleport` 和 `Suspense` 特性为 Vue 应用提供了更高的灵活性和性能。例如，`Suspense` 可以让异步组件加载得更友好，避免阻塞主界面 。

* 8. **服务端渲染 (SSR) 改进**：
     SSR 在 Vue 3 中得到了重构，变得更轻量且具备更好的并发能力，同时首屏渲染速度更快 。

* 9. **懒加载和按需加载**：
     Vue 3 提供了组件懒加载的功能，可以通过 `defineAsyncComponent` 实现按需加载，减少初始加载资源消耗，提高首屏渲染速度 。

* 10. **缓存计算属性和方法**：
      对于开销较大的计算属性或方法，可以使用缓存来避免重复计算，进一步提升性能 。

### Vue 3 组件通信方式及其基本原理

#### 父子组件通信

* Props 和 Events
  * `Props`：父组件可以通过属性绑定的方式将数据传递给子组件。子组件使用 `defineProps` 来接收父组件传来的数据
  * `Events`：子组件可以通过触发自定义事件来通知父组件状态发生了变化，并且可以携带参数给父组件
* `v-model` 双向绑定
  * `v-model` 是一种简化的语法糖，用于实现父组件和子组件之间的双向数据绑定。它实际上是 `:modelValue` 和 `@update:modelValue` 的缩写形式

#### 跨层级组件通信

* Provide / Inject
  * Event Bus（mitt库）
    * 在 Vue 3 中，由于 $root 和 $event 已被移除，通常会使用第三方库如 `mitt` 创建一个轻量级的事件总线来实现兄弟组件间的通信
  * 共享父组件状态
    * 当两个或更多的兄弟组件需要共享状态时，可以通过共同的父组件作为中介进行状态管理

#### 高阶方案

* 插槽（Slots）
  * 插槽提供了一种内容分发的API，允许父组件向子组件传递模板片段
* attrs和listeners（在Vue 3中已合并为 $attrs）
  * `$attrs`包含了所有未被声明为 props 的属性，可以用来透传到子组件
* Ref + DefineExpose
  * 父组件可以通过 ref 直接访问子组件实例或DOM元素，并调用子组件的方法
* Vuex 或 Pinia
  * 对于更复杂的状态管理需求，推荐使用 Vuex 或者 Pinia 这样的状态管理库来集中管理和维护应用的状态

#### 总结

每种通信方式都有其适用场景，选择哪种方式取决于具体的业务需求和组件结构。例如，在父子组件之间，通常首选 Props 和 Events；对于跨层级通信，Provide / Inject 更加合适；而对于非父子关系的组件间通信，则可能需要用到 Event Bus 或者 Vuex / Pinia。

# Vue 组件通信方式

### 1. 父子组件通信

* **Props + Events**
  * 父 → 子：通过 `props` 传递数据
  * 子 → 父：通过 `$emit` 触发事件
  * 原则：遵循单向数据流

* **v-model**
  * 语法糖：`modelValue` prop + `update:modelValue` 事件
  * Vue 3 支持多个 v-model

* **Ref**
  * 父组件通过 `ref` 访问子组件实例方法/数据

### 2. 跨层级通信

* **Provide/Inject**
  * 祖先 → 后代：`provide` 提供数据，`inject` 注入
  * Vue 3 需手动保持响应式（提供 `ref`/`reactive`）

* **事件总线**
  * Vue 2: 新建 Vue 实例作为 EventBus
  * Vue 3: 推荐使用 [mitt](https://github.com/developit/mitt) 库

### 3. 全局状态管理

* **Pinia** (推荐)
  * Vue 3 官方推荐的状态管理库
  * 支持 TypeScript 和 Composition API

* **Vuex**
  * Vue 2 的标准方案
  * Vue 3 仍兼容但不再推荐

### 4. 特殊场景方案

* **共享父组件状态**
  * 通过 `$parent` 访问（不推荐，破坏封装性）
  * 更好的方案：提升状态到父组件 + props 传递

* **本地存储通信**
  * 通过 `localStorage` + `storage` 事件实现跨标签页通信

---

---
url: /learning/browserNetwork/modules/page6.md
---
# 状态码详解

> 状态码通常是指在计算机网络中，特别是HTTP协议中，服务器对客户端请求的响应状态的一个三位数字代码。这些状态码帮助开发者理解请求处理的结果，从而进行相应的处理。以下是常见的几类HTTP状态码及其含义：

1. **信息性状态码（100–199）**：
   * 100 Continue：服务器已接收到请求头，客户端应继续发送请求体。
   * 101 Switching Protocols：服务器已理解客户端的请求，并将通过升级协议来完成后续通信。

2. **成功状态码（200–299）**：
   * 200 OK：请求成功，所希望的回应头或数据体将随此回应返回。
   * 201 Created：请求已被实现，且有一个新的资源依据请求的需要而建立。
   * 204 No Content：服务器成功处理了请求，但不需要返回任何实体内容。

3. **重定向状态码（300–399）**：
   * 301 Moved Permanently：请求的资源已被永久地移动到新URI，返回信息会包括新的URI。
   * 302 Found：请求的资源临时从不同的URI响应请求。
   * 304 Not Modified：资源未被修改，可以使用缓存的版本。

4. **客户端错误状态码（400–499）**：
   * 400 Bad Request：服务器无法理解请求的格式，客户端应该修改请求后再试。
   * 401 Unauthorized：当前请求需要用户验证。
   * 403 Forbidden：服务器已经理解请求，但是拒绝执行它。
   * 404 Not Found：请求失败，请求所期望找到的资源在服务器上不存在。

5. **服务器错误状态码（500–599）**：
   * 500 Internal Server Error：服务器遇到未知情况，使其无法完成请求。
   * 501 Not Implemented：服务器不支持当前请求所需要的功能。
   * 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（如DNS服务器、网关、代理服务器等）收到响应。
   * 503 Service Unavailable：由于临时的服务器维护或过载，服务器暂时无法处理请求。

每种状态码都有其特定的应用场景，了解它们有助于更有效地调试和优化Web应用程序。

---

---
url: /learning/other/modules/page2.md
---
# 移动端适配

> 移动端开发中，适配是确保应用在不同尺寸、分辨率和操作系统的设备上都能提供良好用户体验的关键

**参考文章**

* [移动端适配参考1](https://juejin.cn/post/6844903845617729549?searchId=2025071818035420FAFFCF7822B473A157)
* [移动端适配参考2](https://juejin.cn/post/6844903631993454600?searchId=2025071818035420FAFFCF7822B473A157)
* [移动端适配参考3](https://juejin.cn/post/7046169975706353701?searchId=2025071818035420FAFFCF7822B473A157)
* [移动端适配参考4](https://juejin.cn/post/7266671630025031699?searchId=2025071818035420FAFFCF7822B473A157)

**推荐方案**

* `vh/vw方案：使用视窗单位直接根据窗口大小调整布局`

1. **基础概念**：
   * 英寸：屏幕尺寸的度量单位，指的是屏幕对角线长度。
   * 分辨率：分为屏幕分辨率（如iPhone XS Max为2688 x 1242）和图像分辨率，表示水平和垂直方向上的像素数量。
   * PPI（Pixels Per Inch）：每英寸包含的像素数，用于衡量屏幕清晰度。
   * DPI（Dots Per Inch）：通常指打印机打印输出的精细程度。

2. **设备独立像素（DP/DIP）**：
   * 设备像素比（DPR）是物理像素与设备独立像素的比率。
   * 在不同分辨率的设备上使用设备独立像素可以让界面元素大小保持一致。

3. **视口（Viewport）**：
   * 包括布局视口、视觉视口和理想视口，对于网页在移动设备上的显示至关重要。
   * 使用`<meta name="viewport" content="width=device-width, initial-scale=1">`可以帮助实现理想的页面缩放效果。

4. **常见问题及解决方案**：
   * **1px边框问题**：由于DPR大于1导致1px边框变粗的问题，可以通过border-image、background-image、伪类+transform或SVG等方式解决。
   * **图片模糊问题**：通过提供@2x、@3x等高分辨率图片，并使用media查询、srcset属性或image-set函数来适配不同的设备像素比。
   * **适配iPhone X及其他具有异形屏的手机**：需要考虑安全区域和viewport-fit属性，利用CSS函数env()和constant()设置适当的内边距。

5. **适配方案**：
   * flexible方案：基于rem单位进行适配。
   * vh/vw方案：使用视窗单位直接根据窗口大小调整布局。

---

---
url: /novel/overachiever/pages/page1.md
---
# 第一章：前端工程师被噶了？

霓虹褪色，深夜的写字楼寂静得像座坟墓。

杨易坐在办公椅上，满脸疲惫地盯着屏幕，眼神却依旧坚定。他的 IDE 窗口里，一串串代码还在滚动，而他右下角的工时打卡软件赫然显示：**连续在线 19 小时**。

“杨哥……你还不下班？”

“你先走。”他头也不抬，继续在控制台输入测试参数，“我得把这个需求做完，明天老板要验收。”

同事迟疑了一下，终究没说什么，默默走了。

办公室里再次只剩下他。

他已经记不清自己连续第几个日夜没睡好。项目需求无限迭代，测试用例推翻又推翻，每一个像他一样的“页面仔”都在拼命卷，只为了不被裁掉。

杨易更卷，因为他知道：

**“只要我不掉队，就能活下去。”**

但命运向来残酷。

门开了。HR 拿着一份文件走进来，神情有些僵硬：“杨易，可以耽误你五分钟吗？”

五分钟后。

杨易木然地坐在原位，盯着桌上的“裁员通知书”。他拼了命地卷，却还是被优化了。

他缓缓抬头，看着屏幕发呆：

“我……输了吗？”

就在这时，电脑屏幕突然发出一声“嗡——”的低鸣，亮度莫名其妙地升高。一道刺目的白光猛然迸发，仿佛能穿透灵魂。

“卧槽！”杨易下意识抬手去挡，但手还没抬起，他整个人就被白光吞没了。

天旋地转，意识失控。

……

……

当他再次醒来时，鼻尖先是闻到了一股清新的青草味。

他睁开眼。

头顶是湛蓝的天空，两轮月亮一左一右地挂在高空，云彩像棉花糖一样轻盈飘过。身下是松软的湿地，草叶打着露珠。

“这……哪儿啊？”

杨易猛地坐起，目光四顾，发现自己身处一片山野田地之间，远处是一条清澈的小溪，几只野鹿在林边蹦跳。他穿着之前的格子衬衫，满身泥泞，狼狈不堪。

“我不会是……穿越了吧？”

就在这时，他脑中响起一道清晰的机械女声：

【叮——系统绑定中……】
【卷道修仙系统初始化完成。】
【宿主身份：杨易，原职业：前端工程师】
【当前状态：异界村落·无户籍·无修为】
【绑定成功，卷力模块已开启】

【提示：所在村落三月后将举行“灵山宗”凡人收徒测试。】
【主线任务：在三月内达到炼体三重，获取测试资格】
【奖励：灵根检测权限、灵识初通、神秘支线开启】


“卧槽？真是系统？”

杨易愣了片刻，突然嘴角勾起一丝疯狂的笑意。

“好家伙……我卷成那样都没留下来，结果竟然穿越修仙了？”

“卷王不死，战火重燃！”

**竹禾村 · 外缘地带**

杨易刚从地上站起，就听到不远处传来“吱呀”声。

一个背着锄头的老农站在田埂上，看他一身怪异打扮，惊讶道：“哎哟？你是哪个村头的？怎么趴在祖地边上？”

杨易正要答话，脑中系统响起提示：

> 【当前无户籍，身份未确认。建议维持模糊设定，避免暴露异常状态】

“我……我摔了个大跟头，记不清东西了。”他挠了挠头，假装糊涂。

“唉，可怜人。你运气还算好，祖地守灵的青木不会害人。”

老农看了他一眼，丢下一块干饼：“拿着。你先去村口找村长，报个身份。没户籍，可是不能随便留在村里的。”

杨易接过饼子，饿得狼吞虎咽，一边走，一边思考：

> 【系统提示：因你在异界首次生存自救并成功博得村民信任，获得奖励】
> 【获得经验：炼体经验 +5】
> 【肝力：+1】

“原来连吃饭都算‘卷力表现’？”

他顿时来了精神。

***

**村中 · 草棚边界**

杨易被安排在村边废弃的草棚中，暂时居住。

此处接近祖地，常人不敢靠近，且破旧不堪，夏日尚可，夜晚却冷风透骨。

“终于安顿下来……”

他整理好自己，开始在脑海中呼出系统面板。

***

**宿主**：杨易
**境界**：炼体0重（0%）
**体力**：100/100
**肝力**：3
**当前任务**：
→ 达成炼体三重（进度 0%）
→ 获取资格参加收徒测试
**被动技能**：

* 【卷力换修为】：通过超额训练获得经验。
* 【打工魂】：连续锻炼效率+10%。
* 【肝即真理】：每日首个极限训练获得额外加成。

***

“很好，熟悉的绩效系统味道……”

“既然要炼体，那就从明天开始练到死。”

杨易眼神坚定，看向草棚外的练力坪。那是一片供村民锻炼体魄的泥地，上面摆着劈木台、石锁、沙袋、石磨等粗陋工具。

他不认识任何人，没有灵根，没有背景，也没法炼气。

**但他有一样别人没有的东西——**

**系统和极致的“打工魂”。**

“这一世，我不再是被卷的工具人。”

“我要卷翻整个修仙界。”

**——第一章完。**

---

---
url: /novel/overachiever/pages/page7.md
---
# 第七章：无灵根觉醒！天命被打碎了！

夜深，竹禾村外。

狂风卷动，乌云压顶，电光撕裂天幕。

草棚之中，杨易盘坐石床，气息悠长，系统面板淡金色光芒环绕脑海。

> 【检测到宿主突破炼体三重】
> 【是否启动灵根觉醒仪式？】

“启动。”

杨易眼中无惧，神色如常。

对他来说，这不过是另一个“项目上线”的阶段性交付。他不怕失败，只怕**不够努力**。

## 灵识空间

一阵眩晕后，他意识进入一片空灵空间。

面前浮现五道颜色各异的灵光：金、木、水、火、土。

这是天地间最基本的五灵根之力。凡修者，若能感应其一，即可踏入修道门槛。

然而，下一秒——

> 【检测中……】
> 【结果：无灵根波动】
> 【检测失败。】

“你是……空灵体质。”系统的语气，带着一丝前所未有的迟疑。

“什么意思？”杨易低声问。

> “你并非没有灵根，而是……你的灵根未被天地所承认。”

> “你不属于这个世界的‘灵命谱系’。”

> “因此，你的命运，被天道系统判定为：无修之人。”

周围的五灵光，像是察觉到他“非本地存在”，纷纷避退，仿佛天命之轮，将他永远排除在外。

杨易低头看着自己的手指，沉默了。

良久，他笑了：

“我努力练到炼体三重，打爆同龄人，凭什么你说我不能修仙？”

“你说我无命？”

“那我就**卷出一条命**来！”

## 系统变更

轰！！

系统面板剧烈震荡。

> ⚠️【警告：命运路径不匹配】
> ⚠️【灵根觉醒失败】
> ⚠️【卷道系统判定：宿主仍有“自生卷力”可能性】
> ✅【是否启动备选方案：卷命灵根·自构协议】
> ✅【构建方式：以卷力与修行为根基，自我炼化“命基核心”】

【注】：该路径不被天道承认，宿主将不受“灵气馈赠”，但可通过“卷力值”突破限制！

“我选。”杨易毫不犹豫。

轰隆！！

五灵根之光全部崩解，化为虚尘。

一道全新的金色命盘缓缓浮现，上面只有两个字——

**“卷命”**。

> 【构建完成！】
> 【恭喜宿主觉醒特殊灵根：卷命灵根（唯一）】
> 【属性：无相 · 无源 · 自造】

> 🎁【奖励：卷灵诀（入门）×1】
> 🎁【解锁：灵识空间每日修炼 ×1】
> 🎁【解锁：卷力替代灵气炼化功能】
> 🎁【开启隐藏功能：打破天命路径】

杨易缓缓睁开眼，草棚中一片宁静。

他身体无异变，无灵光升腾，无异象流转。

**安静得仿佛从未发生过觉醒。**

但只有他自己知道——

他此刻，已拥有一种前所未有的力量。

## 系统提示弹出

> 【你已选择踏上一条前所未有的道路】
> 【此后，你将无法依赖天地馈赠，但你将拥有：**用“卷”打破天命”的可能性**】

> 当前灵根：卷命灵根（Lv1）
> 当前状态：炼体三重 · 灵识未通
> 下一目标：**以卷力点燃灵台，凝聚“卷命识海”**

## 翌日 · 村中喧哗

村长收到林冰婉递交的评测记录后，当即召集长老会。

“他完成所有考验，但……仍无灵根波动？”一位长老蹙眉。

“这已非凡俗可解释。”

“村长，依规，他应当被列入‘弃灵档’，不予推荐。”

林冰婉却缓缓站起，声音不大，却清晰无比：

“我反对。”

“他虽无灵气波动，但每一拳都胜过灵根者。他的意志、训练法、战斗力……都远超同龄。”

“我无法解释他为何不被灵气亲近。”

“但我可以肯定，他不应被放弃。”

村长久久沉默。

最终缓缓开口：“若他能在接下来三日内，**自证可修行**，我愿为他破例。”

## 草棚 · 闭关

杨易坐在石床上，手持系统新赠的《卷灵诀》入门篇。

这本功法，完全不同于灵山宗体系。

它没有运气法门，取而代之的是一套近乎魔鬼式的“自炼体制”：

* 以意识每日模拟千万次筋脉冲击。
* 以训练带来的肌肉损伤激活灵识触点。
* 每一次“极限肝爆”，都可换取“识力值”。

“这是……完全以肉身卷出精神的逆修法门？”

“原来你早准备好了。”杨易低笑。

**“那就，让我来卷破这世界给我的天命。”**

他闭上眼，系统界面瞬间浮现修炼模拟界面：

> 【灵识点火进度：0.00%】
> 【当前：识台未亮】
> 【推荐操作：进行“极限脑力冥想”+“肝魂训练”】

他深吸一口气，正式踏入新阶段。

## 三日后 · 村前测灵仪再启

杨易盘坐其上，四周围满了人。

“又来了？”

“他还想证明什么？这次总不会有什么奇迹吧？”

林冰婉也站在不远处，紧紧注视。

一位长老不耐烦地摇头：“来吧，开始测灵。”

测灵珠启动。

片刻沉寂。

下一秒——

轰！

测灵珠竟猛地炸裂出一道**金红色裂痕**，宛如一道“禁忌裂纹”。

所有人骇然！

“这是……？”

系统声音在他脑海中炸响：

> 【恭喜宿主，灵识点火成功！】
> 【当前识力：1】
> 【状态：自构灵识完成，已开启逆修第一阶段】

而测灵珠旁，器灵老者面色惨白，嘴角溢血：

“这是……不在命谱之上的……异命之火！”

**林冰婉看着他，低声呢喃：**

“你……真的卷出了一条命？”

**——第七章·完**

---

---
url: /novel/overachiever/pages/page3.md
---
# 第三章：卷出炼体经验

清晨的露水打湿了练力坪的石地，寒意透骨。

而草棚前，一道正在缓慢挥拳的人影早已汗如雨下。

杨易已连续六日未曾懈怠。

他设定的“炼体动作组”包括——

* 负重深蹲300组
* 劈木1000次
* 金石碎拳400下
* 冷水冥想45分钟
* 三倍强度的断指撑

每完成一轮训练，系统便跳出反馈：

> 【训练完成度：112%】
> 【获得炼体经验+6，体力消耗：-48，肝力+2】
> 【宿主表现：超额达成，触发被动“卷爆临界”】

他早已适应了这种极限修行的节奏。

**甚至，还在优化方法。**

“之前劈木太耗力，现在改成双重挥斧叠击，能在不损伤肌肉的前提下，触发更多卷力点。”

“冥想的时间我再分成两段交叉进行，用以修复心神，兼顾续航。”

系统界面在脑海中不停更新进度：

***

### 【卷道修仙系统 · 面板】

* 境界：炼体0重（98%）
* 体力：22/120
* 肝力：18
* 状态：濒临突破 · 推荐立即进行【破境冲击】

***

“终于来了。”

杨易深吸一口气，盘膝而坐，按照系统引导的口诀开始引动体内那丝若有若无的热流——

“锤骨、熬血、炼肉、通筋、强皮，乃为炼体一重。”

**刹那间，他只觉得全身一震。**

体内仿佛炸裂出一股炽热洪流，从脊椎贯通四肢，一寸寸筋肉开始跳动，骨骼“咯咯”作响，皮肤泛出淡淡红光。

草棚外的土屑在这股气势下微微扬起。

> 【恭喜宿主，突破炼体一重！】
> 【获得奖励：体力上限+20、肝力+5】
> 【解锁新功能：卷力排行（村内）】

杨易缓缓睁开眼，目光清澈如洗。

**他知道，他终于站到了“可修炼者”的门槛。**

这时，系统界面弹出一个新的排行榜：

***

### 📊【竹禾村·卷力榜】

| 排名 | 姓名  | 日常卷力值 | 状态   |
| -- | --- | ----- | ---- |
| 1  | 杨易  | 389   | 草棚孤修 |
| 2  | 石九山 | 180   | 村中天才 |
| 3  | 王大力 | 160   | 猛牛之体 |
| …  | …   | …     | …    |

***

“第一？”

“我卷力居然碾压石九山？”杨易眨了眨眼。

石九山，是村长之孙，天赋极佳，被称为“十年难得一遇的体修种子”。从小就被灌注资源，是下届宗门测试的热门种子选手。

此刻他正蹲在村中练力坪，看着新贴出来的榜单，脸都绿了。

“草棚那个疯子？”他喃喃低语，“他哪来的资格？”

***

## 同时 · 村中议论四起

“你听说没？草棚那个外来疯子……卷爆石九山了！”

“真的假的？他连户籍都没有，怎么能进排行榜？”

“说是他靠自己苦练，练出炼体一重，激活了系统自动纪录的卷力榜。”

“啧啧，天赋不如人，努力补回来，真有点东西……”

曾经的嘲讽与轻视开始转变。

甚至，已经有少年暗中在草棚外观摩杨易的训练流程，偷偷模仿。

“他每天把自己训练得跟狗一样，居然真练成了？”

“那我也试试……”

—

## 傍晚 · 草棚边

系统再次弹出提示：

> 【支线完成：以非村籍身份突破炼体一重，造成村级影响】
> 【奖励：基础灵根感应术 ×1、肉体恢复液 ×1】

> 【主线更新：在村内比试中击败任意一位炼体二重者】
> 【任务奖励：初级灵石×1、训练场权限×1】

杨易喝下肉体恢复液，疲惫迅速缓解，整个人神清气爽。

“灵根感应术？”他立刻选择使用。

脑海中自动浮现一套口诀，他闭上眼，开始调动体内热流，感应天地元气是否能与自身共鸣。

……

……

结果，是沉寂。

没有任何波动，仿佛天地视他为空气。

系统缓缓弹出说明：

> 【初测灵根感应结果：无属性灵根】
> 【备注：并非无灵根，而是未觉醒。建议完成更多突破任务，激活潜力位】
> 【系统补偿：卷力换灵根模块即将开放（解锁条件：炼体三重）】

“啧，果然没有这么顺利。”杨易喃喃。

但他并不气馁。

**“在职场没背景我都能靠卷杀出来，在这修仙界，我一样能靠卷打穿！”**

***

## 夜深 · 某处山林

一个白衣少女站在远处树上，俯视着练力坪。

“他今天突破了。”她轻声道。

随行的中年护卫皱眉：“大小姐，他没有灵根，也无门无派，为何要关注他？”

少女眼中带着复杂的情绪：

“他每一拳都不带一丝懈怠，每一步都踏在生死线上……”

“像极了……十年前的那个人。”

说完，她转身离去，笛声远去，留下一缕冰寒的灵息在空气中徘徊。

而那抹身影，正坐在草棚门前的月下，如磐石般纹丝不动，任由寒风吹袭。

***

**——第三章·完**

---

---
url: /novel/overachiever/pages/page9.md
---
# 第九章：灵山宗震动！系统流天命叛逆者诞生！

—

灵山宗，位于永州大陆西岭山脉，掌三州灵脉，统九十九支属地村落，每十年一次招收外门弟子，择灵根而纳之。

而今天——

灵山宗**灵纹殿**的大预警碑突然震颤。

碑上，浮现一道前所未有的灵力反馈：

> 【异常命格波动】
> 【源头坐标：竹禾村 · 外籍卷修】
> 【特征：灵根体系不明，识火反向点燃，自构灵纹！】

—

## 灵山宗 · 外门堂

一众执事、长老、教习闻讯齐聚。

“大长老，怎么回事？灵纹殿竟自动启动预警？”

“异常命格出现了……竟在竹禾村这种偏僻之地？”

“识火反点？不走灵气通道，自构体系？”

“这不是‘逆修者’吗！”

一时间，满堂哗然。

灵山宗有明确门规：

> “唯纳天地灵命之子，拒纳逆天自造之流。”

因为后者——不受天地认同，极易失控、走火入魔，甚至引来因果反噬，影响宗门根基！

—

## 高层会议 · 暗流汹涌

灵山宗大长老“符元真”拂袖冷声：

“既是逆修，便应当场镇压，防后患！”

“传我命令：暂停竹禾村弟子递交流程，立即派遣监察使，彻查真相！”

而坐于另一侧的副宗主“沈落秋”却皱眉摇头：

“此人虽为逆命者，却自筑神识、自构卷修体系，不假外物，不沾邪道，意志之坚，非凡体可比。”

“若真是未来可造之材，岂能错失？”

此言一出，堂中再掀波澜。

—

## 林冰婉 · 在场旁听

作为本次下派竹禾村的外门记录员，林冰婉面如寒霜，站出拱手：

“弟子请命，为他担保三日。”

“他未走邪路，亦无害心，修行虽异，但苦修之志足以弥补出身之短。”

“请宗门，至少给他一次解释之机。”

大长老冷哼：“你以情代理？”

“他不是你能救的。”

沈落秋却缓缓点头：“三日可。”

“若三日后仍无失控迹象，便许他入外门候选堂。”

—

## 竹禾村 · 草棚外

这天清晨，一位身披银纹长袍、腰佩令牌的监察使御风而至，落于村口。

杨易正在修炼《无限肝魂卷轮阵》第一阶段，挥拳千遍，筋骨哀鸣。

监察使神识一扫，顿时面色一变。

“这股识压……他已能自主模拟灵识攻击？！”

当他见到杨易全身布满血痕，却仍低头训练，喃喃自语：

“只练五千遍，不够稳……起码一万次。”

监察使的眼皮狂跳。

**这人不是疯了，就是已经把苦修当成了信仰。**

—

## 草棚内 · 对话

监察使走近。

“你便是杨易？”

杨易停下拳势，平静点头：“是我。”

“你知道你现在的修行方式已经触犯宗门命理戒条？”

“你若是再进一步，可能会被定为‘逆修’，逐出凡界体系。”

杨易眸中无波：

“那我问你，若我没有灵根，却用卷命之法修上来，是否就是罪？”

监察使沉默。

“若你们要把所有‘非天命者’逐出修行路，那修仙二字，本身就是封闭的谎言。”

“我既能自修、能战、能学、能创，为什么不能走这条路？”

监察使盯着他良久，忽然长叹：

“……三日后，有人会来审你。你准备好自己的答案吧。”

他转身离去。

杨易握拳，望向天边，眼神坚定。

“我不怕谁来。”

“只怕……这世界连一条让我卷上去的路都不给我。”

—

## 系统提示：

> 【任务开启：宗门应答】
> 🎯 三日内，完成下列任一条件，即可转正宗门外门候选者：

* 【A】完成一项自创神识技法并演示（≥5识力消耗）
* 【B】以自身训练法教导三名凡体者入炼体一重（全民风气扩散）
* 【C】卷力冲破炼体三重巅峰，初步凝练“识骨灼纹”

奖励：

* ✅ 进入灵山宗外门特殊序列（记录“自构系”）
* ✅ 解锁：系统地图（周边宗门、资源点标记）
* ✅ 卷命系统·天权模块开放（与传统修士结构对冲）

—

## 林冰婉找来

她第一次神情有些急切：

“你……知道你面对的是什么吗？”

“灵山宗可能不会容你。”

“你若真的执意如此——”

杨易却笑着看她，阳光从肩头斜落，映出一双疲惫却坚韧的眼。

“冰婉，如果所有的宗门都不能容我。”

“那我就……自己建一个。”

—

## 镜头转回 · 灵山宗后山密殿

某位闭关百年的神秘老者，在灵气混沌中缓缓睁开双眼。

他望向东南一隅，喃喃道：

“千年来，第一位逆修者出世了……”

“这次，命运要裂开一个口子了吗？”

—

**——第九章·完**

---

---
url: /novel/overachiever/pages/page20.md
---
# 第二十章：反派登场，惊觉主角不可卷

演武场西侧，看台之上，一身紫金云纹长袍的少年缓步踏出，身后跟随两位执事模样的长老。

“他是……秦家嫡子，秦朗！”

“听说他早在一年前便已炼体九重，并修有家族传承的《雷云劲》，连韩齐都未必是对手。”

“秦家是青玄宗外门大户之一，此人若拜入宗门，前途不可限量。”

人群中窃窃私语，纷纷向那名走来的少年投去敬畏目光。

台下的杨易此刻刚刚结束了与韩齐的一战，精神尚未完全恢复，但神识如剑，依旧死死锁定这位新登场的强敌。

“你便是那个靠‘奇技淫巧’闯入前十的新面孔？”秦朗语气淡漠，却透着一股根深蒂固的优越感，“不错，有点意思。”

杨易皱眉，未言语。

他已经看得出，对方不仅体术强横，且拥有雷属性灵根，天生便在速度与爆发上远胜常人。若硬拼，哪怕是全盛状态的他，也未必能讨得了好处。

但此刻，灵气不足三成，身体疲惫，神识仍在刚才的连环破阵推演中微微刺痛，偏偏这时，来了一位比韩齐更强的对手。

“演武继续，挑战无间。”执事长老的声音如判决。

杨易深吸口气，目光微眯，“好一个‘无间’……”

而台上的秦朗却已出手。

一道雷光如剑，撕裂空气，瞬间掠至杨易面前！

轰——！

杨易脚步错位，踏出古怪步伐，强行扭身避开第一击，但第二道雷光已然接踵而至，似是早已预判好他的闪避路线！

“真当我是系统白送的？”

他低喝一声，神识之海中浮现一幅新的“拟灵阵图”结构，那是他早在刚才推演时便已构建完毕的备用方案——

**“三息动图·风雷借影”！**

只见他周身灵力急速运转，纵身飞掠之间竟拖出三道“影像残痕”，在下一击落下之前，完成了瞬间的三段位移！

全场哗然！

“他居然能在这种状态下继续拟图并实战应用？”

“这不是炼体修士能做出来的事吧！”

“他该不会是隐藏修为的……灵识修士？”

台上的秦朗也露出一丝惊色，但旋即冷笑，“会点小花样，不过是雕虫小技。”

轰！

雷芒再起，这次他直接激发灵识，雷云劲第二式《雷锁苍空》展开，十道雷光自四面八方封锁而来，防止杨易继续借“残影”闪避。

杨易眉头一挑：“真当我没有后招？”

他眼神一厉，右手猛然探出，一道由灵识勾勒而成的“旋盘式破图”瞬间绽放于脚下！

那是他系统中解锁的\*\*“拟阵·雷纹斩”\*\*，原本用于辅助破雷阵之用，如今被他灵活改造，硬生生在半空中形成一个反向雷引场域！

雷光瞬间混乱，朝着阵盘中心汇聚而去！

秦朗面色一变，还未反应过来，杨易已经从雷光混乱中一步踏出，出现在他左侧。

“你知道，什么才是真正的‘卷’吗？”

“不是比谁修炼快，不是比谁灵根好，而是——”

“你以为我只有一招，我已经准备了十招。”

砰！！！

一记重拳击中秦朗左肋，将其打得飞出数丈之外，吐血倒地。

演武场鸦雀无声。

片刻之后，执事长老震惊地宣布：“秦朗……战败，杨易，胜！”

高台上，一名银袍中年男子眼神幽深。

他是青玄宗宗主之弟，掌刑堂长老秦厉，秦朗的亲叔。

“此子，不能留。”他轻声道。

---

---
url: /novel/overachiever/pages/page2.md
---
# 第二章：草棚中的异乡人

清晨，村东头的鸡鸣声刚落，竹禾村便热闹了起来。

杨易起得比谁都早。

他将破草棚前堆起的石头整理成一个简易“训练站”，石锁、木桩、负重水缸、磨盘，都是他从田边、柴房和废料堆里一块块搬来的。

“这感觉……像极了以前为了晋升做的 KRA 指标进度表。”他拍了拍沾满泥的双手，自嘲一笑。

**但不同的是——这一次，他能看到努力的回报。**

脑海中，系统界面浮现。

***

### 【卷道修仙系统】v1.0

* 当前境界：炼体0重（3%）
* 体力：100/100
* 肝力：3
* 主线任务：达成炼体三重（限时89天）
* 被动加成：【打工魂】连续训练效率+10%
* 支线提示：当前居住环境恶劣，激发“艰苦模式”，获得每日锻炼额外奖励+5%

***

“很好，又是充实的一天。”

他搬起一块青石，练习“压肩式”。

呼——压！

呼——起！

**每一次动作都力求极限**，角度、频率、呼吸配合都做到精准无误，甚至超出村中老练壮汉的标准。

这时，几个来练力坪的少年看到了他：

“看，那疯子又在练了。”

“他住在草棚里，连饭都吃不上，还每天劈木、提石，疯得不轻。”

“听说他连村籍都没有，等宗门来时连测试都别想。”

杨易听到了，却毫不理会。

\*\*他听得太多了。\*\*现实世界的办公室从不缺闲言碎语，他早学会了忽略无意义的信息干扰。

系统提示音悄然响起：

> 【持续训练90分钟，卷力值累计达100点】
> 【肝力提升至：5】
> 【奖励：炼体经验+5，筋骨强化+1】

**经验进度条缓缓拉长：炼体0重（3% → 10%）**

他握紧拳头，呼吸加快，全身血液都在沸腾。

**“这种进度，是我梦寐以求的正反馈！”**

***

## 午时

村中饭棚外，炊烟袅袅，香味扑鼻。

杨易站在最后面，一手扶着水桶，一手拿着石锁练腕力。

“大叔，还有饭吗？”他小心问道。

掌厨的汉子扫了他一眼，皱眉：“你不是本村人，怎么还来蹭饭？”

杨易笑了笑，把水桶往地上一放：“我今天帮村东浇了五垄田，又劈了一下午柴。大叔您说这饭……我算不算挣来的？”

掌厨汉子愣了下，随即点头：“有骨气！去旁边拿碗去吧。”

系统提示：

> 【触发被动：“苦力换资源”】
> 【奖励：炼体经验+2，获得低级粮食×1，体力恢复+30】

杨易一边吃，一边研究系统中的卷力转化机制。

“也就是说，只要我不断训练、劳动，就能兑换经验。跟绩效打分一模一样，只是现在……我能看见系统分数了。”

***

## 夜晚

村中渐渐安静。

绝大多数村民早早入睡，只有练力坪那边，传来“呼哈呼哈”的喘息声。

**杨易还在训练。**

石锁负重、木桩锤击、断指撑地、极限深蹲，他不放过每一个动作细节，甚至记录下训练顺序与恢复效率，不断优化“训练流”。

“以前写代码讲究效率堆叠，现在练身体也一样。”

他脑中列出逻辑：

* 每日训练节点：晨练、午训、晚冲刺；
* 每阶段目标：积满卷力点触发强化奖励；
* 每一次突破：系统给经验/体力/奖励；

系统提示接连跳出：

> 【激活连练成就：夜训3小时】
> 【奖励：肝力+2、体力上限+5】
> 【当前炼体经验：27%】

**一夜未眠，他反而越来越兴奋。**

这时，一道清冷的声音忽然响起。

“你为什么……这么努力？”

杨易惊了一下，猛地转头。

草棚不远处，一个女孩正坐在树根上看着他。月光照在她的发上，微风拂动衣角，她眉眼清冷、肤若凝霜，看起来不过十五六岁，却有种超出年龄的冷静。

她身边还放着一根灵竹笛，显然不是普通村民。

“你……是？”杨易擦了把汗。

“我是随父巡村的家眷，灵山宗外门门人之女。”少女平静道。

“那你为什么在这？”

“我在等人。”她声音更低，“等一个……能让我相信的人。”

她的目光落在杨易满是老茧与淤青的手上。

“你不是这村的，也没资格被选中。但你比他们……都努力。”

“你叫什么？”

杨易愣了一下。

“我叫杨易。简单的‘容易’，但我从来没容易过。”

少女一怔，缓缓点头。

她抱起灵竹笛，轻轻一吹，一道清音穿过草坪，悠扬空灵，像是回应着这个世界中最孤独的奋斗者。

系统提示在他脑海悄然浮现：

> 【触发隐藏线索：“冰灵之契”】
> 【神秘少女身份已记录，待条件达成将开启灵识支线】
> 【卷力增幅+10%，夜间训练效率提升】

杨易握紧拳头，第一次觉得：**这世上有人看见他的努力。**

“谢谢你。”

他望着夜空，低声道：“但你看到的，还不算什么。我会让这整个修仙界，都看到我。”

***

夜风轻拂，草棚孤灯。少年身影在月下起落不息，锤石、负重、疾跑……汗水打湿地面，也灌溉了未来的根。

**“卷道初起，草棚为炉，打工魂燃起的第一夜。”**

**——第二章·完**

---

---
url: /novel/overachiever/pages/page5.md
---
# 第五章：全村被我带卷了

自从杨易在练力坪一战击败石九山，整个竹禾村就变了天。

这位曾被人当成疯子的“草棚外人”，如今成了全村少年心中的新偶像。

他用七天时间，从无籍野人练到炼体一重。

他用实战突破的方式，挑战炼体二重天才，并将其击败。

最重要的是——他**没有背景、没有资源、没有灵根**，只靠**训练强度和不休不眠的意志**，卷出了名声。

***

## 村中 · 练力坪

原本冷清的训练场，如今热闹得像集市。

一大早，便有十几个少年围着石锁、木桩、沙袋练得热火朝天。

有人负重跑圈，有人模仿杨易的“断指撑”，甚至连原本只锄地的农夫也加入其中，练腿、举石、踢木桩……

“以前一天练一个时辰就嫌累，现在不卷个三五个时辰都不敢回家。”

“我昨天照着杨易的方法练，手掌都磨破了！”

“他能练成，我们也能！”

“你听说了吗？村长说要把练力坪扩建！”

—

## 村长议堂 · 内室

“这个杨易……真有点东西。”白胡子的村长捋着胡须道。

长老点头：“石九山那孩子被他卷怕了，竟主动提出‘闭门苦修’。”

另一位长老则眼露复杂之色：“原以为他只是个疯子，没想到却带动了村中修炼之风。”

“人心难得啊。”

村长缓缓站起：“传我命令——”

“练力坪扩建三成，新增夜灯十座，开设苦修奖励机制。”

“另——破例将杨易登记为‘外籍候选者’，若三月后通过宗门测试，视同本村出身。”

众人一惊。

“村长，您要保他？”

“不是保，是押宝。”村长目光深邃，“我们不能再失去一个‘石家那样的人’了。”

—

## 草棚外 · 晚上

杨易坐在自制的石凳上，翻阅系统界面。

系统更新提示跳出：

***

### 【卷道修仙系统 · V1.2】

🧠 新增模块：训练计划管理器
🧱 解锁功能：村风引导（推动全民修炼可得“风气值”）

📈 当前风气值：52
📌 效果：全村训练效率 +3%，夜训参与度 +6%

🎯 村风等级：Lv1（0/1000）

> 【提示】：当前已引起小范围“修炼潮流”，请持续引导训练风尚以获取系统成长反馈。

***

“我……能带动整个村子的训练风气？”

杨易微微一愣，随即嘴角勾起一丝笑意。

“在公司我是个没人管的工具人，在这村子，我却能当‘卷风引导者’？”

“系统啊系统……你越来越懂我的口味了。”

—

## 村中各处 · 卷力之火蔓延

* **村西小胖子王三牛**，以前整天偷吃，现在竟然每天早上跟着杨易一起跑圈，瘦了一整圈。
* **村南的哑巴铁柱**，模仿主角修炼方法，用石头压肩，突破炼体一重，能说出完整一句话了。
* **几个少年**偷偷在草棚外支起帐篷，晚上跟着杨易夜训，早上还抢着搬柴火、打水当负重器材。

村民们议论纷纷：

“杨易走哪都有人跟着。”

“他简直把修炼当命在拼！”

“再过一阵，宗门来人都得刮目相看。”

—

## 冰艳女主 · 首次真正现身

某夜，杨易刚完成新一轮“负重爆步练法”，正浑身大汗坐在石上喘气。

一阵淡淡的寒意传来，空气中多了一丝花草结霜的清冷。

“你带动了村子的修炼风气？”清冽的声音在身后响起。

杨易转身，看到一个白衣如雪的少女站在月光下。

她目光如冰湖，唇色微冷，气质孤绝。

“你是……那晚在树下的姑娘。”

她轻轻点头：“我是林冰婉，灵山宗外门弟子，也是本次宗门测试随行记录员。”

杨易一愣，随即微微抱拳：“幸会。”

“你的修炼方法，不合此界常规。”她道。

“但——确实有效。”

“所以我决定：若你能在接下来的测试前冲入‘村比前五’，我将上报你的表现，递交至外门。”

杨易听完，眸中亮起火光。

“也就是说……只要我卷得够狠，你可以帮我跳过灵根门槛？”

林冰婉目光一顿，认真道：“是你自己卷出的资格，不是我帮。”

“我只是——将真实记录送达宗门。”

“你值不值得入门，由你自己决定。”

说完，她转身离去，雪色衣摆翻起一抹微寒，像风中初开的霜花。

系统提示如期而至：

> 【支线开启：冰灵线 · 试观】
> 【要求：在十日内冲入村比前五】
> 【奖励：灵山宗外门推荐书×1、冰艳剧情第一阶段开启】

> 【当前排名：第8位（炼体二重 · 进度64%）】

杨易盯着那个“第8位”的数字，握紧拳头。

“我时间不多了。”

“那就……卷得更狠一点吧。”

—

## 草棚 · 深夜灯火

夜晚的练力坪灯火通明。

越来越多的人加入夜训，小孩、壮年、甚至老者。

杨易站在最中央，一身肌肉紧绷，目光如炬。

他高声道：

“你炼三天？我炼三十天！”

“你睡一夜？我通宵三晚！”

“修仙，不靠天赋，靠**卷**！”

“现在起，凡愿加入‘极限苦修组’者，跟我来！”

数十人热血沸腾，追随他冲进黑夜。

—

**——第五章·完**

---

---
url: /novel/overachiever/pages/page8.md
---
# 第八章：逆修之道！卷命入识！

天光破晓，竹禾村尚未从前夜的震惊中缓过神来。

测灵珠炸裂的余波仍在发酵，长老们噤若寒蝉，灵山宗的记录员将那道“金红裂痕”标记为【异常异命现象】上报宗门。

而杨易，已经闭关第三天。

## 草棚 · 夜

静室之中。

杨易盘坐在石床之上，面容沉静，识海如炉，神意炽盛。

他已不再依赖外在灵气。

他的力量，来自于**极限的精神训练**，一种“靠练出来”的识力！

> 【系统提示】
> 【卷命灵识已启：当前进度 3.7%】
> 【是否进入“卷识幻境”，开启模拟训练？】

“进入。”

## 系统识海 · 幻境加载中……

一阵空间撕裂后，杨易眼前出现一座黑白相间的石殿。

殿内千面铜镜，每一面都映照着一个“他自己”。

有的披甲执剑，有的筋骨爆鸣，有的冥想如石佛，有的神魂破碎却依旧咬牙坚持。

> 【幻境·卷识迷宫】
> 【功能：精神模拟、意志磨炼、未来自我投影训练】

> 🎯 本轮目标：突破“识台九试”，提升识海活性
> 🎁 奖励：识力+5、意识容量+10%、开启“灵识神图”绘制功能

## 第一试：心火试炼

火焰幻境，烈焰焚心。

“你是个无灵根的外来者，你修不成的。”

“你没有天赋，没有依靠，只靠死练，值得吗？”

无数声音灌入脑海，似千万道锋利之针。

杨易闭目，心中却响起了自己在深夜独自训练时的低语：

“我不怕你说我蠢，我只怕你不让我练。”

他睁眼，怒吼一声，火焰幻影瞬间崩散！

> ✅ 第一试通过！精神抗压 +5！

—

## 第二试：镜像自我

铜镜前，走出一个与他一模一样的“杨易”。

“你练得再多，也不过是笑话。”

“你吃的苦，不值钱。”

“你打的架，不会被人记得。”

杨易却突然笑了。

“是啊，确实。”

“但我不是给别人看，我是——为了**打碎我命里那张‘不配修仙’的通知单！**”

他一拳轰碎铜镜！

> ✅ 第二试通过！意志判定 +3！

—

## 第五试：千念环绕

上千种念头化形为影，在识海之中环绕轰鸣。

“偷懒吧，累了。”

“你根本赢不了那些天才。”

“这修仙路，哪怕你拼尽全力，终点也不是你的位置。”

杨易忽然站直，全身仿佛一块熔炉凝铁。

“**那我就不是去‘赢’的，我是去‘抢’的！**”

“他们靠天命，我靠日练十六时、夜练六小时的卷命。”

“他们天生在前，我就在后头追着——咬住不放！！”

他双拳轰出，千念崩塌！

> ✅ 第五试通过！识力+2、反压耐性 +10！

—

## 第九试 · 终极卷命映照

最终一试，他站在识海最高的镜前。

镜中映出——**千年后的自己。**

此人满头白发，背负星河之重，一手翻日月，一指破寰宇。

“这就是……‘卷命大帝’？”

“你修到这里，花了多少年？”杨易低声问。

镜中之人淡淡一笑：“不是年，是**亿次训练**。”

“不是机缘，是**亿次失败**。”

“你还想卷吗？”

杨易咧嘴一笑：“还没卷够。”

镜中之人微微颔首，指尖一点，识海光海暴涨！

轰！！

识台彻底点燃！

一枚金色灵识火印在杨易眉心隐现，宛如神纹初生！

—

## 系统提示

> ✅ 卷识幻境通关成功！
> 🎁 奖励发放中……
> 🔥 灵识强度 +20！
> 🧠 意志抗性 +15%
> 🎨 解锁功能：【灵识神图绘制】
> 🧩 神图用途：通过极限冥想，构建自定义灵识技！

—

## 草棚外 · 众人惊变

“快看！那草棚上空……亮了！”

一道金色灵焰从棚顶腾空而起，宛如点燃星辉，凝而不散。

“他……灵根觉醒了？”

“不，不是灵根……是识火！他点燃了识火！”

—

## 林冰婉神色凝重

“这不是灵山宗的任何功法风格。”

“他……在自己造体系？”

她第一次真正感受到——

**这个人，可能不会属于任何宗门。**

**他，就是一个体系。**

—

## 草棚内 · 主角独白

杨易缓缓睁开眼。

整片识海，已不再是空白。

他在系统界面中，看到了自己第一幅“灵识神图”草稿——

一张由十万次深度冥想刻画而成的图像，名为：

> 《无限肝魂卷轮阵》

> 效果：每次突破临界时，可通过自残式苦修强行压榨识力，以自身意志替代灵气，临时提升修为一小境。

他眼神一凝，低声道：

“这才刚开始。”

**——第八章·完**

---

---
url: /novel/overachiever/pages/page6.md
---
# 第六章：炼体卷王初显威

竹禾村，村比大会，预选第一场。

天未亮，练力坪四周便已人山人海。

这是每十年一次的大事——凡年满十四的少年男女，皆可报名参加村比。优胜者将被推荐参与**灵山宗的门人选拔**，一旦入门，便能从此踏入真正的修仙之路。

而今年，最受关注的不是村长之孙石九山，也不是历年稳定入围的王大力，而是那个从草棚走出的**外乡卷王——杨易**。

—

## 村比开始前

“他来了！那个疯子来了！”

“听说他前天连夜砸石桩，砸到手都流血，还继续训练。”

“他现在已经炼体二重巅峰了吧？”

“可他练不到十天啊！怎么可能？！”

在人群的议论中，杨易步入场中。

他神情平静，身着简单粗布，目光沉稳，宛如一座山。

林冰婉就站在人群远处，身披灵山宗青袍，神色如霜，但眸中却带着一丝难掩的波澜。

“他，果然来了。”

—

## 村比预选 · 第一轮：负重冲刺

测试内容很简单：

**绑负铁块，绕练力坪奔跑三圈，用时最短者晋级。**

其他少年叫苦连天。

“五百斤！这也太重了吧？”

“我才炼体二重初期，腿都抬不起来！”

而此时，杨易径直走向最重的一副负重装——**六百斤的青铁套**。

众人瞠目结舌。

“他疯了吗？那套连大力哥都不敢碰！”

杨易只是淡淡一笑：

“铁不压身，苦不压卷。”

“你们跑三圈，我跑五圈。”

裁判差点以为自己听错了：“你说什么？”

“我跑五圈。麻烦帮我记一下时间。”他点点头，低头系紧负重绳索。

**“系统，训练模拟启动。”**

> 【卷道模拟开启】
> 【开启状态：极限奔行】
> 【筋肉支援、关节承压、肝力燃烧中……】

“预备——开始！”

—

## 轰！

杨易冲出起点，如奔雷卷地！

六百斤青铁在他身上，却被控制得稳如磐石，每一步落地如战鼓擂响，尘沙四起！

围观者倒吸一口冷气：

“那是人？！”

“他怎么像没绑铁一样快？”

第一圈——**十息！**

第二圈——**十一息！**

第三圈——**十二息！**

而其他少年，甚至还没跑完半圈。

“疯子……真疯了……”

更震撼的是，杨易竟真的继续跑了**第四圈**、**第五圈**！

每一圈，他的步伐都稳定如机械，没有丝毫松懈，直到最后冲线那一刻，他猛地跪地，吐出一口血，脸色苍白却眼神坚定：

**“报告！杨易五圈完成，用时56息！”**

全场寂静。

数息后，才爆出如雷掌声！

系统提示跳出：

> 【特殊完成：负重五圈，超额达成任务！】
> 【奖励：炼体经验+8%、肝力+5、筋骨强化+2】
> 【当前进度：炼体二重（92%）】

—

## 村比 · 第二轮：拳力测试

石桩前排起长队，每人需轰击一次，评测拳力强度。

石九山一拳轰出，破石达寸——爆发力为：**1100斤**

引来掌声一片。

“ worthy of炼体二重巅峰！”

杨易缓步上前，深吸一口气，双目紧闭。

**系统辅助模式开启**：

> 【预设动作组合：爆发蓄力 + 下沉震拳 + 闪链震臂】
> 【肌肉协调率：97%】
> 【引动全身爆发潜力】

他睁眼，暴喝一声：

“卷王冲拳！”

**砰！！！！**

整根石柱从中炸裂，碎石崩飞，场地震动！

测力石上浮现数字：

**“1420斤！”**

全场哗然！

连长老席上的铁骨老者都露出惊容：

“他真的是炼体二重？！”

系统提示：

> 【突破瓶颈临界！】
> 【触发炼体三重·觉醒试炼】
> 【即将开启：灵根觉醒路径】

—

## 村长议席 · 长老议论

“此子之志坚如铁，气贯全身，已显修道之姿。”

“以他此刻的修为与意志，若有灵根，绝对是天选之材。”

林冰婉终于开口：“他若能在最后一轮坚持下来，我将立刻递交‘外门特批名额’申请。”

—

## 村比 · 最后一轮：**肉体极限承压阵**

该阵为村长自制，需在阵中承受高频能压冲击三十息，不倒即为通过。

“我来。”杨易脱去上衣，露出结满老茧与瘀伤的身躯，毫不犹豫踏入阵法。

**阵法开启。**

一重重肉眼可见的波动涌来，宛如巨锤砸身。

第一息——汗如雨下！

第十息——血从指尖渗出！

第二十息——骨骼发出“咯咯”响声！

……

第二十九息，众人以为他要倒了——

**他却咬牙怒吼，全身爆发金红色热浪，筋肉膨胀一寸！**

**三十息！完成！**

轰！

他倒下，却神情畅快。

系统提示如天雷炸响：

> 【突破完成：炼体三重达成！】
> 【奖励：灵根觉醒钥匙 ×1、系统功能：灵识界域开启】
> 【提示：觉醒仪式已解锁，是否进入？】

—

## 场外

林冰婉俯身望着场中奄奄一息却笑意盎然的杨易，喃喃道：

“他果然……又卷赢了。”

—

## 草棚夜中 · 主角独白

夜晚，他独坐在星空下，系统提示浮现：

> 【灵根觉醒已就绪，是否即刻尝试？】

他低头看着自己满是伤痕的双手，眼神坚定如火。

“我从来没有灵根——”

“但我有命运的轮盘。”

“别人靠命，我靠卷。”

“那就——觉醒吧。”

—

**——第六章·完**

---

---
url: /novel/overachiever/pages/page11.md
---
# 第十一章：外门初入，卷王乱风起！

—

灵山宗·外门山脚下，晨雾缭绕，数百名新晋弟子整齐列队。

其中，最引人注目的，却是立在队伍最末那位衣衫褴褛、眉心残留神识印记的少年——

**杨易。**

—

## 灵山宗外门 · 简介

灵山宗的外门，表面是修炼启蒙地，实则资源之争最激烈的战场。

丹药、灵地、功法、器材、任务点位，皆按“贡献与战力”排名分配。

**换句话说——**

不管你有没有背景，卷不卷，打不打得过，都决定了你吃不吃得上修仙这碗饭。

—

## 初入分班

杨易被分入\*\*“竹鸣院”\*\*，这是灵山宗最底层的新弟子聚集区。

一进院门，就感受到十几道打量、讥笑、敌意和挑衅交织的目光。

“他就是那个逆命编号一号？”

“说是自创神识技？笑话，连灵气都不会引的凡人，还敢来这里跟我们争资源？”

“等资源排位战的时候，他就知道自己几斤几两。”

杨易一言不发，只把院内规章默背三遍，再次开启系统修炼界面。

> 【目标：三日内战力评定排名前百（当前排名：403）】
> 🎯 奖励：灵食、聚气草 ×3、识海巩固符 ×1

> 系统建议：使用**日程极限卷排法**模拟训练 72 小时
> 📌 预计提升战力评分：+60%

他直接点击启动：

【极限卷模式 · 启动】

—

## 三日后 · 资源战初赛

灵山宗设“资源留级淘汰制”，每月初有一场“资源排位战”，决定各弟子下月所分配的修炼资源。

此次初战，分组对抗，胜者晋级，败者无丹药、无灵田，仅能饮泉水、修粗法。

—

“杨易，对阵，云道凡。”

台下众人一片哗然。

“云道凡可是本届外门灵根前三，他修炼《玄火诀》，还开启了灵气循环通道！”

“那个无灵根的逆修者要凉了……”

—

## 比武台 · 正面对撞

杨易登台，神色平静。

对面，云道凡冷笑一声：“听说你识海强？可惜我们这比的，是灵力。”

“我一掌就能轰碎你这个逆命的笑话。”

杨易没理他，只在心中启动系统神识技准备。

> 🎯 卷识裂息击（压缩版）启动！
> 📌 模式：局部精准释放，攻击敌人神魂联络处！

“你敢先出手？”云道凡怒吼，真元爆涌，火焰自掌心炸裂！

但还未靠近，忽然心神刺痛，一瞬间意识模糊、五感失控！

“什么！？”

杨易身形一动，早已靠近他身边，手中猛地一劈！

砰——！

云道凡整个人被打翻在地，连滚三圈，昏迷不醒。

全场寂静。

—

## 系统提示：

> ✅ 战力评分更新：+145！
> 当前排名：87
> 奖励发放：聚气草 ×3、丹砂清露 ×1、识海巩固符 ×1
> 卷命识海强化进度 +8%

—

## 竹鸣院 · 震动

此战一出，整个竹鸣院沸腾！

“他真赢了云道凡！那可是灵根上品的修士啊！”

“他根本没用灵气，只靠神识和技巧压制？”

“这人疯了吗？精神力打架都打得赢？”

林冰婉远远地站在演武场边缘，听着众人惊叹。

她轻声一笑：

“他才刚开始而已。”

—

## 灵山宗外门殿 · 高层密会

监察使将战报送达大长老、沈副宗主之手。

“他用了自创技，在无灵气的状态下击败炼气一重。”

大长老面色阴沉：“越是不走正道，越是危险。”

沈落秋却看着战报，良久后缓缓道：

“一个不被天命承认的修士，正在用他的方式，打破命运的轨道。”

“我想看他能走到哪一步。”

—

## 夜晚 · 草舍之中

杨易盘坐于榻，系统界面缓缓浮现：

> 🎯 是否开启“自构神识技 · 第二篇章”？
> 📘 建议方向：多段识波连击、幻识干扰、战场识域

> 【提示】：开启“灵识副本”，可与历史卷王对战，快速模拟成长路径！

他微微一笑：

“那就来卷个未来。”

—

**——第十一章·完**

***

📌 **本章关键词**：宗门内卷、资源竞争、战力评分、神识压制、自创技能首次实战成功

📈 **主角当前状态：**

* 境界：炼体三重（即将突破）
* 灵识：已稳固（识力值 26）
* 技法：卷识裂息击（可压制灵气修士）
* 宗门地位：外门87名 · 特殊身份“逆命一号”
* 下一目标：自创神识技·第二篇 + 灵识副本开启

—

📘 **下一章预告：**

▶ 第十二章：**副本之门！卷王对卷王！**
→ 主角进入系统副本空间，与前代“系统卷修者”对战，模拟最强成长路径！

---

---
url: /novel/overachiever/pages/page17.md
---
# 第十七章：封顶令下！十日内卷战前十！

—

【灵山宗 · 外门战力榜 · 公告更新】

今日午时，全宗正式发布新的比斗制度：

> 【外门封顶令】
> 📜 即日起：
>
> * 凡未引灵入体之修士（即无灵根修士），禁止突破战力榜前十
> * 若强行排名进入前十，将被系统重置排名为“未定席”
> * 持续违规者，取消资源供给、剥夺比武资格

公告一出，震惊四座。

—

“他们……真的发布了。”

“这根本是针对杨易一个人的封杀吧？”

“太狠了，宗门就是不允许‘非灵根体系’威胁核心传承！”

—

## 草舍 · 杨易沉默许久

他看着系统弹窗中弹出的红色锁图：

> 当前状态：【排名上升受限】
> 🎯 条件破解中：主线任务【破局·阶段一】

> 目标调整：
> ✅ 击败任意两名榜前十修士
> ✅ 强行获得两次“挑战令归档记录”
> ✅ 激活宗门权限仲裁权·临时议席

杨易嘴角冷笑：“这哪是挑战修士，这是挑战体制。”

他缓缓拿出自己的玉简，开始为“十日计划”立档。

【卷破前十 · 十日挑战表】：

| 日程   | 对手（目标） | 境界   | 技法   | 卷战策略      |
| ---- | ------ | ---- | ---- | --------- |
| 第1日  | 孙景     | 炼气初期 | 水灵封阵 | 领域+识技破解流  |
| 第3日  | 谷清扬    | 炼气中期 | 幻风三式 | 图构干扰+反应杀  |
| 第5日  | 韩齐     | 炼气中期 | 雷灼术链 | 多图联动硬破    |
| 第7日  | 傅青     | 炼气后期 | 土墙遁封 | 副本演练+虚拟识战 |
| 第10日 | 宋傲     | 战力第3 | 火雷双爆 | 全图进化·终极卷压 |

“十天五战，每战向死。”

“但我，要让灵山宗看到——”

“**卷修**，不是旁门左道，而是未来。”

—

## 第1日 · 千云演武台

首战目标：**孙景**，炼气初期，精通水灵防御与控场。

战前，众人摇头：

“杨易的识图再强，也无法破水灵封阵吧？那可是专克精神流的阵法。”

孙景自信登场，抱拳笑道：

“杨师弟，封顶令你也看到了，你我这战，只是走个过场。你若认输，或许还能保留你那系统权限。”

杨易只答一句：

“你这水灵封阵，太慢了。”

开战！

孙景手掐法诀，周围水灵力化为波纹罩笼。

杨易却抢先一步：

【识波裂突·破限型】！

轰！！

一道卷识巨环直接轰穿了未成型的封阵，识压渗入其识海，孙景身形一颤，气机紊乱！

他惊恐吼道：“你这怎么破阵这么快？！”

“我打你一拳前，已经在脑子里打了两百次。”

杨易一记【破限体联突】，将其直接轰下演武台！

众人：……

“这卷得……简直不讲理。”

—

## 当日 · 系统提示

> 🎉【胜利达成！】
> ✅ 1/2 前十击破目标完成
> ✅ 解锁“挑战归档记录 ×1”
> 🎁 奖励：
>
> * 筋骨同步进阶
> * 技法进化选项：“裂环双卷杀·锁定版本”
> * 卷识强度提升至52（跨越炼气识阈）

—

## 夜 · 系统更新

> 【卷识进化：可构建“拟灵图”】
>
> * 描述：通过识息仿造“灵根波动”，短时间内模拟灵气术式结构
> * 意义：可混入灵根术流战斗体系，对抗灵气压制

杨易目光一亮：

“我没有灵根，但我可以卷出‘假灵根’。”

“用系统，演出来。”

他闭上眼，启动识图拟灵流程。

—

## 另一边 · 宗门主峰密会

掌律峰主、两名长老聚首，神情严峻。

“他真的击败了孙景？”

“你们难道还不明白，这不是他一个人的胜利，而是整个系统修士的突破。”

“再让他挑战第二人——他就可能通过系统任务晋级为宗门正式候补弟子！”

掌律峰主冷然一笑：

“既然如此，那就安排**谷清扬**提前动手。”

“给他下一场，埋个坑。”

—

📘 **——第十七章·完**

***

📌 **本章关键词**：封顶令实施、系统被限、主角立下十日五战目标、卷修 vs 灵根首次制度对决正式展开

📈 **主角当前状态更新：**

* 境界：炼体四重中期（识力临近炼气级）
* 战力排名：仍为第12位（系统冻结）
* 系统任务：破局阶段 1 / 2 完成
* 新技法结构：拟灵图（可用灵识模拟灵根术）

—

📘 下一章预告：

▶ **第十八章：幻风三式！系统对抗灵根术法！**
→ 谷清扬出战，擅长幻术与风刃，系统拟灵构图首次实战，主角挑战控制与判断的极限神图战！

---

---
url: /novel/overachiever/pages/page13.md
---
# 第十三章：战力榜挑战！天骄对决！

【灵山宗 · 外门 · 战力榜公告台】

榜单每日更新，前百可得修炼资源、灵田丹药，前十更享有“灵气聚脉屋”、专属任务通道等宗门特权。

而今日，榜单前十的界面更新时，多了一个陌生名字：

> 📌 排名第87：杨易（逆命编号一号）

这一下，整个外门瞬间炸开了锅。

—

“那个无灵根的卷命修士？”

“他居然挤进了前百？而且还稳定了？”

“这人真疯了，居然卷进榜单来了？”

“不行，这种逆体系的修士，必须被压下去！”

外门第十三位的天骄**宁尘**，冷冷看着榜单，拔下自己的战帖玉简，灵力一震：

> 【挑战令已发出】
> 📌 目标：杨易
> 📅 比武时间：次日正午
> 地点：万灵演武台 · 外门场域

—

## 草舍 · 晚间

杨易刚完成副本归来，系统提示响起：

> 【收到战力榜挑战令】
> 发起者：宁尘（外门排名13，风雷灵根）
> 胜利奖励：
> ✅ 系统模块碎片×1
> ✅ 神图灵感·进阶链接思维
> ✅ 卷命权限提升：开启自定被动技构建

杨易看着“风雷灵根”四个字，眉头微挑。

> 【提示】：风雷类修士攻速极快，识海波动剧烈，注意节奏压制

他冷静地调整系统日程：

* 【夜间】：加训神图融合（识环 + 裂息）
* 【晨起】：模拟对战副本一次
* 【正午】：战场应战

他嘴角勾起一抹微笑：

“我，就是来搅乱你们这个榜单结构的。”

—

## 翌日 · 万灵演武台

高台之上，弟子成群，执事长老也现身观战。

宁尘着一袭风衣，背负雷纹长剑，双瞳微闪雷芒。

他冷哼：“我不管你怎么上榜的，今天，你得下来。”

杨易淡然走上台，整整一夜未眠，识海仍稳定如山，神图已融合就绪。

> 🎯 技法：
>
> * 【裂息击】（识爆）
> * 【识环阵】（抗压）
> * 【融合态】：裂环双卷杀（攻守合一）

执事一声令下，战斗开启！

—

## 开局三息 · 风雷裂场！

宁尘率先出手，剑未至，人影已化雷光，灵气如电蛇撕裂空气！

“风雷断魂剑！”

砰！

一道紫电劈向杨易眉心，足以令普通修士识海瞬间裂散！

然而——

杨易不闪不避，神识微动，一道透明识环如镜挡下！

轰——！

两道力量对撞，识环如波纹震荡，虽被压碎，仍将大半冲击力抵消。

“还有下一击。”

杨易踏步而上，手指一扣识图：

> 【裂环双卷杀·释放】

只见神识如狂潮爆裂，从他身后涌出十数重识波链，仿佛猛兽出笼！

“识压连锁？！”

宁尘大惊失色，风雷剑仓促斩出，但已慢了一线！

识波直轰其识海核心！

砰——！！

他一声闷哼，跪地吐血！

—

全场寂静。

三十招？不，三招！

天骄宁尘，败！

—

## 系统提示：

> 🎉 胜利达成！
> ✅ 奖励结算中…
>
> * 战力评分 +65（当前排名：第36位）
> * 卷识融合评分：优秀
> * 获得神图灵感：【识波连弹术】
> * 模块碎片 +1
> * 可解锁模块：**被动神图·构建功能**

杨易缓缓收回神识，体内震荡未息，但眼中满是坚定：

“这，就是我的路。”

—

## 竹鸣院 · 异动

消息传回外门各院，整个修士群体陷入动荡。

一个无灵根的卷修者，靠系统融合识图，在实战中压制传统风雷灵根！

“他，已经不是那个底层凡人。”

“他，是灵山宗最不可预测的人。”

—

## 外门执事会议

“他融合神识技，胜了宁尘。”

“他还在不断升级自己的体系。”

“再这样下去，他可能挑战——前十。”

大长老沉声道：

“继续观测。一旦他走火入魔，即刻镇压。”

而沈落秋副宗主，却只看着战报轻轻笑道：

“你们这些只看‘灵根’的人，还真没见过什么叫——**体系碾压**。”

—

## 夜 · 草舍中

系统开启新功能：

> ✅ 被动神图构建系统开放！
> 🎯 可构建以下类型：

* 【识压减伤类】
* 【卷力回复类】
* 【意识反弹类】

杨易摩拳擦掌，默默点开【卷力回复类】，取名为：

> 📘《打工魂息 · 卷修恢复环》
> 描述：在识力消耗后，进入5秒“低频识图冥想”，每秒回复1点识力，最多回复至30%

他笑着说：

“卷得多，也得卷得久。”

—

**——第十三章·完**

***

📌 **本章关键词**：宗门天骄挑战、融合技实战、自创神图击败灵根天才、被动技能系统解锁

📈 **主角当前状态更新：**

* 境界：炼体三重巅峰，蓄势待突破
* 排名：第36位（灵山外门）
* 技法状态：

  * 主动技：裂环双卷杀
  * 被动技：打工魂息 · 卷修恢复环
* 系统状态：副本系统开启、构图自由度增强、模块系统激活中

—

📘 **下一章预告：**

▶ **第十四章：识海突破！炼体极限冲破枷锁！**
→ 主角识力先行，逼迫肉体突破极限，正式踏入“炼气”前的神魂觉醒阶段，身体与识海同步进化！

---

---
url: /novel/overachiever/pages/page19.md
---
# 第十九章：极限计算！神识推演决杀韩齐！

风起云涌，灵阵森然。

演武场西侧，第三位擂台挑战者缓缓步入场中。他身披深蓝雷纹战袍，脚步每落，虚空间便隐隐传出电弧激荡之声。那是雷灵根修士独有的灵气扰动，迅猛、暴烈、不羁。

“第三位挑战者，天河宗外门第二，‘雷动九霄’韩齐！”

擂台四周，看台席上爆出一片掌声和惊呼。韩齐出身寒门，外门苦修七载，以快准狠著称，已连续两年位列外门考核前十，被认为是本届收徒中最难缠的一员。

韩齐目光锐利，淡淡扫视擂台，最后落在李牧身上，冷笑道：

“你，就是拟灵图的‘外乡野子’？挺能装的嘛，连破两阵，斩一人。可惜，你的好运到头了。”

李牧此时盘膝于阵图中央，五指指尖淡淡灵光游走，眼神平静无波，仿佛未将韩齐放在眼中。

“我不靠运气。”李牧淡然回应，“我靠计算、推演、努力——还有对修行的执念。”

“哼，嘴硬！”韩齐猛然踏前一步，身形竟直接拉出一道雷电残影！

“雷影步·连闪！”
“雷牙指·五击断魂！”

轰！轰！轰轰轰！

几乎是在一瞬之间，韩齐连续五次瞬身突击，配合雷系灵技将攻击精准打向李牧拟出的拟灵阵图中心死角，快如雷霆，宛若电蛇缠身！

但诡异的是——每一次攻击临近目标前，皆被一道光纹强行引导偏斜，仿佛被“计算”过一样，全部落空！

韩齐眉头一跳：“什么？”

看台上，一些擅长神识的修士已看出端倪。

“他……他用神识联动阵图，在战斗中实时推演韩齐的进攻轨迹！”

“什么？这小子神识有这么强？”

“简直是疯子！他是用神识当CPU推演战局吗？这得多卷啊！”

“你说这叫卷？”席间突然有人冷哼一声，“他是神魂多线程并行计算！是真正的天才型苦修疯子！”

李牧指尖微动，心神沉入拟灵图深处，光幕中，上百道灵纹流转如水，实时调整阵眼与气流方向，同时根据韩齐出手规律模拟出“百种可能路径”。

“雷灵修士的攻击节奏是变速曲线，第一击最快，后三击延迟收缩，我只需在阵中布下三重缓冲回旋阵，加一记风引——”

轰！

韩齐第六击终于突破李牧一层灵阵，打碎两道灵纹光柱。

但下一瞬，他自己也突然呛了一口气——

他竟然……被李牧借力“引阵”，打入阵心深处！

“困阵起！”
“水引·风缠！”
“雷封·回流锁灵阵！”

李牧眸光如电，手指连续掐诀！

轰隆！

阵法中央，骤然浮现一个旋转的倒金字塔阵核，将韩齐封困其中，雷电被牵引压制，动弹不得！

“你……！”韩齐怒吼。

李牧缓缓站起，眼神凌厉：“你太快，但快不过计算。”

他抬手虚握，五指如钩，灵光一闪！

“阵图决杀·模拟雷劫！”

瞬间，上方雷云凝聚，由阵图催动的虚拟雷劫骤然降临，一道雷光击中阵中韩齐！

砰！

韩齐喷血倒飞而出，气息暴跌。

——胜负已分！

……

四周一片死寂。

看台上所有弟子、长老、执事都神色复杂地望着李牧。

“他不是战斗力强，他是……把整个战局用神识‘算’赢了！”

“什么拟灵图啊，这是阵术与神识的极限碾压！”

“韩齐败得不冤。”

……

主台上，风成山眼神微凝，口中喃喃：“此子，不可小觑。”

他身边的白衣少女轻轻颔首，声音第一次认真：“他不是走运，是提前预演了每一场战斗的千种可能。”

“他的神魂……简直不像是凡体。”

……

擂台上，李牧静静收起拟灵图，抬头看向擂台尽头。

他的眼中，依旧清冷如初。

“还有七位。”

“继续卷。”

---

---
url: /novel/overachiever/pages/page12.md
---
# 第十二章：副本之门！卷王对卷王！

**夜，灵山宗·竹鸣院。**

杨易完成了今日资源战，回到草舍，体内疲惫不堪，神识却异常活跃。

他已稳坐外门前百，完成三日死卷之约。

但他知道——

这，只是内卷修仙界的第一层。

—

## 系统提示：

> 【检测到宿主达成多重成就】
> ✅ 自创神识技成功实战
> ✅ 战力突破预估上限150%
> ✅ 精神韧性评级：S+

> 🎯 符合条件，是否解锁系统深层副本模块：
> **「卷命副本·灵识对练场」**

【功能说明】：

* 模拟历代“系统修士”投影意志
* 与历史上已失败或登顶的“卷修者”对战切磋
* 每一场胜利可获取：识力提升点、自定义卷图灵感、系统模块碎片

杨易盯着面板，毫不犹豫地确认：

“开启。”

—

## 【卷命副本 · 启动中……】

【加载历史投影：编号·卷王0009】

> 姓名：韩阅
> 出身：七荒大陆边陲煤矿
> 修炼体系：极限劳身识炼流
> 评语：九年不眠，生吞玄火石炼识，曾以凡人之躯拼死冲击元婴，最终识海崩溃而亡

【本场目标】：

* 持续撑过5分钟识压对轰
* 副任务：破解其“负重千识壁”技法一式

—

## 场景切换 · 副本开启

杨易睁眼，置身一片灰褐色的废墟矿场。

对面，一个干瘦如柴、却全身缠绕锁链的男人盘坐于燃烧的石坑中。

那人缓缓睁眼，沙哑而平静地问：

“你就是新的系统之子？”

杨易沉声回答：“不，我是**系统打工人**。”

韩阅微微一愣，随即低笑：“好，打工人。来试试，你能抗我几击？”

“【负重千识壁】。”

轰！！！

杨易瞬间感受到整片识海如被十万吨铁锤碾压，几欲崩溃！

—

## 第一轮 · 卷识裂息击启动！

他咬牙强撑，逆转识息，将“卷识裂息击”爆发而出！

火光流转间，两股神识炸裂，副本空间剧烈动荡。

【时间进度：02:14】

“不错的识爆结构，但不稳。”

韩阅声音低沉如铁：“你练这招，用了多久？”

杨易擦去鼻血：“三天。”

韩阅起身，一字一句：

“那你……不够卷。”

—

## 第二轮 · 识技交锋

韩阅抬手，又是一击“负重千识壁”！这一次附带“多点切割”效果，神识如无形之刀斩入意识海！

杨易识海剧烈动荡，脑中如裂，几近昏厥！

> 【提示：识海即将崩溃，是否开启极限卷图自动演算防御？】

“开启！”

—

## 系统自演技法启动中……

> 自动推演构图中：
> 【构图名：《识环抗压阵·初型》】
> 效果：将识压折返，自身形成多重识气泡缓冲，最多抵消一次识海级爆炸！

杨易低喝一声：“撑住——！”

轰！

整片识海爆鸣，他强行把自己拉回意识中，咬破舌尖清醒，眼神重新锐利！

【时间进度：04:47】

—

## 第五分钟 · 意志之战

韩阅目露讶异：“你已经超越我当初第五分钟的承压极限。”

杨易缓缓起身，识海虽溃但不乱，声音嘶哑：

“我没有天赋，我也不聪明，我只是在不断地练习，不断地死卷。”

韩阅默然良久，忽然躬身鞠躬。

“你……赢了。”

—

## 系统提示：

> ✅ 卷命副本通关！
> 🎁 奖励结算中……
>
> * 识力提升：+8
> * 卷识构图灵感：新增【防御系卷阵】
> * 系统模块碎片 ×1（可用于解锁下级功能）

> 新功能预览：
> 【卷图复合构建】开启条件已达成 75%
> 【卷压融合技】可用：将两个神图技合并

—

## 场景淡出 · 副本结束

韩阅临别前低声道：

“我死在突破那一晚，因为没人告诉我——可以练防御。”

“你……告诉后来人吧。”

杨易微微点头。

—

## 返回现实 · 草舍黎明

他睁眼，满头冷汗，识海仍然震荡不休，但却感觉前所未有地清醒。

“原来‘卷’也要讲方法。”

“不是单点爆破，而是构建体系、连锁演算。”

系统面板上，一条新功能悄然解锁：

> ✅ 新构图技法已获取：
> 【识环抗压阵】（防御类）
> → 可防一次灵识级冲击
> → 可与“卷识裂息击”融合为【攻守一体式卷图】

杨易缓缓吐出一口气，眼神坚定如铁：

“我，要卷得更系统。”

—

## 灵山宗 · 外门演武堂前

同一时间，灵山宗战力榜前十中，数位天骄陆续得知“杨易进入副本并全胜”的消息。

其中一人，冷声开口：

“是时候让他见识什么叫**宗门真正的卷**了。”

—

**——第十二章·完**

***

📌 **本章关键词**：副本系统、系统前代卷王、技能融合、防御构图、自我体系优化

📈 **主角当前状态更新：**

* 境界：炼体三重巅峰（临近突破）

* 灵识：强化后识力 34

* 技法更新：

  * 【卷识裂息击】（攻击技）
  * 【识环抗压阵】（防御技）
  * 【融合技（可开启）：裂环双卷杀】

* 系统新功能：副本挑战、神图合成、灵感构建体系

---

---
url: /novel/overachiever/pages/page15.md
---
# 第十五章：灵根者来袭！系统卷修首次对炼气！

—

【灵山宗 · 外门 · 千云演武台】

比武榜新一轮挑战开启。

而这一次，打破常规的是一条特殊公告：

> 【挑战申请】
> 发起人：方厉（外门战力榜第11）
> 境界：炼气一重
> 灵根：雷火双灵根
> 挑战对象：杨易
> 指定理由：破除系统邪道之名

这条消息一出，灵山宗外门瞬间如山雷炸裂。

—

“炼气境挑战炼体者？”

“而且还是挑战杨易？！”

“方厉可是风雷双灵根的亲传候补！他这是在下杀手锏！”

—

## 草舍 · 系统提示闪烁

> 【警告】：对方为炼气一重，已形成灵气内循环，可进行长时间输出，识防强度高于识技攻击阈值20%

> 🎯 当前胜率预估：41%
> ⚠️ 建议：
>
> * 提前布局场域
> * 利用新技“破限突击”进行奇袭
> * 主动释放“卷压领域”扭转节奏

杨易神色凝重，却毫无退意。

“终于来了……正面挑战传统灵根体系的人。”

他走出草舍，目光如电：

“那我，就让你看看，什么叫系统·压·制。”

—

## 正午 · 千云演武台下

上千名弟子聚集观战。

方厉一袭火纹劲袍，手中灵剑震荡雷光，气息强大，显然已将灵气循环炼至小成。

“杨易，三日内你连败二十六人，自称无灵根也能修行，今日我便替宗门清理门户。”

杨易平静回应：

“我只是打一份工，你非要让我把你卷下去。”

执事皱眉：“你确定应战？你尚未筑灵根，若败，恐伤及神识本源。”

杨易淡然：

“我的命，是卷出来的。你别替我心疼。”

—

## 战斗开启！

方厉当即出手！

【雷火穿心指】！

一道炽烈雷火气劲穿空而来，破空裂响，直奔杨易眉心！

轰！！！

空气扭曲，灵气爆鸣！

但众人还未看清——

一道识力波纹骤然成型，宛如无形水幕，瞬间在杨易身前展开！

【识环抗压阵·主动启动】

识波撞雷，灵火瞬间被识息分流，引爆于杨易前方一丈外！

“什么！？这不是识海才有的护法阵？”

“不对，这像是识图构建类——主动防御卷技！”

—

方厉大怒！

“那再试这一招——雷火连锁剑阵！”

轰轰轰轰——！

十数道雷火飞剑从他袖中爆出，结阵围杀，杀气逼人！

杨易咬牙：

“系统，启动新构图。”

【破限突击·识爆体联——激活！】

他脚下猛地一震，识图与肉体协同联动，双拳包裹识力，化为识爆拳锋！

“破！”

砰砰砰砰——！

他的拳头如重锤击鼓，接连轰破五道雷火剑！

其余数道穿体而过，却被体内新生成的筋骨识纹直接震散！

杨易吐血倒退三步，强撑身形怒喝：

“继续卷！”

【卷压领域·开启】！！！

—

## 系统新技 · 实战首用！

只见他识图化境，一道无形场域自脚下铺开三丈，蔓延而出，所过之处空气似被冻结。

> 【卷压领域】说明：
>
> * 范围内识力波动放大150%
> * 对敌识域判断误差提升
> * 技法释放延时0.3秒

—

方厉面色剧变！

“什么！？我动作怎么慢了半拍？”

杨易眼中冷光一闪，识图再次跃现！

“裂环双卷杀！”

轰——！！！

识图链式波纹爆发，将方厉整个身体卷入光爆核心，灵火失控，雷霆激散！

“啊——！”

方厉怒吼中被炸出台外，重重砸在演武台下的青石地上，浑身焦黑、气息虚弱！

全场一片死寂！

下一刻——

**沸腾！**

—

## 灵山宗高层 · 同时监看

沈落秋面露微笑：

“他的识图体系，已初具‘对抗灵气境’能力。”

大长老沉声道：

“这条逆修的路，居然真的有人踏上了……”

“若真放任其成长，灵根体系，将动摇。”

—

## 系统提示：

> ✅ 胜利达成！
> 🎁 奖励结算中：
>
> * 战力提升 +122（当前排名：第12）
> * 解锁新识图模板：【链式穿识】
> * 模块碎片 ×2
> * 开启资格：**系统进化·版本升级 Alpha-2**

杨易抬头望天，额头滴血，眼神却像钻石一样硬：

“我，不需要灵根。”

“我只需要——**卷得够狠**。”

—

**——第十五章·完**

***

📌 **本章关键词**：首次对战炼气修士、识图领域控制、攻守一体构图、体系冲突升级

📈 **主角当前状态更新：**

* 境界：炼体四重中期
* 战力榜排名：第12位
* 技法体系：

  * 主动技1：裂环双卷杀
  * 主动技2：破限突击·识爆体联
  * 被动技：打工魂息 · 卷修恢复环
  * 领域技：卷压领域（NEW）
* 新技能研发中：【链式穿识】（控制类）

—

📘 下一章预告：

▶ **第十六章：灵根动摇！宗门危机初现！**
→ 杨易连胜突破灵气体系，宗门内部高层开始争论是否彻底改变入门标准，一场传统与革新的大争议即将爆发！

---

---
url: /novel/overachiever/pages/page18.md
---
# 第十八章：幻风三式！系统对抗灵根术法！

—

【灵山宗 · 外门演武台】

第三日清晨，主角第二场挑战如约而至。

对手：**谷清扬**，战力榜第九，炼气中期，风灵根，擅长控速与幻术。

此人因天赋出众，已被内门长老列入“亲传种子”名单。此次提前应战，被视为宗门对杨易系统体系的一次精准打击。

—

“你不是要卷进前十吗？”

“那我便让你知道，什么是天赋与灵根的不可逾越。”

谷清扬语气冰冷，脚踏风印，衣袍翻卷如刃。

—

## 开战前 · 系统提示

> 🎯 对手属性：风灵根（二品）
> 📌 术式特点：高速位移+幻象干扰+多段风刃追击
> ✅ 建议：拟灵图激活【风识拟构】，同步反演风势轨迹

杨易深吸一口气，指尖轻弹，光影浮动：

> 🔓 启动拟灵图：**风拟式·初级**
> 描述：通过识力模拟风灵术式的波动轨迹，短时间获得术式对等性（60%效率）

—

## 比武台 · 开战！

“幻风三式·影风！”

谷清扬身影化作三道残影飞掠而出，台上尘沙翻卷，仿佛三人同时出手！

呼——！

数道风刃交错斩向杨易！

普通人根本无法分辨虚实！

—

【系统辅助分析】：影身概率排序中……

> ✅ 真身锁定完成：东南 22 度偏离 4.1 米处
> ✅ 拟灵识图锁定风场！

“你太慢了。”

杨易一记**识波裂指**直击虚空！

砰！！！

风影炸散，一道身影从空气中跌出，正是谷清扬！

“什么！？你居然能破我第一式！？”

—

“再来——幻风二式·缠风锁境！”

谷清扬怒吼，双手结印，整个演武台忽然狂风四起，气旋环绕，天地如入漩涡！

幻境起，空间感模糊，甚至连杨易脚下的地面都似乎失重一般变形！

—

但杨易眼神如电，沉声低语：

“系统构图——【卷压领域·识域稳定模式】！”

轰！

他以自身为核心，展开识图领域，重塑“真实感知”，瞬间扭转幻风感知扭曲！

场景在他识海中重新分层解构：

* 幻象层
* 风压层
* 气旋结构层
* 真身轨迹层

他猛地踏步而出，拳光裹识如雷霆突袭：

“【破限体联突·压秒模式】！”

砰！！！

谷清扬尚未脱出幻风术式，即被杨易一拳轰中胸口，识息紊乱，吐血倒飞！

—

## 台下一片惊呼！

“风灵根竟然被压制了？”

“这杨易……不是没有灵根吗？那他刚才模仿出的风灵气感，是怎么回事？！”

“这家伙根本不是战斗，他是在演算法运算！”

—

## 谷清扬挣扎而起，怒目相视

“你……你究竟是怎么破解我这幻风术的？”

杨易淡淡开口：

“你靠风速迷惑敌人，我靠计算模拟每一道风势轨迹。”

“风乱你的敌人，计算乱你自己。”

“你以为你是术士，其实你只是个数据样本。”

—

## 系统提示更新！

> ✅ 第二次击败榜前十修士，破局任务第一阶段完成！
> ✅ 解锁系统升级通道【Beta版本 · 启动中】

🎁 奖励如下：

* 解锁新构图槽位 ×1
* 技能分支构图系统激活（可一技多形）
* 系统模块碎片 ×2
* 识图推进率提升至78%
* 获得称号：【拟灵识修】（标志性成果：模拟术压制术）

—

## 外门议论如潮

一战定势！

幻术失效，灵根被算计，风灵败北！

此战之后，再无人敢称杨易为“无灵根”劣等者。

甚至有人提出：

“也许他的识图，就是新时代的‘伪灵根’。”

“以智慧代替血脉，以算法构建天赋……”

“这或许，就是灵山宗第二修行体系的雏形。”

—

## 主峰 · 长老殿

长老们神色复杂：

“他真的又赢了？”

“而且，是在对方术法完全展开的状态下？”

一位白袍老者轻声道：

“是时候，承认他具备成为‘第二路径继承人’的资格了。”

掌律峰主脸色铁青，冷哼：

“哼——下一战，我要让他连‘拟图’都画不出来。”

—

📘 **——第十八章·完**

***

📌 **本章关键词**：拟灵图实战、术法反推破解、幻术失效、系统突破升级、主角斩第二人

📈 **主角当前状态更新：**

* 境界：炼体四重末期（识力已临炼气界限）
* 战力排名：系统冻结（名义第12）
* 技法体系：

  * 主动技：裂环双卷杀、破限体联突
  * 被动技：卷修恢复环
  * 领域技：卷压领域（识域稳定增强）
  * 新构图：拟灵图·风识版
  * 模块：技能分支构图（NEW）

—

📘 下一章预告：

▶ **第十九章：极限计算！神识推演决杀韩齐！**
→ 第三位榜前十将由雷系速攻修士韩齐登场，主角拟灵图将接受连续破阵与连击压制测试！

---

---
url: /novel/overachiever/pages/page16.md
---
# 第十六章：灵根动摇！宗门危机初现！

—

【灵山宗 · 主峰 · 议道堂】

这座建于山巅之上的古老宫殿，是灵山宗高层议事之地。

今日，因一名“无灵根者”连胜灵根修士，甚至战胜炼气强者，议道堂中高层齐聚。

—

“杨易。”

议道堂内，大长老目光肃冷地念出这个名字。

“一个连灵根都未觉醒的凡躯，竟靠自创神识技，连战连胜，现居外门战力榜第十二位。”

“他是奇才，还是——邪道？”

掌律峰主冷笑：“若人人不经灵根洗髓便能修行，那我等数千年之传承，岂不成了笑话？”

“宗门何以立基？”

但副宗主沈落秋轻轻叩桌：

“可你不能否认，他赢了。”

—

## 议道堂·争论升温

长老们分为三派：

* **守旧派**：以灵根论天命，视杨易为不敬天道之徒，应予限制。

* **观望派**：认为其尚未稳定，若有失控，恐生变故。

* **革新派**（少数）：认为这是“修行体系自我进化”的可能，主张观察并引导。

—

“副宗主，”大长老忽然冷声道，“你可知此子入门之初，体内识海已觉醒非凡？”

“他从未测试灵根，也未引灵入体，就敢挑战炼气之人。”

沈落秋不动声色：“那你想如何？”

“废其修为？驱逐宗门？你敢赌，他不是宗门未来的天骄？”

—

掌律峰主斜睨一眼，冷笑：

“如果人人都可以靠‘系统’修行，那还要我灵山宗何用？”

“今日我提议：设【封顶令】。”

“令内容如下：**凡未引灵入体者，禁入战力榜前十**。”

此言一出，全场震动！

—

## 另一侧 · 外门弟子之间暗潮汹涌

杨易的逆袭，已在外门引发深层波动。

不少灵根修士开始感到危机：

“他一人卷出了我们五年积累……”

“以后拼的不再是天赋，而是系统效率？这还让人修吗？”

—

更甚者，个别执事开始有选择性地**限制杨易任务接取**、延后资源发放。

草舍门外，系统提示缓缓浮现：

> 【宗门评级机制变动中】
> 🎯 检测到外部压制意图
> 🔒 触发系统自护规则：**系统主线晋升任务即将开启**

杨易眉头微皱，点开系统新任务界面：

> 🎯 主线任务【破局】（阶段一）开启！
>
> * 目标：强行杀入战力榜前十
> * 限时：十日
> * 难度：SS
> * 成就：开启“内门挑战资格”，并逼宗门承认系统修士合法体系

> 🎁 奖励：系统版本升级 · Alpha-2 → Beta-1
>
> * 解锁天赋融合槽
> * 自定义识图机制

—

## 草舍夜 · 杨易沉思

他静静翻阅宗门古卷，查看“历代修士突破灵根体系”失败案例。

尸骨无数，异变横生。

但他没有丝毫动摇。

“我既然能用识图压住炼气，那我便能卷出一个属于凡人也能修行的‘新路’。”

他望向夜空。

那片浩瀚星辰之中，藏着某种巨大的力量。

—

## 同时 · 宗门一角

一位身披黑袍的老者，站在古钟下低声呢喃：

“又一个‘逆命者’？”

“罢了……该做的，总要有人来做。”

他抬手，一道黑色传讯玉简飞出，目标直指宗门最深处——

【内门·试炼堂】

“送他入死地，让天道来决定……他，到底能不能逆。”

—

## 章节末 · 系统提示悄然更新

> 【主线任务·阶段一】激活中……
> ⚠️ 后续阶段将影响宗门等级结构
> 🧠 系统建议：立即构建“识海拟态副图”，以应对更高维度的精神干涉

> 🔓 同时解锁隐藏图技预览：

📘《识震九息图》
→ 高级领域技，释放后压制范围识域感知
→ 对炼气初期造成3秒识失盲区

📘《卷心构图阵》
→ 可在意识中同步“协修队友”识图
→ 支持多人战法构建

杨易闭上眼，低语：

“那就……来卷内门吧。”

—

**——第十六章·完**

***

📌 **本章关键词**：宗门议道、体制对抗、封顶令、系统主线任务开启、结构动摇前夜

📈 **主角当前状态更新：**

* 境界：炼体四重中期
* 战力排名：第12（遭遇人为限制）
* 系统状态：

  * 主线任务【破局】启动
  * 技能构图进阶筹备
  * 解锁路径：系统 Beta 版进化条件满足30%

—

📘 下一章预告：

▶ **第十七章：封顶令下！十日内卷战前十！**
→ 宗门封禁令颁布，杨易必须突破一切规则与封锁，在十日内击败至少两位炼气境榜前十，以实绩破除歧视！

---

---
url: /novel/overachiever/pages/page14.md
---
# 第十四章：识海突破！炼体极限冲破枷锁！

—

【灵山宗·竹鸣院】

经过数日资源战，主角杨易连续击败传统灵根修士、成功将“卷命识图体系”初步稳固，如今战力已压制大半外门弟子。

但，他的境界仍卡在：

> 【炼体三重巅峰】
> 📌 突破条件：
>
> * 识力：≥35 ✅
> * 肉体爆发强度：未达标 ❌
> * 需引发一次“极限肉体撕裂·自我重构”过程

换句话说，识海强归强，肉体还未“配套”，必须**破壳一次**。

—

## 系统提示：

> 🎯 启动【炼体极限突破】引导流程？
> 📘 方式推荐：
>
> 1. 卷力十倍速叠训，撕裂肌纤重塑骨纹
> 2. 接受“超阶副本·压力构图炼肉战”挑战
> 3. 混合法：实境+副本卷命叠加突破

杨易沉吟片刻，果断选择**方式 3：混合法**。

“我不能光练识，还得练打工的身体。”

—

## 草舍夜修 · 卷命启动！

> 【日程模拟】：
>
> * 00:00~02:00：铁线腿负重×500次
> * 02:00~03:00：拳法碎壁×300
> * 03:00~04:00：识波裂式冲击肉身腧穴
> * 04:00~06:00：副本交互模拟：重力极限室

这一夜，草舍里传出骨裂筋鸣之声，仿若利刃磨刀、狂风穿壁。

杨易衣衫尽湿，肌肉震颤，汗液如雨，不停低吼：

“再卷十下！”

“没破极，不许停！”

“系统，再给我加一次强识压负载！”

—

## 清晨 · 剧变！

当晨曦第一缕阳光洒落草舍——

杨易整个人瘫在地板上，浑身青紫，气息微弱，但系统光幕突发剧烈震动！

> 【识海冲击肉体壁垒】
> 【爆发值临界！】

轰——！

识海之力沿筋脉反卷，化为一道道金线灌入体内骨骼！

> 【神图识息已触发筋骨反应】
> ✅ 筋膜断裂 ×38处
> ✅ 骨纹共鸣 ×7处
> ✅ 自愈系数超常激活！

—

## 突破 · 炼体四重！

只听**咔咔咔**连续声响，他的骨骼仿佛被火炼一般重塑，肌肉中浮现微不可见的“识图锁印”。

每一次呼吸，识息都隐隐在体表萦绕。

> 🎉 【恭喜宿主，炼体四重突破成功】
> 📌 当前属性更新：
>
> * 力量：+42%
> * 脚程：+38%
> * 神识操控稳定度：+15%
> * 技法适配率：可容纳第二图技！
>   ✅ 新模块开启：【筋骨识纹同步构图】！

杨易睁眼，整个人如脱胎换骨。

“我不是天才。”

“我只是把每一滴汗，每一寸识，都卷进骨头里了。”

—

## 外门 · 修炼广场

这天，外门新一轮“斗力试演”开启，由执事随机挑选新晋者测试体魄与技艺。

杨易被点名上台，对战者为：

> 宋问舟：灵根五品，炼体四重后期，修《赤炎炼血诀》，精于体术

旁人低语：

“这次可难了，宋问舟是靠肉搏打上来的硬茬。”

“杨易识强不代表他真能打得过这等肉修。”

—

## 对战开启！

宋问舟大笑：“杨易是吧？听说你靠神识打的比我还猛？来，我就不信你不怕拳头！”

轰！

他双拳带烈焰杀来，劲风凛冽如刀。

但下一刻——

杨易双目一凝，**脚下一踏**，身形似电，识波微动，直接贴身绕至对方身后！

咚！！

一记重拳轰向宋问舟后腰，带起识息锁印残痕！

“你——怎么——”

砰！

第二击，膝击胸口！

砰！

第三击，裂识掌爆！

只三息，宋问舟连退七步，血气翻腾，双眼圆睁：

“你这家伙……明明没修气，却……”

倒地！

—

全场沸腾！

“杨易！真的是他！体术竟然也突破了！”

“这是炼体四重的极限吗？！”

—

## 系统提示：

> ✅ 技法容纳位 +1
> 🎯 是否构建第二识技？
> 🎁 推荐构图方向：
>
> * 【锁识缠绕】：持续干扰
> * 【破限突击】：神识+肉体共鸣撞击
> * 【卷压领域】：构造短暂识息场域

杨易微笑：

“给我构图：**破限突击·识爆体联**。”

“下一次，我要挑战——灵气境界的修士。”

—

## 同时 · 灵山宗主峰

沈落秋收到汇报，手指轻敲玉简：

“他已炼体四重，而且融合了神识与肉身？”

“快了，他很快就会走到第一重体系冲突点——炼气。”

“到那时，所有修真者都会看到一个问题——”

“到底是‘灵根’，还是‘意志’，决定命运？”

—

**——第十四章·完**

***

📌 **本章关键词**：极限修炼、自残式突破、识海反哺肉身、体术融合、突破炼体四重

📈 **主角状态更新：**

* 境界：炼体四重（初期）
* 技法：

  * 主动技1：裂环双卷杀
  * 主动技2：破限突击·识爆体联（新）
  * 被动技：打工魂息 · 卷修恢复环
* 系统模块：

  * 【副本挑战】
  * 【识图融合】
  * 【筋骨同步构图】（NEW）

—

📘 下一章预告：

▶ **第十五章：灵根者来袭！系统卷修首次对炼气！**
→ 外门精英突破炼气境，主动来战杨易，“传统体系”与“系统流”第一次正面对决！

---

---
url: /novel/overachiever/pages/page4.md
---
# 第四章：你炼三天？我炼三十天！

石九山的拳，再次轰在石桩上，沉闷有力。

“炼体二重巅峰”，这是他如今的境界。

作为村长之孙，他自小就被灌注最好的资源。每天三顿药膳，夜晚灵泉洗筋，再加上家传秘技——**“铁骨拳”**，整个竹禾村的同龄人里，没人能与之争锋。

可如今，他却不得不承认——**有一个人，打破了这个平衡。**

“草棚那疯子……竟然能登上卷力榜第一？”

石九山咬牙，望着新刷出的榜单。

***

### 📊【竹禾村·卷力榜】（更新后）

| 排名 | 姓名  | 日卷力值 | 累积总值 | 备注       |
| -- | --- | ---- | ---- | -------- |
| 1  | 杨易  | 512  | 2130 | 草棚疯子，已突破 |
| 2  | 石九山 | 270  | 1720 | 村长之孙     |
| 3  | 王大力 | 198  | 1430 | 村西壮汉之子   |

***

村民们也议论纷纷：

“听说杨易一周前还是炼体0重，现在已经一重巅峰了？”

“我看到他昨天夜里还在石堆上练断指撑！”

“石九山连续三天没出来训练，是不是怕了？”

“我听说他每天劈一千下木，还带负重跑十圈练力坪……”

“这也太卷了吧？”

—

## 草棚边 · 清晨

杨易正在新建的“负重磨轮”上进行训练。

这是他自制的：把两只水缸灌满，再用绳索绑在身上，围着大石轮转圈，用来练腿力与心肺配合。

“呼……呼……”

汗水浸湿衣襟，肌肉在撕裂中不断重塑。

系统提示音接连跳出：

> 【完成负重循环：训练效率+15%】
> 【突破临界进度：炼体一重（95%）】
> 【任务触发：是否挑战炼体二重者？】

“挑战？”杨易眯起眼，望向练力坪方向，“时候到了。”

—

## 村中练力坪

石九山站在场中央，双手抱拳，脸色冷峻。

周围聚集了十多个少年，还有几位村中长辈。就连巡山回来的猎户和农田里的人都暂时停工来看热闹。

“杨易要挑战石九山？”

“疯了吧？他才炼体一重！”

“不过他现在真有人看了，我听说连林家那位灵山宗的小女修也关注他了。”

“看，来了！”

—

## 杨易登场

一身汗湿的布衫，赤脚，手掌上老茧清晰可见。他走到练力坪中央，静静地站在石九山面前，神情平静。

“我想挑战你。”

石九山冷笑：“你觉得你配吗？”

“你炼了三年炼体，我才炼了七天。”杨易声音不大，但字字如锤，“但我不是来聊天的。”

全场安静了一瞬。

“七天？”

“他才炼七天？”

“吹牛吧？”

而石九山也终于按捺不住怒气，喝道：“既然你找死，我成全你！”

**砰！！**

石九山率先出手，一拳如铁锤般砸向杨易面门，劲风激起尘沙！

杨易却不闪不避。

在千百次的“系统冲击训练”中，他早已习得本能闪避与应变。

身形一偏，脚步如风，竟以一个不合常理的横斜步让开！

然后——反拳砸出！

砰！！

石九山一退再退，脸色顿变。

这一拳……竟带着**不属于炼体一重**的厚重力道！

“你不是炼体一重！！！”

“我突破了。”杨易嘴角轻扬，“炼体二重初期。”

“你……什么时候？”

“刚才你挥拳的时候。”

系统提示刚好跳出：

> 【实战冲击突破完成！】
> 【炼体二重已达成，当前进度3%】
> 【战斗状态加成：临战反应+15%、筋肉爆发+20%】

—

## 场中展开

石九山暴怒，连续使出“铁骨拳”三式，拳劲如雷，打得空气都在爆响。

而杨易身体灵活，步伐扎实，每一次闪避都像提前预判。

这不是天赋——这是他在“模拟训练模块”中用3000次假想对战磨出来的实战本能。

轰！！！

最终一拳击中石九山腹部！

后者喷出一口气，跪倒在地，眼神满是不甘：

“你这疯子……你到底怎么练的！”

杨易缓缓吐出一口气，抬起满是血痕的拳头：

“你炼三年，我炼三十天。”

“你一天练两个时辰，我每天练**十八个时辰**。”

“你靠资源，我靠意志。”

**“我卷死你，有问题？”**

—

## 村中哗然

众人噤若寒蝉。

他们看着那个孤身住草棚、练到满身伤的“疯子”，此刻站在练力坪中央，像一座无法逾越的山峰。

长老们交换了眼神：

“此子……虽无灵根，意志惊人。”

“若灵山宗真愿收其为杂役，只怕十年后也有造化。”

“他不一定真没灵根……听说有人修至炼体四重，灵根方显……”

—

## 系统提示浮现：

> 【支线完成：击败炼体二重者】
> 【奖励：低级灵石×1、系统特训模块开启】
> 【激活事件：“村比大会提前入榜”】
> 【冰灵线索推进度 +10%】

而此时，在村外山路尽头，一队身穿蓝白道袍的修士正在接近。

为首者，正是灵山宗外门女弟子——**林冰婉**，冰艳女主原身之一，正静静地看着村内比试的余波，眼底泛起一丝涟漪。

“这个人……值得一观。”

—

**——第四章·完**

---

---
url: /learning/core/modules/page2.md
---
# 箭头函数 vs 普通函数

> 在现代 JavaScript 中，箭头函数（Arrow Functions）和普通函数（Function Declarations/Expressions）是两种定义函数的方式，它们在语法、用途以及行为上有一些关键的不同点。以下是它们的主要区别：

### 一、语法差异

* **普通函数**：
  普通函数的定义方式较为传统，既可以作为函数声明也可以作为函数表达式使用。

  ```javascript
  function add(a, b) {
    return a + b;
  }
  ```

* **箭头函数**：
  箭头函数提供了一种更加简洁的语法来定义函数，尤其适用于简短的函数体。

  ```javascript
  const add = (a, b) => a + b;
  ```

### 二、`this` 绑定

* **普通函数**：`this` 的值取决于函数如何被调用。它可能指向全局对象（在非严格模式下），当前实例（对于方法），或 `undefined`（在严格模式下）。

* **箭头函数**：箭头函数不绑定自己的 `this` 值；相反，它会捕获并使用其定义时所在上下文的 `this` 值。这意味着箭头函数内部的 `this` 值与外部作用域中的 `this` 相同。

  ```javascript
  const obj = {
    regularFunc: function() {
      console.log(this); // this points to obj
    },
    arrowFunc: () => {
      console.log(this); // this points to the outer scope's this value
    }
  };
  ```

### 三、构造函数

* **普通函数**：可以作为构造函数使用，通过 `new` 关键字创建对象实例。

* **箭头函数**：不能用作构造函数，尝试使用 `new` 关键字调用箭头函数将抛出错误。

### 四、参数处理

* **普通函数**：支持 `arguments` 对象，它是一个类数组对象，包含传递给函数的所有参数。

* **箭头函数**：不拥有 `arguments` 对象，但可以通过剩余参数（rest parameters）实现类似功能。

  ```javascript
  function regularFunc() {
    console.log(arguments);
  }
  const arrowFunc = (...args) => console.log(args);
  ```

### 五、原型属性

* **普通函数**：具有一个 `prototype` 属性，这对于基于原型的继承很重要。

* **箭头函数**：没有 `prototype` 属性。

### 六、super

* **普通函数**：能通过super继承父类的属性和方法

* **箭头函数**：不能通过super继承父类的属性和方法

### 适用场景

* **普通函数**：适用于需要动态 `this` 值的场景，如对象的方法、构造函数等。

* **箭头函数**：更适合用于匿名函数表达式，特别是当需要访问父级作用域的 `this` 值时，比如在回调函数中。

### 总结对比表：

| 特性 | 普通函数 | 箭头函数 |
| --- | --- | --- |
| 语法 | 更加冗长 | 更为简洁 |
| `this` 绑定 | 动态绑定，依赖于调用方式 | 静态绑定，继承自外层作用域 |
| 构造函数 | 可以使用 `new` 创建实例 | 不允许使用 `new` |
| `arguments` 对象 | 支持 | 不直接支持，但可通过 rest 参数替代 |
| `prototype` 属性 | 存在 | 不存在 |
| super | 能 | 不能 |

---

---
url: /learning/category/page.md
---
# 系统性的温故而知新

### [系统性主页](/learning/category/page)

## 浏览器与网络

### ✅浏览器输入URL到渲染过程

::: details 详解

###### 一、用户输入URL

* 用户输入`URL`，按下`Enter`，浏览器检查输入的`URL`是否完整，如果不完整则当关键词搜索处理，跳转到默认的搜索引擎

###### 二、URL解析

* 提取出协议、域名、端口和路径等信息

###### 三、DNS解析(域名解析)

* 依次按 `浏览器缓存`、`操作系统缓存`、`路由器缓存`、`ISP DNS 服务器缓存`查询，如果都没有命中缓存，则依次从`根域名`、`顶级域名`、`权威域名服务器`递归和迭代查询，最终找到该域名的IP地址和更新各级缓存

**`优化点`：** dns-prefetch 和 preconnect，让资源提前DNS 解析和 连接，首屏优化非常有效

###### 四、TCP连接（三次握手）

* 客户端->服务端发送`SYN`: 请求简历连接
* 服务端->客户端发送`SYN-ACK`: 接收到请求，并同意连接
* 客户端->服务端发送`ACK`: 连接成功
* HTTPS TLS 握手
  * `Client Hello`: 浏览器->服务端发送发送 TLS 版本、随机数、加密套件列表
  * `Server Hello`: 服务端->浏览器发送 随机数、加密套件、证书（含公钥）
  * 密钥生成：客户端生成主密钥，用含公钥加密发送给服务端
  * 密钥会话生成后，后续通信都使用对称加密

###### 五、发起 HTTP(s) 请求

* 发送请求报文，包含请求行(user-agent、accept、content-type)、请求头、请求体

###### 六、服务端接收请求并响应

* CDN分发
  * 如果是缓存的静态资源，该请求有可能被分发到就近的服务器进行处理
* 缓存检查
  * 如果是强缓存（Cache-Control: max-age=xxx）的资源，则直接返回缓存，状态码200
  * 如果是协商缓存（Last-Modified/if-Modified-Since、Etag/if-none-match）的资源，则检查缓存，返回304 Not Modified
* 重定向检查
  * 如果返回的是301，永久性重定向到新的URL，下次访问直接访问新地址
  * 如果返回的是302，临时性重定向到新的URL，下次访问该网站依然还是会重定向
* 业务逻辑处理
  * 查询数据库、模板渲染SSR
* 返回响应报文，包含状态码、响应头、响应体

###### 七、接收响应并解析

* 解析HTML：构建DOM树
* 解析CSS：构建CSSOM树
* 合并CSSOM树和DOM树成render树
* 布局：计算每个元素的大小和位置
* 绘制：将每个元素的绘制到屏幕上
* 合并：合并多个图层，优化渲染

###### 八、加载子资源

* 在HTML解析的过程中，会加载js、css、图片等资源
* 会重绘和回流
* 会请求资源和请求数据加载数据渲染

**`优化点：`**

* 图片优化
  * 图片最好设置固定宽高，不然有闪烁问题
  * 图片懒加载和压缩
* 加载优化
  * 由于多个资源加载，可以开启HTTP2/3, 多路复用，提升并发多个请求的加载速度
  * 静态资源可以放在CDN，提升访问速度
  * 可以设置延迟加载，比如async、defer，或者使用懒加载
  * 静态资源可以进行压缩，比如gzip、brotli
  * 非首屏资源可以进行懒加载
  * 字体资源可以先设置font-display: swap
  * prefetch 、preconnect关键资源提前加载，非关键资源延时加载
  * 内联CSS样式，减少请求数
  * 使用 SSR（服务端渲染）或 SSG（静态生成）
  * 对关键资源使用 < link rel="preload"> 预加载。
  * 减少 DOM 嵌套层级，提高查找效率。
  * 将 JS 放在 < body> 底部，避免阻塞渲染。

###### 九、页面加载完成

* window.onload 事件触发

###### 十、断开连接

* 客户端->服务器发送FIN： 请求断开连接
* 服务器->客户端发送ACK： 同意断开连接
* 服务器->客户端发送FIN： 请求断开连接
* 客户端->服务器发送ACK： 同意断开连接
* 等待2MSL 时间后，等待最后一个ACK包被接收，TCP 断开连接

:::

### ✅事件轮询

::: details 详解

##### 作用

* 事件轮询是 JavaScript 引擎用来协调代码执行、处理异步任务的一种机制，确保主线程不会被阻塞，并保证异步操作能按顺序执行

##### 概念

* JavaScript 是单线程语言，意味着同一时间只能做一件事。为了实现异步非阻塞的能力，JavaScript 引擎通过 调用栈（Call Stack）、消息队列（Callback Queue） 和 事件循环机制 来管理任务调度。

##### 工作流程

###### 1. 调用栈（Call Stack）

* JS 引擎用来记录当前正在执行的函数调用。
* 函数调用时入栈，执行完成后出栈。

###### 2. 浏览器 API（Web APIs）

* 包括 `setTimeout`、`setInterval`、`DOM 事件`、`fetch` 等浏览器原生功能。
* 当这些异步操作完成时，它们会将回调函数交给“消息队列”。

###### 3. 消息队列（Callback Queue）

* 存放已经完成异步操作的回调函数。
* 例如：`setTimeout` 到时间后，其回调会被放入这个队列。

###### 4. 事件循环（Event Loop）

* 不断检查调用栈是否为空，如果空了，就从消息队列取出第一个回调推入调用栈执行。
* 这就是事件循环的核心逻辑。

#### 宏任务 & 微任务（Microtask）

| 类型 | 示例 | 特点 |
|------|------|------|
| 宏任务（Macro Task） | `setTimeout`, `setInterval`, `I/O`, `UI 渲染`, `script` 整体代码 | 每次事件循环执行一个宏任务 |
| 微任务（Micro Task） | `Promise.then/catch/finally`, `MutationObserver`, `queueMicrotask` | 在当前宏任务结束后立即执行，优先于下一个宏任务 |

#### 执行顺序规则：

1. 执行同步代码（整个 script 是宏任务）
2. 同步代码执行完，清空微任务队列
3. 取出一个宏任务执行，重复上述过程
   :::

### ✅跨域

::: details 详解

##### 什么是跨域？为什么会出现跨域？

* 跨域是指浏览器因为 **`同源策略（Same-origin policy）`** 的限制，阻止从一个不同协议（HTTP/HTTPS）、不同域名、不同端口加载资源的行为。
* 同源策略的三个条件
  * 协议相同
  * 域名相同
  * 端口号相同
  * 只要有一个不相同，就会触发跨域

#### 常见解决方案

* 后端设置 CORS（推荐）
  * CORS（Cross-Origin Resource Sharing） 是一种 W3C 标准，后端通过设置响应头允许跨域
  * 常用响应头：
  ```JS
  Access-Control-Allow-Origin: * 或 http://example.com
  Access-Control-Allow-Credentials: true
  Access-Control-Allow-Methods: GET, POST, PUT, DELETE
  Access-Control-Allow-Headers: Content-Type, Authorization
  ```
* 使用 Nginx 反向代理（上线推荐）
* WebSocket 跨域 :WebSocket 本身不受同源策略限制，可以直接跨域连接。但服务端仍可做限制

#### 常见问题

* 1. 为什么浏览器要限制跨域？
  * 为了防止 **CSRF（跨站请求伪造）** 攻击，保护用户数据安全
* CORS 是如何工作的？
* 浏览器在发送请求时自动加上 Origin 头，服务器响应时带上 Access-Control-Allow-Origin，如果匹配，浏览器才允许前端访问响应内容。
* OPTIONS 预检请求是什么？
* 对于复杂请求（如带 Authorization、Content-Type: application/json 的 POST 请求），浏览器会先发送一个 OPTIONS 请求进行预检，确认服务器是否允许该请求。
* 如何解决上传文件跨域
  * 上传文件时使用 FormData + fetch 或 XMLHttpRequest，后端需设置 Access-Control-Allow-Origin 和允许的 Content-Type 类型。\
    :::

### ✅HTTP1.1 与 HTTP2 区别

::: details 详解

* HTTP2 是二进制传输，HTTP1.1 是文本传输，HTTP1.1 是明文
* HTTP2 支持开启多路复用，可以同时处理多个请求
* HTTP2 支持头部HAPCK压缩
* HTTP2 支持设置优先级
* HTTP2 服务器推送
* HTTP2 通常加密（推荐TLS）
  :::

### ✅OPTIONS 预请求

::: details 详解

##### 定义

OPTIONS 请求是浏览器在发送某些跨域请求之前，自动发起的一个“探路”请求，用于确认服务器是否允许该跨域请求，这就是 CORS 中的预检机制（Preflight）

##### 触发 OPTIONS 预检请求条件

* 使用了除 GET、HEAD、POST 以外的方法
* 设置了自定义请求头
* 设置了自定义的 Content-Type

##### OPTIONS 请求工作流程

* 浏览器向目标服务器发送一个 OPTIONS 请求。
* 服务器根据这些options请求头信息决定是否允许请求，并返回相应的响应头
* 如果服务器允许，则浏览器继续发送真正的请求；否则，阻止请求并报错
  :::

### ✅状态码详解

::: details 详解

1. **信息性状态码（100–199）**：
   * 100 Continue：服务器已接收到请求头，客户端应继续发送请求体。
   * 101 Switching Protocols：服务器已理解客户端的请求，并将通过升级协议来完成后续通信。

2. **成功状态码（200–299）**：
   * 200 OK：请求成功，所希望的回应头或数据体将随此回应返回。
   * 201 Created：请求已被实现，且有一个新的资源依据请求的需要而建立。
   * 204 No Content：服务器成功处理了请求，但不需要返回任何实体内容。

3. **重定向状态码（300–399）**：
   * 301 Moved Permanently：请求的资源已被永久地移动到新URI，返回信息会包括新的URI。
   * 302 Found：请求的资源临时从不同的URI响应请求。
   * 304 Not Modified：资源未被修改，可以使用缓存的版本。

4. **客户端错误状态码（400–499）**：
   * 400 Bad Request：服务器无法理解请求的格式，客户端应该修改请求后再试。
   * 401 Unauthorized：当前请求需要用户验证。
   * 403 Forbidden：服务器已经理解请求，但是拒绝执行它。
   * 404 Not Found：请求失败，请求所期望找到的资源在服务器上不存在。

5. **服务器错误状态码（500–599）**：
   * 500 Internal Server Error：服务器遇到未知情况，使其无法完成请求。
   * 501 Not Implemented：服务器不支持当前请求所需要的功能。
   * 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（如DNS服务器、网关、代理服务器等）收到响应。
   * 503 Service Unavailable：由于临时的服务器维护或过载，服务器暂时无法处理请求。
     :::

### ✅WebSocket

::: details 详解

##### WebSocket 是什么

* WebSocket 是一种全双工通信协议，允许客户端和服务器之间建立一个持久连接，并且可以双向实时通信。它通过 ws://（不加密）或 wss://（加密）协议进行通信

##### WebSocket 和 HTTP 有什么区别

* HTTP 是一种请求-响应模型的协议，客户端发送请求，服务器返回响应，通信是单向的。即使使用 HTTP/2 或 Server Push，本质上还是基于请求驱动的
* 所以 WebSocket 更适合需要实时性高、低延迟的场景，比如聊天、股票行情、在线游戏等

##### WebSocket 是如何建立连接的？握手过程是怎样的

WebSocket 的建立过程是基于 HTTP 协议的，称为握手（Handshake）

* 客户端发送一个 HTTP 请求，请求头中包含：
* 服务端如果支持 WebSocket，会返回一个 101 状态码（Switching Protocols）并带上相应的响应头
* 握手完成后，连接就升级为 WebSocket 协议，后续的通信就不再是 HTTP 请求/响应模式，而是真正的双向数据传输。
  :::

## 性能优化 ❌

### ✅前端性能优化

::: details 详解

#### 一、加载优化

1. **预加载（Preload）**
   * 使用 `<link rel="preload">` 提前加载关键资源，如字体、CSS、JS等。
   * 示例：`<link rel="preload" href="/styles.css" as="style">`
2. **懒加载（Lazy Load）**
   * 对图片、视频等大文件采用懒加载技术，仅当用户滚动到视口内时才加载。
   * 示例：使用 `loading="lazy"` 属性。
3. **延迟加载（Defer/Async Script Loading）**
   * 通过 `defer` 或 `async` 加载脚本，避免阻塞页面渲染。
   * `defer` 按顺序执行脚本，而 `async` 不保证顺序但异步加载。
4. **资源合并**
   * 将多个小文件合并为一个，减少HTTP请求次数。
   * 注意平衡文件大小与浏览器缓存效率。
5. **资源压缩**
   * 使用工具压缩HTML、CSS、JavaScript代码，去除不必要的空格和注释。
6. **CDN**
   * 使用内容分发网络(CDN)加速静态资源的访问速度。
7. **HTTP2/3**
   * 升级到HTTP/2或HTTP/3以利用多路复用、头部压缩等功能提升性能。
8. **强缓存/协商缓存**
   * 合理设置 `Cache-Control` 和 `ETag` 头部来控制缓存行为。
9. **字体资源使用font-display：swap**
   * 设置 `font-display: swap;` 确保文本在自定义字体加载前可见。

#### 二、构建优化

1. **Tree-shaking**
   * 利用Webpack等打包工具移除未使用的代码部分，减小最终包大小。
2. **打包分块：第三方和业务分离**
   * 分离第三方库与业务逻辑代码，利用长期缓存机制提高加载效率。
3. **代码分割**
   * 根据路由或组件动态加载模块，减少初始加载时间。
4. **按需加载**
   * 实现功能或页面级别的懒加载，只加载当前需要的部分。

#### 三、渲染优化

1. **骨架屏**
   * 在内容加载前显示占位符，改善用户体验。
2. **虚拟滚动加载**
   * 针对长列表，仅渲染视口内的元素，减少DOM操作成本。
3. **SSR (Server Side Rendering)**
   * 在服务器端完成页面首次渲染，加快首屏加载速度。
4. **减少重绘和回流**
   * 批量修改样式，尽量使用类名代替直接操作样式属性。
5. **内存泄漏减少**
   * 定期检查并清理不再使用的变量和事件监听器。
6. **编写复用函数和组件**
   * 提高代码复用性，降低维护成本。
7. **内连CSS**
   * 对于关键路径上的CSS，可以考虑内联至HTML中以减少额外请求。
8. **动画使用transform和opacity GPU加速动画**
   * 使用 `transform` 和 `opacity` 来创建平滑的GPU加速动画，避免触发布局重排。

#### 四、图像优化

1. **格式WEBP**
   * 转换图像格式为WebP，相比JPEG/PNG有更高的压缩率。
2. **压缩**
   * 使用工具压缩图片，保持视觉质量的同时减小文件大小。
3. **懒加载+占位图**
   * 结合懒加载技术和占位图，确保图像加载流畅且高效。

#### 五、监控分析

1. **前端埋点和上报**
   * 收集用户行为数据，用于后续分析和优化决策。
2. **性能面包分析和追踪**
   * 使用Lighthouse等工具定期评估网站性能，并跟踪改进效果。
3. **持续优化**
   * 基于监控数据不断调整和优化网站性能。
     :::

### ✅前端首屏优化

::: details 详解

##### 一、资源加载优化

1. **优先加载关键资源**
   * **CSS**：将用于首屏渲染的CSS内联至HTML中，确保样式能立即应用。
   * **JS**：对于非必要的JavaScript文件（如广告脚本、分析脚本），使用`async`或`defer`属性延迟加载。
2. **图片优化**
   * 使用**懒加载**技术，仅当图片进入视口时才加载。
   * 将图片格式转换为更高效的格式，如WebP。
   * 使用占位图（placeholder）替代实际图片，直到图片完全加载。
3. **字体优化**
   * 设置`font-display: swap;`，使得文本在自定义字体加载前可见。
   * 考虑使用系统默认字体作为回退方案，避免空白文本闪烁。
4. **使用CDN**
   * 静态资源通过CDN分发，利用地理位置优势加快资源加载速度。
5. **HTTP/2 或 HTTP/3 升级**
   * 利用多路复用、头部压缩等特性减少延迟。
6. **资源合并与压缩**
   * 合并多个CSS和JS文件以减少请求数量，并启用Gzip或Brotli压缩来减小传输体积。
7. **内联关键CSS**
   * 将首屏所需的所有CSS直接嵌入HTML中，避免额外的HTTP请求

##### 二、构建流程优化

1. **代码分割**
   * 按需加载组件或模块，而不是一次性加载所有内容。
   * 动态导入（Dynamic Imports）可以有效地实现按需加载。
2. **Tree Shaking**
   * 移除未使用的代码部分，减小打包后的文件大小。
3. **SSR (Server Side Rendering)**
   * 在服务器端完成页面初次渲染，发送给客户端的HTML已经包含了完整的内容结构，减少了浏览器解析和执行的时间。
4. **Service Worker 缓存**
   * 实现离线访问和快速加载，特别是在重复访问时能够直接从缓存读取数据。

##### 三、渲染性能优化

1. **骨架屏（Skeleton Screen）**
   * 在内容加载之前显示一个简单的UI框架，给用户即时反馈，改善等待体验。
2. **避免阻塞渲染的CSS**
   * 确保CSS不会阻止页面渲染，可以通过媒体查询指定某些样式只在特定条件下加载。
3. **减少重绘和回流**
   * 批量修改DOM元素样式，尽量使用类名切换代替直接操作样式属性。
4. **动画优化**
   * 对于涉及视觉变化的动画，优先使用`transform`和`opacity`，因为它们可以被GPU加速，避免触发布局重排。

##### 四、监控与分析

1. **性能监控工具**
   * 使用Lighthouse、WebPageTest等工具定期评估网站性能，并根据报告进行针对性优化。
2. **前端埋点**
   * 收集用户行为数据，了解用户的交互模式，识别性能瓶颈。
3. **持续优化**
   * 根据监控数据不断调整和优化网站性能，保持最佳状态。
     :::

### ✅Web缓存

::: details 详解

##### 定义和作用

Web缓存是一种临时存储Web文档(如HTML页面、图片等)的技术，目的是减少带宽使用、服务器负载和感知延迟。当用户再次访问相同资源时，可以直接从缓存中获取，而不需要重新从服务器下载。

##### 缓存类型

* 浏览器缓存 - 存储在用户本地设备上
* 代理缓存 - 位于客户端和服务器之间的中间缓存
* 网关缓存(反向代理缓存) - 部署在服务器前端的缓存，如CDN

##### HTTP缓存机制

Cache-Control是HTTP/1.1中定义的最重要的缓存控制头部，它可以指定：

* public/private - 定义资源是否可被共享缓存
* max-age - 资源被认为新鲜的最大时间(秒)
* no-cache - 使用前必须验证
* no-store - 禁止任何缓存
* must-revalidate - 过期后必须重新验证

##### 缓存验证

主要有两种验证机制：

* Last-Modified/If-Modified-Since - 基于时间戳
  * 服务器响应Last-Modified头部
  * 客户端下次请求携带If-Modified-Since
  * 服务器比较时间决定返回304(未修改)或新内容
* ETag/If-None-Match - 基于内容标识符
  * 服务器响应ETag(通常是内容的hash)
  * 客户端下次请求携带If-None-Match
  * 服务器比较ETag决定返回304或新内容

##### 实际应用

`静态资源(JS/CSS/图片):`

* 设置较长的max-age(如1年)
* 使用内容hash作为文件名实现"永不过期"缓存
* 通过CDN分发

`动态内容(HTML/API):`

* 设置较短的max-age(如几分钟)
* 通常使用no-cache或must-revalidate
* 对个性化内容使用private

##### 缓存问题

主要问题有：

* 缓存失效 - 用户看不到最新内容
  * 解决方案：版本化文件名或查询参数
* 敏感数据缓存 - 可能泄露隐私
  * 解决方案：对敏感内容使用private或no-store
* 缓存污染 - 恶意内容被缓存
  * 解决方案：验证输入，对用户生成内容谨慎缓存

##### 本地缓存

* LocalStorage、SessionStorage、IndexedDB、cookie
  :::

### ✅前端内存泄漏

::: details 详解

* 未清除的定时器
* 未移除的事件监听器
* 意外的全局变量
* 滥用闭包
* 游离的DOM元素
* console.log持有引用
* 第三方库使用和管理不当
* 未关闭的WebSocket连接 和 未取消的订阅
* 缓存使用不当
  :::

## JavaScript 核心

### ✅ES6 新特性

::: details 详解

* let/const
* class
* promise
* import/export
* Set/Map
* Proxy/Relect
* async/await
* 模板字符串
* 扩展运算符
* 剩余参数
* 箭头函数
* 默认参数
* 解构赋值
  :::

### ✅箭头函数 vs 普通函数

::: details 详解

* 写法差异
* 没有自己的this
* 没有arguments
* 没有prototype属性
* 无法使用new,不能作为构造函数
* 不能super继承父类的属性和方法

:::

### ✅原型和原型链

::: details 详解

##### 原型

在 JavaScript 中，原型（Prototype）是实现继承和共享属性与方法的一种机制。每个函数都有一个 prototype 属性，它是一个对象，包含了可以被该函数创建的所有实例共享的属性和方法。而每个对象都有一个内部属性 \[\[Prototype]]，通常可以通过 **proto** 访问，它指向其构造函数的 prototype 对象。

##### 原型链

原型链是 JavaScript 实现继承的核心机制。当访问一个对象的属性或方法时，如果该对象本身没有这个属性，JavaScript 引擎会去它的原型对象中查找，如果原型对象也没有，就会继续向上查找它的原型对象的原型，直到查找到 Object.prototype 或者遇到 null 为止，这个查找过程就构成了原型链。

##### **proto** 和 prototype 区别

* `prototype` 是函数对象的一个属性，它是一个对象，用于存放通过该函数构造出的实例可以共享的属性和方法。
* `__proto__` 是每个对象都有的一个内部属性（对应 `[[Prototype]]`），它指向该对象的构造函数的 prototype

##### constructor 是什么？它在原型链中的作用是什么

* constructor 是每个 prototype 对象默认拥有的属性，它指向该原型对象对应的构造函数

```js
function Person() {}
console.log(Person.prototype.constructor === Person); // true
```

**原型是继承的基础，原型链是属性查找的机制**
:::

### ✅函数柯里化

::: details 详解

##### 定义

函数柯里化是一种函数转换技术，它将一个接受多个参数的函数转换成一系列连续的、每次只接受一个参数的嵌套函数。换句话说，原本需要多个参数的函数，被改造成可以通过逐步传参的方式调用。例如，一个函数 add(a, b, c) 可以被柯里化为 add(a)(b)(c)

##### 柯里化实现

```js
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function (...moreArgs) {
        return curried.apply(this, args.concat(moreArgs));
      };
    }
  };
}
```

使用

```js
function add(a, b, c) {
  return a + b + c;
}

const curryAdd = curry(add);

console.log(curryAdd(1)(2)(3)); // 6
console.log(curryAdd(1, 2)(3)); // 6
console.log(curryAdd(1)(2, 3)); // 6
```

##### 函数柯里化在实际开发中有以下常见应用场景

:::

### ✅CommonJS 与 模块化

::: details 详解

##### 模块化

模块化是一种将代码划分为独立、可复用部分的编程范式。它的目的是：

* 解耦：减少模块之间的依赖
* 可维护性：便于调试和更新
* 复用性：可以在多个项目中重复使用

JavaScript 原生并不支持模块化，直到 ES6 才正式引入模块标准（ES Module）。

##### CommonJS 是什么

CommonJS 是一种模块化规范，最初是为了解决 Node.js 中的模块问题而提出的。
**特点：**

* 使用 require() 同步加载模块
* 使用 module.exports 和 exports 导出模块
* 主要用于服务端（Node.js）

```js
// math.js
exports.add = function(a, b) {
  return a + b;
};

// 或者
module.exports = {
  add: function(a, b) { return a + b; }
};

// app.js
const math = require('./math');
console.log(math.add(1, 2)); // 3
```

**优点：**

* 简单易懂，语法清晰
* Node.js 的默认模块系统

**缺点：**

* 同步加载，不适合浏览器环境
* 不利于异步加载或按需加载

#### ES Module（ESM）

ES6 引入了官方模块系统 —— ECMAScript Module（ESM）

**特点：**

* 使用 import / export 语法
* 支持异步加载
* 静态分析能力强，适合 Tree Shaking

```js
// math.js
export function add(a, b) {
  return a + b;
}

// app.js
import { add } from './math.js';
console.log(add(1, 2));

```

**优点：**

* 官方标准，未来主流
* 支持异步加载
* 可以做静态优化（如 Tree Shaking）

**缺点：**

* 浏览器兼容性早期较差（现已广泛支持）
* 不能直接在旧版 Node.js 中使用（需要配置 type="module"）

#### CommonJS 与 ESM 的区别

CommonJS（CJS）和 ECMAScript 模块（ESM）是JavaScript中两种不同的模块系统，它们在语法、使用场景以及一些特性上有所区别。以下是两者的主要区别：

##### 1. 语法差异

* **CommonJS (CJS)**:

  * 使用`require()`函数来导入模块。
  * 使用`module.exports`或`exports`对象来导出模块内容。

  ```javascript
  // 导入模块
  const moduleA = require('./moduleA');

  // 导出模块
  module.exports = { foo: 'bar' };
  ```

* **ECMAScript 模块 (ESM)**:

  * 使用`import`语句来导入模块。
  * 使用`export`关键字来导出模块内容。

  ```javascript
  // 导入模块
  import { foo } from './moduleB.js';

  // 导出模块
  export const bar = 'foo';
  ```

##### 2. 加载时机

* **CommonJS**: 模块是在运行时加载的，这意味着你可以根据条件动态地决定要加载哪些模块。
* **ESM**: 模块在编译时确定依赖关系，因此具有更严格的依赖图谱，并且不允许动态导入模块路径（尽管有动态`import()`语法，但它的行为与静态`import`不同）。

##### 3. 适用环境

* **CommonJS**最初是为Node.js设计的，在早期版本的Node.js中广泛使用。
* **ESM**是JavaScript标准的一部分，现在也被现代浏览器和Node.js支持。随着标准化进程，它逐渐成为前端和后端开发中的主流选择。

##### 4. 性能考虑

* **ESM**由于其静态结构，可以进行更多优化，比如Tree-shaking（消除未使用的代码），这对于构建高效的应用程序非常重要。

##### 5. 默认导出与命名导出

* **CommonJS**: 主要是默认导出的概念，尽管也可以通过向`exports`添加多个属性实现类似命名导出的功能。
* **ESM**: 明确区分了默认导出(`export default`)和命名导出(`export const ...`等)，提供了更大的灵活性。

:::

## Vue 框架

### ✅Vue 双向绑定原理

::: details 详解

* Vue 的双向绑定本质是数据劫持 + 发布订阅模式。

* 在 Vue 2 中通过 Object.defineProperty 递归转换 data 的每个属性为 getter/setter，在 getter 中收集依赖（Watcher），在 setter 中通知更新。视图层通过 v-model 指令实现双向绑定，它本质是 value 属性绑定和 input 事件监听的语法糖。

* Vue 3 改用 Proxy 实现，优势在于能直接监听整个对象且自动处理新增属性。整个系统还包含异步批量更新和虚拟 DOM diff 等优化机制，既保持了开发便捷性又保证了性能。

```js
// Vue2 实现
function defineReactive(obj, key, val) {
  Object.defineProperty(obj, key, {
    get() {
      return val;
    },
    set(newVal) {
      if (val !== newVal) {
        val = newVal;
        console.log("数据更新了");
      }
    },
  });
}

const data = { name: "Vue" };
defineReactive(data, "name", data.name);
data.name = "Vue3"; // 控制台输出 "数据更新了"
```

:::

### ✅Vue 生命周期详解

::: details 详解

* `beforeCreate`:**这个钩子在实例初始化之后、数据观测 (data observer) 和 event/watcher 事件配置之前被调用**,不过，在 Composition API 中，通常使用 setup() 函数来处理这一阶段的逻辑，因此这个钩子不常用。
* `created`：**在实例创建完成后立即调用**。在这个阶段，实例已经完成了数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。但是，挂载阶段还没开始，$el 属性目前不可见
* `beforeMount`：**在挂载开始之前被调用**：相关的 render 函数首次被调用。此时，虚拟 DOM 尚未渲染到真实 DOM 上
* `mounted`：**在 el 被新创建的 vm.$el 替换，并挂载到实例上后调用**。这时，组件已经被渲染到 DOM 中，可以访问 DOM 元素了。
* `beforeUpdate`：*在数据更新时，在虚拟 DOM 打补丁之前调用*\*。此时，可以获取更新前的状态，适合用来进行一些清理工作。
* `updated`：**在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用**。此时，组件 DOM 已经更新，可以执行依赖于 DOM 的操作。然而，避免在此期间改变状态，因为这可能会导致无限的更新循环
* `beforeUnmount（在 Vue 2 中为 beforeDestroy）`：**发生在实例销毁之前，在当前阶段实例完全可以被使用**。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。
* `unmounted（在 Vue 2 中为 destroyed）`:**卸载组件实例后调用**。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器被移除，所有子组件实例也都被销毁。

**activated 和 deactivated 是 Vue 中专门用于 < keep-alive> 缓存组件时的生命周期钩子**

* `activated`：**当组件被 < keep-alive> 缓存后，每次该组件被激活（显示）时调用**。可以在这里执行组件重新展示时需要的逻辑，比如重新获取数据、恢复动画、计时器等
* `deactivated`：**当组件被缓存后，离开当前视图（被切换出去）时调用**。可以在这里进行一些资源释放操作，比如清除定时器、取消事件监听、停止动画等，防止内存泄漏。
  :::

### ✅Vue 自定义指令

::: details 详解

* `v-focus`：自动聚焦输入框；
* `v-permission`：权限控制；
* `v-lazy`：图片懒加载；
* `v-throttle`：防抖节流；
* `v-draggable`：拖拽行为。

```js
// 注册自定义指令 v-focus
app.directive("focus", {
  mounted(el) {
    el.focus();
  },
});
```

:::

### ✅Vue 如何优化 SEO

::: details 详解
在Vue.js项目中优化SEO（搜索引擎优化）主要涉及以下几个方面：

1. **服务端渲染 (SSR)**：默认情况下，Vue应用是客户端渲染的，这意味着在JavaScript执行之前，页面对于搜索引擎来说是空白的。通过使用服务端渲染，可以在服务器上预渲染Vue组件，并将HTML发送到客户端，这有助于搜索引擎更好地理解和索引你的网页内容。

   Vue官方提供了一个名为Vue Server Renderer的库来实现这一点。此外，Nuxt.js是一个基于Vue.js的更高层次的框架，它简化了服务端渲染的配置和使用，同时也提供了静态站点生成等功能。

2. **预渲染 (Prerendering)**：如果您的网站主要是静态内容，或者只有少量动态内容，那么可以考虑使用预渲染。预渲染与服务端渲染类似，但它只在构建时生成特定路由的静态HTML文件，而不是每次请求都进行服务端渲染。这种方法简单易行，适合那些不需要频繁更新的页面。

3. **Meta标签管理**：确保每个页面都有正确的meta标签，这对于SEO至关重要。你可以使用vue-meta等插件来动态管理标题、描述和其他meta信息，使其能够根据不同的路由或状态自动更新。

4. **合理利用Link组件**：在Vue Router中使用`<router-link>`组件代替普通的`<a>`标签可以帮助你更有效地管理内部链接，从而有利于SEO。

5. **提升页面加载速度**：快速加载的页面不仅改善用户体验，也对SEO有正面影响。可以通过代码分割、懒加载非关键资源等方式减少初始加载时间。

6. **创建Sitemap**：为你的Vue应用创建一个XML Sitemap，并提交给搜索引擎，以帮助它们更好地发现和索引你的网站内容。

7. **结构化数据标记**：使用JSON-LD格式添加结构化数据标记，可以帮助搜索引擎理解页面上的内容类型（如产品、文章等），从而可能在搜索结果中显示更丰富的摘要。

8. **避免重复内容**：确保你的URL设计不会导致相同内容出现在多个不同的URL上。如果存在这种情况，应该设置适当的301重定向或使用canonical标签指定首选版本。

结合以上策略，您可以有效地提高基于Vue的应用程序的SEO表现。不过，请记住SEO是一个持续的过程，需要不断地监控和调整策略以适应搜索引擎算法的变化。

:::

### ✅Vue2 vs Vue3

::: details 详解

#### ✅ 1. **组合式 API vs 选项式 API**

* **Vue2** 使用 Options API（如 `data`、`methods`、`computed` 等）组织代码，逻辑分散，不易复用。
* **Vue3** 引入了 Composition API（如 `setup()`、`ref`、`reactive`、`watch` 等），更灵活，更适合逻辑复用和大型项目的维护。

***

#### ✅ 2. **性能优化**

* **更快的虚拟 DOM**：Vue3 重写了虚拟 DOM，实现更快的 diff 算法。
* **编译优化**：静态提升、事件缓存等机制使渲染更高效。
* **Tree-shaking 支持**：Vue3 使用 ES Module 编写，可以按需引入，减小打包体积。

***

#### ✅ 3. **响应式系统升级**

* **Vue2** 使用 `Object.defineProperty`，不支持对数组、新增属性的完全监测。
* **Vue3** 改用 `Proxy` 实现响应式，更彻底、性能更好，支持更复杂的数据结构。

***

#### ✅ 4. **Fragment / Teleport / Suspense 支持**

* **Fragment**：Vue3 组件可以返回多个根节点，Vue2 不支持。
* **Teleport**：可以将组件渲染到 DOM 的任意位置，适合弹窗等场景。
* **Suspense**：用于异步组件的加载状态处理，配合 `<script setup>` 更加简洁。

***

#### ✅ 5. **TypeScript 支持更好**

* Vue3 是用 TypeScript 重写的，原生支持类型推导和开发体验，Vue2 对 TypeScript 支持较弱。

***

#### ✅ 6. **生命周期钩子不同**

* Composition API 下生命周期名称为 `onMounted`、`onUnmounted` 等，更接近函数语义。
* 而 Vue2 是 `mounted`、`destroyed` 等选项式 API。
* vue3中 beforeDestroy->onBeforeUnmounted, destroyed->onUnmounted
* beforeCreate、created 被语法糖 setup 替代
  :::

### ✅Vue3 组件通信与原理

::: details 详解

* 父子组件通信
  * props/emit
  * ref获取子组件实例的属性和方法
  * ref 和 expose
    * 使用 ref 可以让你直接访问组件实例或 DOM 元素。结合 defineExpose 函数，可以在组合式 API 中暴露特定的方法或属性给父组件使用
* 跨组件通信
  * mitt（第三方插件）
  * Provide/Inject
* 全局状态管理
  * Pinia (推荐)
    :::

### ✅Vue 路由实现原理

::: details 详解

* Hash 路由：通过 URL 的 # 后面的字符变化实现路由，不触发页面刷新。
* History 路由：使用 HTML5 的 pushState 和 replaceState 方法，URL 更美观，但需要服务器配置支持。
  :::
* Vue keep-alive 原理
  ::: details 详解

#### 简述

`Vue` 中的 `keep-alive` 是一个**抽象组件**，用于**缓存组件状态**，避免组件重复创建和销毁。它在开发中常用于优化性能，特别是在组件切换频繁的场景下，比如标签页切换、路由组件缓存等。

#### 一、Vue keep-alive 的作用

`<keep-alive>` 的作用是：

* **缓存动态组件**（使用 `<component :is="xxx">`）
* **缓存路由组件**（结合 Vue Router 的 `router-view` 使用）

当组件被包裹在 `<keep-alive>` 中时：

* 首次渲染时正常创建组件；
* 组件切换时不会被销毁，而是被缓存；
* 再次显示时直接复用缓存的状态，不会重新执行 `created`、`mounted` 等生命周期钩子。

***

#### 二、Vue keep-alive 的实现原理（以 Vue 2 和 Vue 3 为例）

##### 1. 核心机制

`<keep-alive>` 是一个**抽象组件**，它不会渲染成一个真实的 DOM 节点，而是作为一个组件缓存的控制器。

它内部维护一个缓存对象（`cache`），用于保存已经被创建过的组件实例。当组件需要显示时，优先从缓存中取出，而不是重新创建。

***

##### 2. 生命周期钩子（Vue 2 & Vue 3）

使用 `<keep-alive>` 缓存的组件，会多出两个生命周期钩子：

* `activated`：组件被激活时调用（从缓存中恢复）
* `deactivated`：组件被停用时调用（放入缓存）

这两个钩子可以用于执行一些组件激活/停用时的逻辑（如数据刷新、计时器清除等）。

***

##### 3. 缓存控制（include / exclude / max）

`<keep-alive>` 支持以下属性来控制缓存行为：

| 属性名 | 说明 |
|--------|------|
| `include` | 字符串或正则，只有匹配的组件会被缓存 |
| `exclude` | 字符串或正则，匹配的组件不会被缓存 |
| `max`     | 最大缓存组件数量，超出后采用 LRU 算法清除 |

示例：

```vue
<keep-alive>
  <component :is="currentComponent" v-if="currentComponent" />
</keep-alive>
```

或者结合路由：

```vue
<keep-alive>
  <router-view v-if="$route.meta.keepAlive" />
</keep-alive>
<router-view v-if="!$route.meta.keepAlive" />
```

***

#### 4. Vue 2 与 Vue 3 的差异

##### Vue 2 实现简述：

* `keep-alive` 是一个内置组件，通过 `vnode.componentInstance` 来获取和复用组件实例。
* 缓存结构为对象：`{ key: vnode }`
* 切换时根据组件名判断是否命中缓存。
* 使用 `v-if` 控制组件显示，避免多个组件同时渲染。

##### Vue 3 实现简述（Vue 3 Composition API）：

* 依然使用 `keep-alive` 组件，但内部实现更加优化。
* 支持更复杂的组件树缓存。
* 使用 `LRU` 缓存策略（最近最少使用）来控制缓存大小。
* 支持异步组件缓存。
* 使用 `ShapeFlags` 和 `PatchFlags` 提升性能。

***

#### 三、源码层面的简要实现逻辑（Vue 3 伪代码）

```ts
const KeepAlive = {
  __isKeepAlive: true,
  props: ['include', 'exclude', 'max'],
  setup(props, { slots }) {
    const cache = new Map(); // 缓存组件实例
    const keys = []; // 缓存键列表，用于 LRU 管理

    const pruneCache = () => {
      // LRU 清理策略
      if (props.max && cache.size > props.max) {
        const oldestKey = keys.shift();
        cache.delete(oldestKey);
      }
    };

    return () => {
      const vnode = slots.default();
      const comp = vnode.type;

      if (props.include && !matches(props.include, comp.name)) {
        return vnode; // 不满足 include，不缓存
      }

      if (props.exclude && matches(props.exclude, comp.name)) {
        return vnode; // 满足 exclude，不缓存
      }

      const key = vnode.key == null ? comp : vnode.key;

      if (cache.has(key)) {
        // 缓存命中，复用组件实例
        vnode.componentInstance = cache.get(key).componentInstance;
        invokeHook(vnode, 'activated');
      } else {
        // 首次创建，加入缓存
        cache.set(key, vnode);
        keys.push(key);
      }

      pruneCache(); // 控制缓存大小

      return vnode;
    };
  }
};
```

> 注意：上面是简化版的伪代码，实际 Vue 源码中会涉及更多细节，比如组件卸载、组件状态管理、异步组件处理等。

***

#### 四、使用场景

1. **Tab 切换组件**：保持每个 Tab 的状态
2. **路由组件缓存**：比如后台管理系统中，用户希望切换回上一个页面时保留其状态
3. **高频切换组件**：减少重复渲染开销

#### 五、注意事项

* `keep-alive` 只对组件起作用，不能直接包裹 HTML 元素。
* `keep-alive` 不能和 `v-for` 一起使用（因为 `v-for` 优先级高于 `keep-alive`）。
* `activated` 和 `deactivated` 是 `keep-alive` 独有的生命周期钩子。
* 使用 `max` 属性时要注意 LRU 缓存策略的影响。

#### 六、总结

| 特性 | 描述 |
|------|------|
| 类型 | 抽象组件 |
| 目的 | 缓存组件状态，提高性能 |
| 生命周期 | `activated`、`deactivated` |
| 控制方式 | `include`、`exclude`、`max` |
| 适用场景 | 组件切换频繁、需要保留状态的场景 |

:::

### ✅Vue computed 原理

::: details 详解
Vue 的 `computed` 属性实现的核心在于`依赖追踪`和`响应式系统`。简要来说，其实现原理包括以下几个关键点：

* 1. **依赖收集**：当一个计算属性（computed property）被访问时，Vue 会自动追踪在这个过程中哪些响应式数据（reactive data）被访问了。这是通过 Vue 的响应式系统来完成的，该系统会在读取响应式数据时进行依赖收集。

* 2. **缓存机制**：计算属性的结果会被缓存起来，并且只有在其依赖的数据发生变化时才会重新计算。这意味着如果相关依赖未发生改变，多次访问同一个计算属性将会立即返回缓存的结果，而不会重复执行计算逻辑。

* 3. **响应更新**：一旦某个计算属性所依赖的数据发生了变化，Vue 就会知道需要重新计算这个计算属性的值，并更新相应的视图。这种更新是自动的，开发者不需要手动干预。

* 4. **惰性求值**：计算属性采用惰性求值策略，即仅在访问计算属性时才执行计算逻辑，而不是在定义时就立即执行。这样可以避免不必要的计算，提高性能。

综上所述，Vue 的 `computed` 利用了依赖追踪、缓存机制以及响应式更新等特性，使得它能够高效地管理复杂状态逻辑，同时简化了代码的编写和维护工作。
:::

### ✅vue3 watch vs watchEffect

::: details 详解

#### `watch`

`watch` 更加直接，它允许你监听一个特定的数据源，并在数据源发生变化时执行回调函数。你可以监听响应式对象、引用（ref）、计算属性（computed）等。

* **特点**：
  * 需要明确指定要监听的数据源。
  * 可以访问监听数据变化前后的值。
  * 默认情况下是惰性的，即只有当被监听的数据变化时才会触发回调。
  * 支持深度监听对象的变化。

* **适用场景**：
  * 当你需要对特定的数据进行监听并做出反应时非常有用。
  * 如果需要比较新旧值来决定是否执行某些逻辑。

#### `watchEffect`

`watchEffect` 则自动收集依赖，它会立即执行传入的函数，并追踪函数内部所有响应式数据的访问。当这些响应式数据中的任何一个发生变化时，`watchEffect` 就会重新运行。

* **特点**：
  * 自动收集依赖项，无需显式指定监听哪些数据。
  * 不提供访问变化前的数据值的方式。
  * 立即执行一次以收集依赖，然后在依赖变更时重新运行。
  * 适合用于副作用管理，比如数据获取、更新DOM等。

* **适用场景**：
  * 当你想要根据多个响应式数据的变化自动重新执行某些逻辑时很有用。
  * 对于不需要比较前后状态，只需要在相关响应式数据变化时执行某些操作的情况。

#### 总结

* 使用 `watch` 当你需要对特定数据的变化作出响应，并且可能需要访问该数据变化前后的值。
* 使用 `watchEffect` 当你需要基于多个响应式数据的状态自动执行某些操作，并且不关心之前的状态。

:::

### ✅Vue SSR 和 SSG 的实现原理

::: details 详解
Vue 的 SSR（Server-Side Rendering，服务端渲染）和 SSG（Static Site Generation，静态站点生成）是两种不同的预渲染技术，旨在提高首屏加载速度、SEO效果以及用户体验。下面分别介绍这两种技术的实现原理。

#### Vue SSR 实现原理

SSR 指的是在服务器端完成页面的 HTML 结构生成，然后将这个结构发送到客户端，客户端直接展示已经渲染好的页面，之后再下载 JavaScript 文件来接管页面交互。其主要流程如下：

1. **入口文件分离**：需要为服务端和客户端分别创建入口文件。服务端入口文件负责服务端渲染逻辑，而客户端入口文件负责挂载应用并处理交互。
2. **服务端渲染**：在接收到请求时，服务器根据请求的数据动态地渲染出对应的HTML字符串，并将其返回给客户端。
3. **同构/通用代码**：为了能够同时运行在服务器和服务端，代码需要保持一定的同构性，比如使用Vue.js的组件可以在两端复用。
4. **数据预取**：由于是在服务端进行渲染，因此需要一种机制来确保在渲染之前获取必要的数据。这通常通过`asyncData`或类似的钩子函数来实现，在渲染前异步获取数据。
5. **客户端激活**：当带有已渲染内容的HTML到达客户端后，Vue会对其进行“激活”，即绑定事件处理器等，让页面变为一个完整的单页应用。

#### Vue SSG 实现原理

SSG 是预先构建所有页面为静态HTML文件的过程，这些页面可以部署在任何静态文件服务器上。它适合于内容变化不频繁的网站。其核心思想是：

1. **构建时渲染**：在构建阶段，根据路由配置及可能的数据源，提前渲染所有的页面为静态HTML文件。
2. **静态资源输出**：除了HTML文件外，还会生成相关的JavaScript、CSS等资源文件。
3. **部署灵活性**：生成的静态文件可以直接部署到任何静态托管服务上，如Netlify、Vercel等，无需专门的服务器端环境支持。
4. **数据更新策略**：对于部分内容需要动态更新的情况，可以通过API调用或增量生成等方式来解决。一些框架也提供了重新生成部分页面的能力。

#### 区别与联系

* SSR 更加动态，适用于需要实时数据更新的场景；而 SSG 更适合内容相对固定的网站，如博客、文档等。
* SSG 通过预先生成静态页面提高了访问速度，降低了服务器负载；SSR 则提供了一种方式来在服务端动态生成每个请求的HTML，有利于SEO和首次加载性能。

无论是 SSR 还是 SSG，它们的目的都是为了优化用户的初次加载体验，并改善搜索引擎的抓取效率。选择哪种方案取决于具体的应用场景和需求。

#### SSR SEO

在使用 SSR（Server-Side Rendering，服务端渲染）时，SEO（搜索引擎优化）的处理主要依赖于服务器能够在页面请求时直接生成完整的HTML内容，这使得搜索引擎爬虫能够像普通用户一样获取到完全加载的网页内容。以下是一些关键点和最佳实践，用于确保你的 SSR 应用程序具有良好的 SEO 表现：

##### 关键点

1. **正确的Meta标签**：确保每个页面都有合适的`<title>`和`<meta>`描述标签，这些对于SEO至关重要。利用Vue的SSR功能动态地为每个页面设置这些标签。

2. **预渲染重要数据**：在服务端渲染过程中，尽可能预先加载和渲染页面所需的数据。这不仅提升了用户体验，也确保了搜索引擎抓取工具可以访问完整的内容。

3. **URL结构优化**：保持简洁、有意义的URL结构。避免使用复杂的查询参数，尽量采用语义化的路径来提高搜索引擎的友好度。

4. **Sitemap和Robots.txt文件**：创建一个XML格式的站点地图，并通过robots.txt文件告诉搜索引擎哪些页面应该被索引，哪些不应该。这对于指导搜索引擎爬虫工作非常重要。

5. **Open Graph和Twitter Cards**：为了提升社交媒体分享的效果，添加Open Graph协议元标签和Twitter Cards标记，这样当你的页面被分享到社交网络时，会显示吸引人的卡片视图。

6. **响应式设计**：确保网站在各种设备上都能良好显示。随着移动优先索引策略的普及，拥有响应式设计的网站将更受搜索引擎青睐。

7. **性能优化**：尽管SSR有助于首次加载时间，但仍然需要关注其他性能因素，如图片优化、代码分割等，以进一步改善页面加载速度和用户体验。

8. **结构化数据（Schema Markup）**：使用结构化数据可以帮助搜索引擎更好地理解你的网页内容，从而可能获得丰富的搜索结果展示（如评分、价格等信息）。

##### 实践建议

* 在Vue应用中使用`vue-meta`库管理页面的头部信息，它允许你在组件内部方便地设置meta标签。
* 定期检查Google Search Console或其他类似工具提供的反馈，了解你的网站在搜索引擎中的表现，并根据反馈进行调整。
* 考虑使用渐进式Web应用（PWA）技术来增强用户体验，同时也有助于SEO。

通过上述措施，你可以最大化地发挥SSR在SEO方面的潜力，确保你的网站不仅对用户友好，也能很好地适应搜索引擎的需求。
:::

### ✅vue2和 vuex3渲染器的 diff算法

::: details 详解
Vue 2 和 Vue 3 在渲染机制和 diff 算法方面有着显著的不同，这些改进旨在提高性能和开发体验。

#### Vue 2 的 Diff 算法

Vue 2 使用的是基于 Snabbdom 的虚拟 DOM 实现。其核心 diff 算法主要包括以下几点：

1. **同层级比较**：Vue 2 在进行 diff 操作时，仅在同一层级上进行节点的比较，这意味着它不会跨层级去寻找节点的变化。
2. **Patch VNode**：当新旧 VNode（虚拟节点）树对比时，Vue 2 会尝试以最小的代价更新实际 DOM。如果节点类型相同，则复用并更新；如果不同，则创建新的 DOM 节点替换旧的。
3. **Key 属性**：通过为列表中的每个元素指定一个 `key` 属性，Vue 可以更准确地识别哪些元素被添加、移除或重新排序，从而优化重绘和重排。

#### Vue 3 的 Diff 算法改进

Vue 3 对渲染器和 diff 算法进行了多项优化，包括但不限于：

1. **静态树提升**：Vue 3 引入了静态树提升的概念，能够检测到不依赖于状态的静态部分，并在初次渲染后将这部分标记为静态。这意味着在后续的状态更新中，Vue 不需要对静态部分进行 diff 操作，从而提高了性能。

2. **静态属性提升**：与静态树类似，Vue 3 还可以对组件内的静态属性进行提升，减少不必要的属性比对。

3. **优化的 Patch Flag**：Vue 3 使用了更为精细的 patch flag 来标记动态绑定的部分，这样在更新过程中只需关注这些动态部分，而不是整个模板，这极大地减少了需要 diff 的内容量。

4. **Fragment 和多根节点支持**：Vue 3 支持 Fragment（片段），允许组件拥有多个根节点。这不仅简化了某些 UI 结构的设计，而且在 diff 算法上也做了相应的优化以支持这种结构。

5. **更高效的编译器**：Vue 3 的编译器更加智能，能生成更高效的代码，尤其是在处理条件渲染和列表渲染时，能够更好地利用上述优化技术。

总的来说，Vue 3 相对于 Vue 2，在 diff 算法和渲染逻辑上有了显著的改进，使得应用在保持简洁的同时还能获得更好的性能表现。这些改进帮助开发者构建更高效的应用程序，同时也提升了用户体验。
:::

### ✅Vue nextTick

::: details 详解

#### nextTick 的作用是什么？他的实现原理是什么

`nextTick` 是一个在多个前端框架（如 Vue.js）中使用的方法，主要用于在下次 DOM 更新循环结束之后执行延迟回调。它的主要作用是在数据变化后等待 DOM 更新完成，然后执行指定的回调函数。

#### 作用

当你修改了某些数据时，Vue 不能立即更新 DOM 以反映这些更改。它会在当前事件循环“tick”结束之后、新的渲染发生之前，将所有待处理的 DOM 更新刷新。使用 `nextTick` 可让你在 DOM 更新完成后执行代码。

例如，如果你需要在状态更新后立即操作新渲染的 DOM 元素，可以使用 `nextTick` 来确保 DOM 已经更新：

```javascript
// 修改数据
this.message = 'changed';

// 在 DOM 更新后执行
this.$nextTick(function() {
  // 操作更新后的 DOM
});
```

#### 实现原理

`nextTick` 的实现依赖于环境。在浏览器环境中，它会尝试使用以下几种方式来安排回调函数的执行，按优先级顺序如下：

1. **Promise**：如果环境支持 Promise，则使用 Promise.resolve().then(callback) 安排回调。
2. **MutationObserver**：对于不支持 Promise 但支持 MutationObserver 的旧版浏览器，Vue 使用 MutationObserver 来调度微任务。
3. **setImmediate**：这是一个仅在 IE 中可用的方法，用于安排宏任务。
4. **setTimeout**：作为最后的选择，使用 setTimeout(callback, 0) 来安排回调。

通过这种方式，`nextTick` 能够尽可能地利用现代浏览器提供的高效异步执行机制，保证回调函数在当前调用栈清空且 DOM 渲染完毕之后尽快执行。这种机制使得 `nextTick` 成为一种非常有效的方式，可以在数据变更导致的 DOM 更新完成后进行后续操作。
:::

* Vue complier 的实现原理
  ::: details 详解
  Vue 编译器（Vue Compiler）负责将 Vue 单文件组件（SFC, Single File Component）或模板字符串转换为渲染函数（render function），以便在浏览器中执行。这个过程大致可以分为两个阶段：**编译时（compile time）** 和 **运行时（runtime）**。下面简要介绍 Vue 编译器的工作原理，主要关注 Vue 2 和 Vue 3 的一些关键差异和改进。

#### Vue 2 编译器工作原理

1. **解析（Parse）**：首先，Vue 2 编译器会将模板字符串解析成抽象语法树（AST）。这个过程包括识别模板中的文本、元素、属性、指令等，并将其结构化表示出来。

2. **优化（Optimize）**：在这个阶段，Vue 会对生成的 AST 进行静态分析，标记出静态节点和动态节点。静态节点是指那些内容不会随应用状态变化而改变的节点。通过这种方式，Vue 可以跳过对静态节点的重新渲染，从而提高性能。

3. **代码生成（Generate）**：最后一步是根据优化后的 AST 生成渲染函数。这些函数会在运行时被调用，用来创建虚拟 DOM 树，并最终更新实际的 DOM。

#### Vue 3 编译器的新特性与改进

Vue 3 对编译器进行了多项改进，主要包括：

* **更高效的静态提升**：Vue 3 改进了静态树提升技术，能够更好地识别和处理静态部分，减少不必要的 diff 操作，进一步提升了渲染性能。

* **更好的分支预测**：Vue 3 引入了更智能的分支预测机制，能够在编译时对条件渲染进行优化，使得运行时的决策更加高效。

* **编译时静态分析增强**：Vue 3 编译器增强了对模板的静态分析能力，能够识别更多类型的静态内容，减少了需要在运行时处理的内容量。

* **支持自定义指令的优化**：Vue 3 允许开发者编写可被编译器优化的自定义指令，提高了灵活性。

* **更快的渲染函数生成**：Vue 3 在代码生成阶段引入了新的算法和技术，使得生成的渲染函数更加简洁高效。

总的来说，Vue 编译器的工作就是将开发人员书写的模板或 JSX 转换成高效的 JavaScript 渲染逻辑。Vue 3 相对于 Vue 2，在编译效率、输出质量和性能优化方面都有显著的进步，这使得使用 Vue 构建的应用程序能够获得更好的用户体验。同时，Vue 3 的编译器设计也更加模块化，便于未来功能的扩展和性能的持续优化。
:::

### ✅Vue 中的 Key

::: details 详解
在 Vue 中，`key` 是一个特殊的属性，用于给每个节点提供一个唯一的标识。Vue 使用 `key` 来追踪节点的身份，以便更高效地更新虚拟 DOM。以下是关于 `key` 属性的详细解释：

#### 为什么需要 key？

1. **高效的DOM操作**：当数据项的顺序发生变化时，Vue 默认会尝试复用现有的 DOM 元素来提高效率。然而，在某些情况下（例如列表渲染），这种默认行为可能会导致问题。通过为每个元素提供一个唯一的 `key` 值，Vue 可以准确地识别哪些元素被添加、删除或重新排序，从而更智能地决定如何更新 DOM。

2. **避免不必要的重渲染**：使用 `key` 后，Vue 可以更好地判断哪些组件或元素实际上需要重新渲染，而不是盲目地认为所有东西都需要更新。这有助于提升性能，特别是在处理大型列表或表格时尤为重要。

#### 如何使用 key？

* 在 Vue 的模板中，`key` 特性通常应用于 `v-for` 指令生成的元素上。例如：
  ```vue
  <ul>
    <li v-for="item in items" :key="item.id">{{ item.name }}</li>
  </ul>
  ```
  这里，我们假设 `items` 数组中的每个对象都有一个唯一的 `id` 属性，这样可以确保每个 `<li>` 元素都有一个独一无二的 `key`。

#### 注意事项

* **唯一性**：虽然 `key` 不一定在整个应用中都是唯一的，但在它所在的上下文中应该是唯一的。比如在一个 `v-for` 循环内部，所有的 `key` 应该是不同的。

* **稳定性**：理想情况下，`key` 应该是稳定、可预测且唯一的。如果 `key` 不稳定（例如基于随机值或者数组索引），Vue 将无法有效地追踪元素身份，可能导致不必要的组件销毁和重建，影响性能。

* **不要使用数组索引作为 key**：除非你有特别的理由这样做，否则尽量避免使用数组索引作为 `key`，因为在项目被重新排序或新增/删除时，这会导致意外的行为。相反，应该尽可能使用数据中稳定的、唯一的标识符。

总之，正确使用 `key` 对于优化 Vue 应用的性能至关重要。它不仅帮助 Vue 更加智能地进行 DOM 操作，还能避免一些潜在的错误和性能瓶颈。
:::

### ✅ref 和 reactive 的区别

::: details 详解
在 Vue 3 中，`ref` 和 `reactive` 是 Composition API 提供的两个核心响应式函数，它们用于创建不同类型的响应式数据。

#### `ref`

* **定义**：`ref` 用于创建一个包含值的响应式引用对象。这个引用对象是一个容器，它有一个 `.value` 属性来存取实际的值。

* **适用场景**：适用于基本类型数据（如字符串、数字等）或需要跨组件层级传递的数据。由于 `ref` 返回的是一个对象，因此它可以很好地处理 JavaScript 的值传递机制，尤其是在函数参数和返回值中使用时。

* **用法示例**：
  ```javascript
  import { ref } from 'vue';

  const count = ref(0);
  console.log(count.value); // 输出: 0
  count.value++;
  ```

#### `reactive`

* **定义**：`reactive` 接受一个普通对象然后返回该普通对象的响应式代理。本质上是对对象进行深度监听，使对象中的所有属性都成为响应式的。

* **适用场景**：最适合于复杂的数据结构，比如对象或者数组。当你需要对整个对象进行响应式追踪而不是单一值时，`reactive` 是更合适的选择。

* **用法示例**：
  ```javascript
  import { reactive } from 'vue';

  const state = reactive({
    count: 0
  });
  console.log(state.count); // 输出: 0
  state.count++;
  ```

#### 主要区别

1. **数据类型**：`ref` 可以用来包装任何类型的值，包括原始类型和对象；而 `reactive` 主要用于对象（包括数组和集合），不能直接应用于原始类型。

2. **访问方式**：`ref` 创建的数据需要通过 `.value` 来访问或修改其值；而 `reactive` 直接操作对象属性即可，不需要额外的语法。

3. **解构与传播**：解构 `reactive` 对象不会保持响应性，而 `ref` 在某些情况下可以通过解构保持响应性（例如在 `<script setup>` 中自动解开）。此外，`ref` 可以作为 prop 传递并在子组件中使用 `.value` 访问，这使得它非常适合用于组件间通信。

4. **性能考虑**：由于 `reactive` 对对象的所有嵌套层次进行深度监听，可能会带来一定的性能开销；相比之下，`ref` 只监听顶层的值变化，可能在特定场景下提供更好的性能表现。

理解何时使用 `ref` 和 `reactive` 是掌握 Vue 3 Composition API 的关键之一。根据你的具体需求选择合适的工具可以让你的应用更加高效且易于维护。

#### 实现原理

在 Vue 3 中，`ref` 和 `reactive` 是 Composition API 的两个重要函数，用于创建响应式数据。它们的底层实现基于 ES6 的 `Proxy` 对象，但各自有不同的机制来实现响应式行为。

#### `reactive` 的底层实现原理

* **Proxy 对象**：`reactive` 函数通过将传入的对象转换为一个 `Proxy` 对象来实现响应式。`Proxy` 可以拦截对对象的基本操作（如获取属性、设置属性等），这使得 Vue 能够追踪依赖并在状态改变时通知相关的视图进行更新。

* **深度响应**：使用 `reactive` 创建的对象是深度响应式的，这意味着它会递归地将所有嵌套的对象都转换为 `Proxy` 对象，确保任何层级的变化都能被检测到并触发更新。

* **陷阱（Traps）**：`Proxy` 使用了多种陷阱（如 `get`, `set`, `deleteProperty` 等）来定义当执行这些操作时的行为。例如，在 `get` 操作中收集依赖，在 `set` 操作中触发更新。

##### `ref` 的底层实现原理

* **封装基本值**：与 `reactive` 不同，`ref` 主要用于包装基本数据类型（虽然也可以包装对象）。它返回的是一个包含 `.value` 属性的对象，这个对象本身不是响应式的，但其 `.value` 属性是响应式的。

* **触发更新**：当你修改 `ref` 包装的值（即修改 `.value` 属性）时，Vue 会检测到这一变化，并触发相应的更新。对于基本数据类型的 `ref`，Vue 通过访问器属性（getter 和 setter）来追踪变化。

* **自动解包**：在模板和某些特定的反应式上下文中（比如计算属性或侦听器），Vue 会自动解包 `ref`，使其可以直接使用而不需要显式地通过 `.value` 访问。但是，在 JavaScript 代码内部使用时，仍然需要手动访问 `.value`。

##### 总结

* **`reactive`** 利用 `Proxy` 提供深层次的响应式对象，适用于复杂的数据结构。
* **`ref`** 更加灵活，可以包装任意类型的值，特别是基本数据类型，并且通过访问器属性实现响应性。

两者都是 Vue 响应式系统的重要组成部分，但根据不同的需求选择合适的工具可以使你的应用更加高效和易于维护。
:::

* toRefs 和 toRaw 的区别
  ::: details 详解
  在 Vue 3 的 Composition API 中，`toRefs` 和 `toRaw` 是两个用于处理响应式数据的函数，但它们的作用和使用场景完全不同。了解这两者的区别对于有效地管理应用的状态非常重要。

#### `toRefs`

* **作用**：`toRefs` 函数将一个响应式对象转换为普通对象，其中该对象的每个属性都是指向原始响应式对象相应属性的 `ref`。这使得你可以轻松地从一个响应式对象中解构出响应式的属性，而不会失去其响应性。

* **适用场景**：当你需要将一个响应式对象的属性解构出来并在组件中使用时非常有用。这样可以确保即使在解构后，这些属性仍然保持响应式。

* **用法示例**：
  ```javascript
  import { reactive, toRefs } from 'vue';

  const state = reactive({
    name: 'Vue',
    version: 3
  });

  const { name, version } = toRefs(state);

  console.log(name.value); // 输出: Vue
  name.value += ' 3';
  ```

#### `toRaw`

* **作用**：`toRaw` 函数接受一个响应式对象（包括 `reactive` 或 `readonly` 创建的对象），并返回最初的普通对象。这是对原始数据的一个直接引用，而不是代理版本。

* **适用场景**：有时你可能需要访问原始对象来避免某些副作用或性能问题，比如当你想要绕过 Vue 的响应式系统进行一些非响应式的操作时。

* **用法示例**：
  ```javascript
  import { reactive, toRaw } from 'vue';

  const state = reactive({
    name: 'Vue',
    version: 3
  });

  const originalState = toRaw(state);
  originalState.name = 'Vue Original'; // 修改原始对象不会触发响应式更新
  ```

#### 区别总结

* **目的不同**：`toRefs` 主要用于将响应式对象的属性转化为独立的 `ref`，以便于解构使用同时保留响应性；而 `toRaw` 则是为了获取响应式对象背后的原始对象，适用于那些不需要响应性的场景或者希望直接操作原始数据的情况。

* **结果不同**：使用 `toRefs` 后的结果是包含 `ref` 属性的对象，这意味着你需要通过 `.value` 来访问和修改这些属性的值，并且任何改变都会被 Vue 的响应式系统追踪。相反，`toRaw` 返回的是原始对象本身，对其所做的更改不会触发 Vue 的响应式更新机制。

理解这两个函数的区别有助于更高效、正确地管理和操作 Vue 应用中的状态。根据具体的需求选择合适的工具，可以帮助你编写更加清晰、高效的代码。
:::

## React 框架

### ✅React 框架原理

::: details 详解
在准备前端面试时，了解 React 框架的原理是非常重要的。以下是一些关键概念和原理，可以帮助你更好地理解 React，并在面试中展示你的知识。

#### 1. 虚拟DOM（Virtual DOM）

React 使用虚拟DOM来提高应用的性能。虚拟DOM是一个内存中的轻量级副本，反映了真实DOM的状态。当状态发生变化时，React首先更新虚拟DOM，然后通过差异算法（Diffing Algorithm）比较新旧两棵虚拟DOM树的不同，只将必要的变更应用到实际的DOM上，从而减少直接操作DOM的次数。

#### 2. 单向数据流

React 实现了单向数据流的概念，这意味着数据只能在一个方向上传播：从父组件流向子组件。这种模式简化了数据流的跟踪，使得调试更加容易，同时也让应用更容易理解和维护。

#### 3. 组件化

React 强调组件化的开发思想，鼓励开发者将UI拆分成独立、可复用的组件。每个组件都有自己的状态和属性（props），并能够根据这些数据渲染出相应的视图。

#### 4. JSX

JSX是一种JavaScript的语法扩展，它看起来很像HTML，但允许你在JavaScript代码中书写类似于HTML的结构。JSX最终会被编译成纯JavaScript，这有助于更直观地创建React元素。

#### 5. Hooks

Hooks是React 16.8引入的新特性，它允许函数组件拥有类组件的大部分特性，比如状态管理（useState）、生命周期（useEffect）等，同时保持函数式的简洁性。使用Hooks可以让你避免复杂的嵌套层级，并且更方便地共享逻辑。

#### 6. Reconciliation（协调过程）

这是React用来决定何时以及如何更新DOM的过程。它基于一种称为“协调”的算法，该算法包括diff算法，用于比较前后两次渲染的结果，以确定需要对DOM进行哪些最小化的更改。
:::

## 样式与布局

### ✅Flex

::: details 详解
在前端开发中，`flex`（弹性盒子布局，Flexbox）是一种现代的、高效的 CSS 布局模型，特别适合用于一维布局（即行或列）。它简化了在不同屏幕尺寸和设备上对齐、分布和排列元素的方式，是响应式设计的重要工具。

#### 一、Flex 布局的基本概念

Flex 布局由 **容器（flex container）** 和 **项目（flex items）** 组成：

* **Flex 容器（Flex Container）**：通过设置 `display: flex` 或 `display: inline-flex` 的元素。
* **Flex 项目（Flex Items）**：容器的直接子元素。

```css
.container {
  display: flex;
}
```

***

#### 二、Flex 容器的主要属性

##### 1. `flex-direction`

定义主轴方向（即项目的排列方向）

```css
flex-direction: row | row-reverse | column | column-reverse;
```

* `row`（默认）：从左到右水平排列
* `row-reverse`：从右到左
* `column`：从上到下垂直排列
* `column-reverse`：从下到上

***

##### 2. `flex-wrap`

定义项目是否换行

```css
flex-wrap: nowrap | wrap | wrap-reverse;
```

* `nowrap`（默认）：不换行
* `wrap`：换行
* `wrap-reverse`：换行但方向相反

***

##### 3. `justify-content`

定义主轴上的对齐方式

```css
justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;
```

* `flex-start`（默认）：左对齐
* `center`：居中
* `space-between`：两端对齐，项目之间间距相等
* `space-around`：项目周围间距相等

***

##### 4. `align-items`

定义交叉轴上的对齐方式（适用于所有项目）

```css
align-items: stretch | flex-start | flex-end | center | baseline;
```

* `stretch`（默认）：拉伸填满容器
* `center`：居中
* `flex-start`：顶部对齐
* `flex-end`：底部对齐

***

##### 5. `align-content`

多行项目在交叉轴上的对齐方式（仅在换行时生效）

```css
align-content: stretch | flex-start | flex-end | center | space-between | space-around;
```

***

#### 三、Flex 项目的主要属性

##### 1. `order`

定义项目的排列顺序，默认是 0，数值越小越靠前

```css
order: <integer>;
```

***

##### 2. `flex-grow`

定义项目的放大比例，默认为 0（不放大）

```css
flex-grow: 1; /* 项目将填满剩余空间 */
```

***

##### 3. `flex-shrink`

定义项目的缩小比例，默认为 1（空间不足时会缩小）

```css
flex-shrink: 0; /* 不缩小 */
```

***

##### 4. `flex-basis`

定义在分配多余空间之前，项目占据的主轴空间

```css
flex-basis: auto | <length>;
```

* `auto`：根据 width/height 属性决定大小
* 可以设置固定值如 `200px`

***

##### 5. `flex`（推荐使用简写）

```css
flex: <flex-grow> <flex-shrink> <flex-basis>;
```

常用简写：

* `flex: 1` → `flex: 1 1 0%`
* `flex: auto` → `flex: 1 1 auto`
* `flex: none` → `flex: 0 0 auto`

***

#### 四、常见应用场景（面试常问）

| 场景 | 解法 |
|------|------|
| 水平垂直居中 | `display: flex; justify-content: center; align-items: center` |
| 等宽等高布局 | 使用 `flex: 1` 或 `flex-grow: 1` |
| 响应式导航栏 | 使用 `flex-wrap: wrap` 配合媒体查询 |
| 自适应间距 | 使用 `gap` 属性（CSS Grid 也支持） |
| 左右结构（如页眉页脚） | 使用 `justify-content: space-between` |
:::

### ✅BFC

::: details 详解

#### **BFC 是什么？**

**BFC（Block Formatting Context）** 是 CSS 中的一个渲染概念，表示一个独立的布局环境。在这个环境中，内部的元素按照特定规则进行布局，与外部元素互不影响。

***

#### **BFC 的作用：**

1. **清除浮动影响**：父元素创建 BFC 后，可以包含内部浮动元素，避免高度塌陷。
2. **阻止外边距合并（Margin Collapse）**：两个相邻块级元素的上下 margin 不会合并。
3. **防止文字环绕浮动元素**：文本内容会自动避开浮动元素，保持清晰布局。

***

#### **如何创建 BFC？**

满足以下任意条件即可创建 BFC：

* 根元素（`<html>`）
* `float` 不为 `none`
* `position` 为 `absolute` 或 `fixed`
* `display` 为 `inline-block`、`table-cell`、`flex`、`grid`、`flow-root` 等
* `overflow` 不为 `visible`（如 `hidden`、`auto`）

***

#### **总结一句话：**

**BFC 是一个独立的布局区域，用于控制元素内部和外部的布局行为，常用于清除浮动、防止 margin 合并等问题。**

:::

* 两边固定宽度中间自适应方案
  ::: details 详解
* 方法一：使用 Flexbox

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<style>
.container {
  display: flex;
  flex-wrap: wrap; /* 当空间不足时换行 */
}

.column {
  flex: 1; /* 允许子元素增长以填充可用空间 */
  min-width: 200px; /* 设置最小宽度 */
  margin: 10px;
  background-color: lightblue;
}
</style>
</head>
<body>

<div class="container">
  <div class="column">Column 1</div>
  <div class="column">Column 2</div>
  <div class="column">Column 3</div>
</div>

</body>
</html>
```

优点：简洁、现代、响应式友好。

缺点：不支持 IE8 及以下浏览器。

* 方法二：使用 CSS Grid 布局

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<style>
.container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px; /* 列之间的间距 */
}

.column {
  background-color: lightgreen;
}
</style>
</head>
<body>

<div class="container">
  <div class="column">Column 1</div>
  <div class="column">Column 2</div>
  <div class="column">Column 3</div>
</div>

</body>
</html>
```

优点：更直观地定义列宽。

缺点：兼容性略差于 Flexbox（但现代浏览器都支持）。

* 方法三：浮动 + margin（传统方法）

```html
<style>
  .container {
    overflow: hidden; /* 清除浮动 */
  }
  .left {
    float: left;
    width: 200px;
    background-color: lightblue;
  }
  .right {
    float: right;
    width: 200px;
    background-color: lightblue;
  }
  .center {
    margin-left: 200px;
    margin-right: 200px;
    background-color: lightcoral;
  }
</style>

<div class="container">
  <div class="left">Left</div>
  <div class="right">Right</div>
  <div class="center">Center</div>
</div>
```

优点：兼容性较好，适用于旧浏览器。
缺点：结构顺序影响渲染顺序，中间内容在 HTML 中需放在最后。

* 方法四：绝对定位（慎用）

```html
<style>
  .container {
    position: relative;
    width: 100%;
  }
  .left {
    position: absolute;
    left: 0;
    width: 200px;
    background-color: lightblue;
  }
  .right {
    position: absolute;
    right: 0;
    width: 200px;
    background-color: lightblue;
  }
  .center {
    margin-left: 200px;
    margin-right: 200px;
    background-color: lightcoral;
  }
</style>

<div class="container">
  <div class="left">Left</div>
  <div class="center">Center</div>
  <div class="right">Right</div>
</div>
```

优点：可以灵活控制位置。

缺点：脱离文档流，可能导致高度塌陷，维护困难。
:::

## 构建工具及工程化

### ✅Webpack 的构建流程

::: details 详解

#### Webpack 是什么

Webpack 是一个模块打包工具，它的核心功能是将项目中的各种资源（如 JavaScript、CSS、图片等）视为模块，并通过一系列流程将它们打包成优化后的静态资源。Webpack 的构建流程可以分为以下几个主要阶段：

##### 一、初始化（Initialization）

1. **解析配置文件**：
   * Webpack 启动时会读取 `webpack.config.js` 或其他指定的配置文件。
   * 配置包括入口（entry）、输出（output）、加载器（loader）、插件（plugin）等。

2. **创建 Compiler 对象**：
   * Webpack 根据配置创建一个 `Compiler` 实例。
   * 这个对象控制整个构建流程，管理所有插件和选项。

***

##### 二、编译（Compilation）

3. **执行 `run` 方法**：
   * 开始构建过程，触发 `beforeRun` 和 `run` 生命周期钩子。

4. **确定 Entry 入口文件**：
   * Webpack 从 entry 指定的文件开始分析依赖关系。

5. **创建 Compilation 对象**：
   * `Compilation` 负责实际的模块构建和打包工作。
   * 它记录了本次构建的所有模块、资源、变化和错误信息。

6. **调用 Loader 解析模块**：
   * Webpack 会根据配置中 `rules` 匹配的规则，使用对应的 loader 对模块进行转换。
   * 例如：使用 `babel-loader` 将 ES6+ 转换为 ES5；使用 `css-loader` 处理 CSS 文件。

7. **递归构建依赖图谱（Dependency Graph）**：
   * Webpack 从入口文件出发，递归地分析每一个模块的依赖关系。
   * 构建出一个完整的依赖图谱（Dependency Graph），包含所有需要打包的模块。

8. **处理异步模块（Code Splitting）**：
   * 如果使用了动态导入（`import()`）或路由懒加载，Webpack 会创建额外的 chunk。

***

##### 三、优化（Optimization）

9. **执行优化策略**：
   * 合并重复模块（ModuleConcatenationPlugin）。
   * 去除无用代码（Tree Shaking）。
   * 分割代码（SplitChunksPlugin）。
   * 哈希命名（HashedModuleIdsPlugin）。
   * 插件可以在这一阶段介入，对 chunk 进行修改。

***

##### 四、生成资源（Emit Assets）

10. **生成最终的 bundle 文件**：
    * Webpack 将模块内容按照 chunk 组织成最终的文件结构。
    * 使用模板（mainTemplate、chunkTemplate 等）生成可执行的 JS 文件。

11. **调用插件写入资源**：
    * 所有资源（JS、CSS、图片等）准备好后，通过 `emit` 钩子通知插件进行最后的处理。
    * 例如：`HtmlWebpackPlugin` 会生成 HTML 文件并自动引入打包好的 JS/CSS。

***

##### 五、输出（Output）

12. **写入磁盘或内存（开发服务器）**：
    * 如果是生产环境，Webpack 会将资源写入到磁盘上的 `output.path` 目录。
    * 如果是开发环境（使用 `webpack-dev-server`），则资源保存在内存中，不写入磁盘。

13. **完成构建**：
    * 触发 `done` 钩子，表示一次完整的构建流程结束。

***

#### 总结图示

```
初始化
  ↓
创建 Compiler
  ↓
读取配置 & 创建 Compilation
  ↓
从 Entry 开始解析模块、调用 Loader
  ↓
递归构建依赖图谱
  ↓
优化模块（Tree Shaking、SplitChunks）
  ↓
生成 Chunk & 最终 Bundle
  ↓
插件处理输出资源（HtmlWebpackPlugin 等）
  ↓
输出到磁盘 / 内存
  ↓
完成构建（done）
```

***

#### 常见插件与生命周期钩子说明

| 阶段 | 插件作用 | 示例 |
|------|----------|------|
| 初始化 | 注册事件监听器 | `BannerPlugin` |
| 编译 | 分析模块、调用 loader | `BabelLoader` |
| 优化 | 拆分代码、去重、压缩 | `SplitChunksPlugin`, `TerserPlugin` |
| 输出 | 生成 HTML、清理目录 | `HtmlWebpackPlugin`, `CleanWebpackPlugin` |
:::

### ✅vite 的构建流程

::: details 详解
Vite 底层原理的理解

#### 🧠 总览：

> Vite 构建流程分为 **开发模式构建流程** 和 **生产模式构建流程**，两者分别侧重于 **快速启动+按需加载** 和 **打包优化+产物生成**。

#### 💻 一、开发模式构建流程（`vite dev`）

开发模式下 Vite 采用的是 **原生 ES 模块导入 + 按需加载 + 极速冷启动**，主要流程如下：

##### 1. 启动 Dev Server

* 启动 `createServer()`，使用 `koa` 或类似中间件架构。
* 加载配置（如 `vite.config.ts`），应用插件钩子（如 `config`, `configureServer` 等）。

##### 2. 模块解析与按需编译

* 拦截浏览器请求（如 `/src/main.ts`）
* 对 `.ts`、`.vue`、`.jsx` 等非 JS 资源做 **按需转译**，如调用 `esbuild` 转译 TS、JSX，或 `@vite/plugin-vue` 处理 Vue。
* 转换为浏览器能直接使用的 **ES Module**，返回给浏览器。

##### 3. HMR 热更新

* 基于 `WebSocket` 通信实现模块热更新。
* 修改某文件时，只重新编译该模块及其依赖，避免整体重载。
* 插件可以处理 `handleHotUpdate`，定制热更新行为。

##### ✅ 总结优点：

* 利用浏览器原生 ES 模块
* 冷启动快，按需编译
* 极致热更新体验（仅编译改动模块）

***

#### 📦 二、生产模式构建流程（`vite build`）

构建流程使用的是 **Rollup 作为打包器**，追求优化产物体积与执行性能：

##### 1. 加载配置与插件初始化

* 执行 `vite.config.ts` 并调用 `resolveConfig`
* 执行插件生命周期钩子（如 `config`, `buildStart`, `resolveId`, `transform`, `generateBundle`）

##### 2. 构建优化前处理

* 预构建（`optimizeDeps`）：对第三方依赖使用 `esbuild` 快速打包缓存
* 扫描入口文件，解析模块依赖图

##### 3. 调用 Rollup 打包

* 使用 `Rollup` 对模块进行解析、tree shaking、生成 chunk。
* 插件链与 Rollup 插件系统融合，如 `vite:vue`、`vite:css` 等。

##### 4. 生成产物（Assets）

* 支持代码分割、动态导入
* 支持 CSS 提取、资源 hash 命名、压缩
* 可配置 `base`、`publicDir`、`manifest`、`ssr` 等参数

#### 🧩 三、插件机制贯穿全流程

Vite 的插件系统兼容 Rollup 插件，同时扩展了自己的钩子：

| 阶段   | 常见插件钩子                                            |
| ---- | ------------------------------------------------- |
| 配置加载 | `config`, `configResolved`                        |
| 开发服务 | `configureServer`, `transform`, `handleHotUpdate` |
| 打包阶段 | `buildStart`, `transform`, `generateBundle`       |

***

##### 🗣 范例：

> Vite 的构建流程可以分为两种情况。开发模式下是基于原生 ES Module 的快速启动，通过 `esbuild` 实现按需编译和极快的热更新；生产构建时则基于 Rollup，利用插件机制完成模块打包、tree-shaking 和资源优化，产物更轻更快加载。整个过程中，Vite 通过统一的插件架构，兼容了 Rollup 插件，同时也提供了自己的扩展钩子，非常灵活。

***

#### ✅ 扩展

下面是你列出的五个 Vite 核心知识点的详细对比分析和答题模板，适合口述面试或系统学习参考：

***

#### ✅ 1. Vite 和 Webpack 的构建流程对比

##### 📌 核心区别：

| 项目      | Vite                        | Webpack               |
| ------- | --------------------------- | --------------------- |
| 构建模式    | 基于原生 ES Module，开发时按需加载      | 打包所有模块为一个/多个 Bundle   |
| 启动速度    | 快速冷启动（无需预构建全部模块）            | 冷启动慢（需构建依赖 + 应用代码）    |
| 模块处理    | 使用 esbuild 做转译（TS/JSX 等）    | 使用 Babel/Loader 转译    |
| HMR 热更新 | 精细模块热更新（仅更新改动模块）            | 依赖模块图重构，热更新成本更高       |
| 构建工具    | 开发：Vite + esbuild，生产：Rollup | 开发/生产：Webpack + Babel |
| 插件体系    | Rollup 插件体系为基础 + 自定义扩展      | Webpack 独立插件体系        |
| 编译效率    | esbuild（Go 编写，10-100x 快）    | Babel（JS 编写，慢）        |

##### 🗣 回答模板：

> Vite 与 Webpack 的最大区别在于“开发时不打包”。Vite 利用浏览器的原生 ES 模块能力，按需加载模块并用 esbuild 进行极速转译。而 Webpack 则是构建时整体打包，冷启动较慢。生产模式下 Vite 使用 Rollup 构建，侧重代码优化和体积压缩。

***

#### ✅ 2. Vite 如何加速开发和构建（如 esbuild vs babel）

##### 📌 加速方式：

1. **开发构建优化**：

   * 使用 `esbuild` 替代 Babel，进行 TS/JSX 快速转译（Go 编写，极快）
   * 只处理被请求的模块（按需编译）

2. **依赖预构建**：

   * 第三方库（如 `vue`, `lodash`）在开发启动时会用 esbuild 预构建到缓存中（`optimizeDeps`），避免频繁重新处理

3. **热更新（HMR）性能高**：

   * 模块级热更新，仅重编译/重载变更模块，无需整体刷新

4. **生产构建优化**：

   * 使用 Rollup 做 Tree-shaking 和代码分割
   * 支持 `esbuild` 做 minify（构建更快）

##### 🗣 模板：

> Vite 借助 esbuild 实现了飞快的开发构建，尤其在 TS、JSX 等场景下，构建速度远超 Babel。同时，通过依赖预构建、模块级热更新和 Rollup 的产物优化，实现了开发快、构建精的双重目标。

***

#### ✅ 3. vite-plugin 的编写流程与关键钩子

##### 📌 插件结构（和 Rollup 插件类似）：

```ts
export default function myPlugin(): Plugin {
  return {
    name: 'vite:my-plugin',
    enforce: 'pre', // 控制插件执行顺序 pre/post/默认
    config(config, env) {},           // 修改配置
    configResolved(resolvedConfig) {}, // 配置已解析
    transform(code, id) {},           // 转换模块
    resolveId(id, importer) {},       // 自定义模块路径解析
    load(id) {},                      // 自定义加载模块内容
    handleHotUpdate(ctx) {},          // 热更新处理
  }
}
```

##### 📌 关键钩子：

| 钩子名               | 说明         |
| ----------------- | ---------- |
| `config`          | 修改配置前处理    |
| `configResolved`  | 配置已加载后调用   |
| `transform`       | 转换模块内容（核心） |
| `resolveId`       | 自定义路径解析逻辑  |
| `load`            | 自定义模块加载    |
| `handleHotUpdate` | 自定义 HMR 行为 |

##### 🗣 模板：

> vite-plugin 与 Rollup 插件结构基本一致，同时支持开发中用于 HMR、自定义模块加载等高级钩子。常用钩子包括 `transform`（源码转换）、`handleHotUpdate`（自定义热更新逻辑）和 `resolveId`（路径解析），可以实现各种定制行为，如自动导入、组件注册等。

***

\######✅ 4. SSR 构建流程与 `vite-ssr` 插件

#### 📌 SSR 简介：

Vite SSR（Server-Side Rendering）是一种将页面在服务器上预先渲染为 HTML，再发送给客户端的模式，提升 SEO 和首屏加载。

#### 📌 SSR 构建流程：

1. **开发阶段（`vite.ssrLoadModule`）**

   * 使用原生模块导入加载 `App.vue`、路由等
   * 动态构建、无需打包
   * 每次请求可实时加载服务端入口

2. **生产构建阶段**

   * 使用 `vite build --ssr` 生成服务端产物
   * 客户端使用正常 `vite build`
   * `manifest.json` 用于 SSR 产物资源映射

3. **常用 SSR 工具**

   * `vite-ssr`：开箱即用的 Vite SSR 解决方案
   * `vite-plugin-ssr`：灵活可扩展、支持页面文件路由
   * `Nuxt 3`：Vue 生态完整 SSR 框架

#### 🗣 模板：

> Vite SSR 支持按需加载服务端模块，开发阶段使用 `vite.ssrLoadModule` 动态加载 Vue 组件。构建阶段则通过 `vite build --ssr` 输出 Node 可用模块，结合 `manifest.json` 实现客户端资源映射。使用 `vite-ssr` 插件可以更方便地管理路由和模板渲染。

***

#### ✅ 5. vite 中 CSS 和静态资源如何处理

##### 📌 CSS 处理：

1. **开发阶段**

   * 自动注入到页面 `<style>` 标签中
   * 支持 PostCSS、预处理器（如 Sass、Less）

2. **生产阶段**

   * 使用 Rollup 插件提取为独立 CSS 文件
   * 支持 `cssCodeSplit` 分离 chunk CSS
   * 支持 `vite-plugin-css-modules`, `postcss` 插件链

3. **CSS Modules**

   ```ts
   // xxx.module.css
   .title { color: red }

   // ts
   import style from './xxx.module.css'
   style.title
   ```

##### 📌 静态资源处理：

1. **引用规则**（默认 4kb 为临界值）：

   * 小文件转 base64 内联
   * 大文件拷贝至 `dist/assets` 并替换路径

2. **使用方式**：

   * JS/TS 引入：`import logo from './logo.png'`
   * CSS 中引用：`background: url('./bg.jpg')`

3. **public 目录**

   * 放置不经过打包处理的静态资源
   * 访问路径 `/public/favicon.ico`

##### 🗣 模板：

> 在开发时，Vite 会自动将 CSS 注入到页面中，支持各种预处理器。在生产构建时，CSS 被提取成独立文件并自动分块。静态资源如图片、字体等也根据大小自动处理，内联或拷贝到 `dist/assets`。此外还有 `public` 目录专门用于不打包的静态资源。

:::

### ✅Webpack vs vite

::: details 详解

#### 🧩 一、基本介绍

##### **Webpack**

* 类型：模块打包器（module bundler）
* 发布时间：2012 年
* 特点：
  * 支持代码分割、懒加载、热更新等高级功能。
  * 插件系统非常丰富，生态庞大。
  * 主要用于**传统构建流程**（如 React、Vue、Angular 等项目）。

##### **Vite**

* 类型：新型前端构建工具
* 发布时间：2020 年（由 Vue.js 作者尤雨溪创建）
* 特点：
  * 基于原生 ES 模块（ESM），开发服务器启动快。
  * 支持 TypeScript、JSX、CSS 预处理器等无需配置即可开箱即用。
  * 构建速度极快，尤其适用于**现代浏览器和现代 JavaScript 开发**。

#### ⚙️ 二、核心区别

| 特性 | Webpack | Vite |
|------|---------|------|
| 启动速度 | 较慢（需要打包所有文件） | 极快（利用浏览器原生 ESM，按需加载） |
| 生产构建 | 使用 webpack 打包输出优化后的 bundle | 使用 Rollup 进行生产环境打包 |
| 开发模式 | 编译后提供本地服务 | 利用浏览器原生支持 ES Modules |
| 配置复杂度 | 复杂，依赖大量插件 | 简洁，大部分默认配置已满足需求 |
| 热更新（HMR） | 支持，但较慢 | 支持，响应速度快 |
| 插件系统 | 基于 webpack 插件生态（庞大） | 基于 Rollup 插件系统（逐渐成熟） |
| 支持框架 | React、Vue、Angular 等主流框架 | Vue 3、React、Svelte 等现代框架 |
| CSS 预处理 | 需手动配置 loader（如 sass-loader） | 内置支持 `.scss`, `.less`, `.styl` 等 |
| TypeScript | 需要 `ts-loader` 或 `babel-loader` | 默认支持 `.ts` 文件 |
| JSX / Vue SFC | 需配置 Babel / vue-loader | 默认支持 |

#### 📈 三、使用场景对比

##### ✅ Webpack 更适合：

* 老旧项目或需要兼容 IE11 的项目。
* 需要高度定制化打包策略的大型应用。
* 需要兼容不支持 ES Module 的浏览器环境。
* 使用 Angular 的项目（目前 Angular CLI 仍基于 Webpack）。

##### ✅ Vite 更适合：

* 现代浏览器环境下的新项目（ES6+）。
* 快速原型开发、小型到中型项目。
* 使用 Vue 3、React、Svelte 等现代框架。
* 需要极速的开发体验（尤其是 HMR）。

***

#### 🔧 四、典型命令对比

##### Webpack

```bash
# 安装
npm install --save-dev webpack webpack-cli

# 启动开发服务器
npx webpack serve

# 构建生产版本
npx webpack --mode production
```

##### Vite

```bash
# 创建项目
npm create vite@latest my-app

# 启动开发服务器
npm run dev

# 构建生产版本
npm run build
```

***

#### 🌱 五、生态系统与社区支持

| 方面 | Webpack | Vite |
|------|---------|------|
| 社区活跃度 | 非常高（长期维护） | 快速增长（Vue、React 社区支持强） |
| 插件数量 | 极其丰富 | 正在快速增长 |
| 文档质量 | 成熟且完整 | 清晰简洁，文档友好 |
| 兼容性 | 支持老旧浏览器 | 推荐用于现代浏览器 |

***

#### 📊 六、性能对比示例

| 操作 | Webpack | Vite |
|------|---------|------|
| 初始启动时间 | 5~20 秒 | < 1 秒 |
| 修改文件后热更新 | 1~3 秒 | ~0.1 秒 |
| 生产构建时间 | 10~30 秒 | 5~10 秒（Rollup） |

***

#### ✅ 七、总结建议

| 场景 | 推荐工具 |
|------|----------|
| 新项目、现代框架、追求开发效率 | ✅ Vite |
| 老项目、需要兼容 IE、高度定制化 | ✅ Webpack |
| 快速原型开发 | ✅ Vite |
| Angular 项目 | ✅ Webpack（目前主流） |
| 大型企业级应用 | 可以结合使用（Vite + 微前端架构） |
:::

### ✅[TypeScript](/learning/category/modules/page3)

::: details 详解

:::

* Uniapp
  ::: details 详解

:::

* 前端架构
  ::: details 详解

:::

## 其他

* 大文件上传方案
  ::: details 详解

:::

* 移动端适配
  ::: details 详解

:::

* 数据大屏适配
  ::: details 详解

:::

* 谷歌浏览器插件
  ::: details 详解

:::

* 脚手架cli
  ::: details 详解

:::

* vite插件编写
  ::: details 详解

:::

* vscode插件编写
  ::: details 详解

:::

* AI 前端功能实现
  ::: details 详解

:::

* SEO 如何做
  ::: details 详解

### 如何优化 SEO

> SEO（搜索引擎优化）的主要目的是通过提高网站在搜索引擎结果页面（SERPs）中的可见性和排名，从而吸引更多的有机（非付费）流量到网站

从提高`网站的可见性`和`访问量`的角度来归类，可以将上述SEO策略分为以下几个类别：

**一、提升搜索引擎可见性**

1. 关键词研究：投其所好，目标受众使用的关键词，确保自然地出现在网站内容中
2. 技术优化：使用语义化标签，加快网站加载速度、保证移动端友好、使用SSL保证网站安全、创建网站地图sitemap、使用结构化数据标记，让搜索引擎更容易和理解你的页面

**二、增加用户访问量**

1. 高质量内容创建： 提供有价值、原创与目标关键词相关的内容，吸引访问者同时鼓励其他网站链接您的页面
2. 用户体验（UX）： 设计良好、易于导航，减少跳出率，增加用户停留时间
3. 外部链接建设：获取来自权威网站的反向链接
4. 社交媒体整合：增加曝光度，间接增加访问量
5. 图片和视频优化： 图片添加alt属性。制作视频吸引流量

**三、长期增长访问量**

1. 定期更新内容：保持内容新鲜度，有利于保持搜索引擎的关注
2. 避免黑帽SEO技巧：避免使用如隐藏文本、关键词堆砌等不当做法，以免遭受搜索引擎的惩罚，影响网站的长期发展和可见性。

:::

* uniapp 插件开发
  ::: details 详解

:::

## NodeJS

* 流
  ::: details 详解

:::

---

---
url: /Interview/vue/pages/page23.md
---
# 组件中写 name 选项有哪些好处

* 可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）
* 可以通过 name 属性实现缓存功能（keep-alive）
* 可以通过 name 来识别组件（跨级组件通信时非常重要）
* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的

---

---
url: /learn/chinese/skill.md
---
# 语文

---

---
url: /Interview/vue/pages/page13.md
---
# 说一下 Vue SSR 的实现原理

SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。

SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。

---

---
url: /Interview/vue/pages/page4.md
---
# 谈一谈对 MVVM 的理解？

MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。

---

---
url: /answer/page.md
---
# 问答区

## 微信下载基础库版本 2.31.0 失败 该怎么办

::: details 解决方法

* 点击微信开发者工具左上角，微信扫码登录
* 详情->基本信息->appId 填入（从微信公众平台登录找到复制）
* 详情->本地设置->调式基础库更改为 3.8.9 点击推送
  :::

---

---
url: /Interview/js/pages/page3.md
---
# 首屏优化如何去做

## 🎯 理解问题背景

首屏优化的核心目标是`提升用户感知加载速度`，`减少白屏时间`，`让用户尽快看到内容`，从而提升用户体验和转化率。

## 🧱 二、从整体流程出发，分阶段优化

* `压缩资源`：使用 Gzip / Brotli 压缩 JS/CSS/HTML。
* `图片懒加载`：非首屏图片延迟加载，使用 loading="lazy" 或 Intersection Observer。
* `CDN 加速`：静态资源部署到 CDN，缩短请求路径。
* `字体优化`：只加载必要的字体子集，避免阻塞渲染。
* `关键资源优先级`：通过 rel="preload" 预加载关键 CSS、JS、字体。

2\. 代码分割与打包优化（Build）

* `按需加载（Code Splitting）`：使用动态 import() 拆分非首屏模块。
* `Tree Shaking`：移除未使用的代码，减小包体积。
* `SplitChunks`：将第三方库和业务代码分离，利用缓存。

3\. 服务端配合（Server）

* `服务端渲染（SSR）或预渲染（Prerendering）`：提前返回 HTML 内容，加快首屏显示。
* `HTTP/2 / HTTP/3 协议`：多路复用，减少请求耗时。
* `服务端缓存策略`：合理设置缓存头（Cache-Control、ETag），减少重复请求。

4\. 浏览器渲染优化（Render）

* `Critical Rendering Path（CRP）优化`：
  * 减少关键请求链长度。
  * 减少关键资源大小。
* `内联关键 CSS（Critical CSS）`：提前注入首屏需要的样式，避免 FOUC。
* `避免阻塞渲染的脚本`：不将 JS 放在 < head> 中同步加载，使用 async 或 defer。

5\. 监控与持续优化

* 使用 `Lighthouse`、`PageSpeed Insights`、`Web Vitals` 等工具评估性能指标。
* 关注核心指标如：
  * FCP（First Contentful Paint）
  * LCP（Largest Contentful Paint）
  * FID（First Input Delay）
  * CLS（Cumulative Layout Shift）

## 💡 三、结合项目经验举例说明

> 示例：在我上一个项目中，我们通过 `SSR` + `骨架屏` + `Critical CSS` 的方式，将 FCP 从 4s 缩短到 1.5s。同时，通过 `Webpack` 的 `Code Splitting` 和`懒加载`，将首页 JS `包体积`从 3MB 减少到 600KB，显著提升了加载速度。

## 📈 四、总结与价值输出

> “前端性能优化不仅关乎技术实现，更是产品体验的重要保障。作为开发者，我们需要从用户视角出发，持续关注性能指标，并通过工程化手段保持长期优化。”

## ✅ 加分项

* 能区分客户端渲染（CSR）和服务器端渲染（SSR）下的不同优化策略。
* 对现代构建工具（Webpack/Vite）有深入理解。
* 能说出具体的性能指标及其优化方法。
* 能结合具体项目谈经验，体现落地能力。
