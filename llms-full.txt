---
url: /note/vitePress/page1.md
---
# 1.从零用VitePress搭建个人轻型博客的正确姿势(1)

## 一、写在前面

最近在想更新一把自己的前端吧小博客，但发现wordPress版本停留在了5年之前，发现变化挺大，不支持在线直接更新，服务器正在运行的php等环境完全不支持wordPress最新版本。如果想使用最新版本，服务器环境配置必须更新，只能慢慢折腾了。

然后在想能不能用vitePress + CMS探索重构的可能性，所以接下来这是自己用vitePress搭建的纯文档博客的步骤，在此记录一下。

## 二、vitePress相关文档

首先我们要知道，VitePress 是 [VuePress](https://vuepress.vuejs.org/) 小兄弟, 它基于 [Vite](https://github.com/vitejs/vite)构建的，而[VuePress](https://vuepress.vuejs.org/) 是基于 Webpack构建的。

VitePress使用vite和Vue3的驱动的静态站点生成器，比之VuePress更加简约、轻型和高效。特点如下

* 开发服务器启动更快
* 热更新更快
* 构建更快(内部使用 Rollup)

更多不同可以查看文档：https://vitejs.cn/vitepress/#motivation

**官方英文文档**：https://vitepress.dev/

**中文文档**：

https://vitejs.cn/vitepress/

https://vitepress.qzxdp.cn/reference/site-config.html

## 三、初始化项目

### 1、创建项目目录并初始化

创建一个qianduan8目录，进入到目录，执行初始化命令

```js
pnpm init
```

### 2、本地项目安装VitePress

```javascript
pnpm add -D vitepress
```

![image-20230928151359486](./images/1.png)

### 3、配置项目目录结构

我们创建一个**docs/.vitepress**的目录和配置文件、首页，public。

开始我们创建的目录结构如下所示:

```javascript
├─ docs
│  ├─ .vitepress
│  │  └─ config.js
│  └─ index.md
│  └─ public
└─ package.json
```

说明如下：

**docs/.vitepress:**  用于存放全局的配置、自定义组件， 自定义主题（theme）等。

* config.js:  项目配置文件。

**public:**  公共文件目录，存放静态资源目录。（之后在首页和主题配置里可以直接使用 “/logo.png”引入）

**index.md**：则是站点的首页。

其中，config.js是配置VitePress网站的必要条件，它将导出一个JS对象，如果项目越来越大时，配置可以抽出来。

config.js初步配置：

```javascript
export default {
  title: '前端吧',
  description: '关注web前端开发为主的博客网站和前端网址大全',
  // 打包目录
  outDir: './dist',
   head: [
		// 添加图标
		['link', { rel: 'icon', href: '/favicon.ico' }]
	],
}
```

如上所示，我们只简单地设置了**网站标题，网站描述，打包的 dist 目录，以及网站图标**，后面更多配置都是在config.js这个文件完成。

### 4、配置运行脚本

在package.json下配置，如下：

```javascript
  "scripts": {
    "docs-dev": "vitepress dev docs",
    "docs-build": "vitepress build docs",
    "docs-serve": "vitepress serve docs"
  }
```

### 5、本地运行

执行如下命令

```javascript
pnpm docs-dev
```

结果如下：

![image.png](./images/2.png)

运行成功，不过目前网站是空的，只有一个logo标题，那么，接下来我们需要不断完善，比如配置导航，首页、自定义模板等等

---

---
url: /note/vitePress/page2.md
---
# 2.VitePress默认首页和头部导航配置

更多内容请查
[VitePress搭建博客教程系列(2) – VitePress默认首页和头部导航配置](http://www.qianduan8.com/2024.html)

---

---
url: /note/vitePress/page3.md
---
# 3.VitePress默认主题相关细节配置

更多内容请查
[VitePress搭建博客教程系列(3) – VitePress默认主题相关细节配置](http://www.qianduan8.com/2030.html)

---

---
url: /note/vitePress/page4.md
---
# 4.如何自定义布局页面模板？

更多内容请查
[VitePress搭建博客教程系列(4) – 如何自定义首页布局和主题样式修改？](http://www.qianduan8.com/2041.html)

---

---
url: /note/vitePress/page5.md
---
# 5.第三方组件库的使用-作组件库文档

更多内容请查
[VitePress搭建博客教程系列(5) – 第三方组件库的使用-搭建组件库文档？](http://www.qianduan8.com/2048.html)

---

---
url: /note/vitePress/page6.md
---
# 6.如何用Github Actions自动化部署到Github Pages？

更多内容请查

[VitePress搭建博客教程系列(6) – 用Github Actions自动化部署到Github Pages](http://www.qianduan8.com/2072.html)

---

---
url: /note/vitePress/page7.md
---
# 7. vitePress如何非自动化部署到Github Pages？

更多内容请查

[VitePress搭建博客教程系列(7) – vitePress如何非自动化部署到Github Pages？](http://www.qianduan8.com/2097.html)

---

---
url: /note/vitePress/page8.md
---
# 8. vitePress部署到Github Pages后发现样式错乱怎么办？

更多内容请查

[VitePress部署到Github Pages后发现样式全错乱了怎么办？](http://www.qianduan8.com/2099.html)

---

---
url: /examples/button.md
---
# Button 按钮

## 基础用法

```vue
<template>
  <el-button type="primary">主要按钮</el-button>
  <el-button type="success">绿色按钮</el-button>
  <el-button type="info">灰色按钮</el-button>
  <el-button type="warning">黄色按钮</el-button>
  <el-button type="danger">红色按钮</el-button>
</template>
```

### plain用法

::: details CODE

```vue
<el-button type="primary" plain>主要按钮</el-button>
<el-button type="success" plain>绿色按钮</el-button>
<el-button type="info" plain>灰色按钮</el-button>
<el-button type="warning" plain>黄色按钮</el-button>
<el-button type="danger" plain>红色按钮</el-button>
```

:::

---

---
url: /note/electron/page1.md
---
# Electron+Vue3 硬件交互篇

> 当我们使用 `Electron+Vue3` 来开发我们的桌面应用程序，有时候我们需要硬件来与我们的`Vue3`进行交互，交互主要通过 `Electron` 的主进程和渲染进程通信机制来实现。以下是大致的实现方案：

## 技术方案

**Electron的角色**

* 1.1 主进程：Node.js环境，直接调用serialport库操作硬件串口37。

* 1.2 渲染进程：Vue3页面，通过预加载脚本(preload)安全访问Node.js能力29。

* 1.3 关键约束：浏览器无法直接访问串口，必须依赖Electron的Node.js环境710。

> 主要依赖`Electron`的`Node.js`环境访问系统底层`API`的能力，结合串口通信(`SerialPort`)和进程间通信(`IPC`)技术。

## 流程示意图

![流程](../../assets/mermaid.png)

### 跨平台串口通信库

```bash
npm install electron serialport --save-dev
```

> SerialPort 是一个用于 Node.js 的跨平台串口通信库，允许 JavaScript 应用通过 RS-232、RS-485 和 USB 串行端口与硬件设备通信。它是 Electron 应用中实现硬件交互的核心工具。

### Electron主进程配置 (electron/main.js)

```js
const { app, BrowserWindow } = require('electron');
const path = require('path');

function createWindow() {
 const win = new BrowserWindow({
   webPreferences: {
     preload: path.join(__dirname, 'preload.js'),  // 关键：预加载脚本
     contextIsolation: true,  // 启用安全隔离
   }
 });
 win.loadURL(process.env.VITE_DEV_SERVER_URL || 'http://localhost:3000');
}
app.whenReady().then(createWindow);
```

### 预加载脚本 (electron/preload.js)

```js
const { contextBridge, ipcRenderer } = require('electron');
const { SerialPort } = require('serialport');

contextBridge.exposeInMainWorld('electronAPI', {
 // 获取串口列表
 getPorts: () => SerialPort.list(),
 // 监听串口数据
 onSerialData: (callback) => {
   ipcRenderer.on('serial-data', (_event, value) => callback(value));
 },
 // 发送数据到设备
 sendToDevice: (data) => ipcRenderer.send('send-to-device', data)
});
```

## 硬件接入

### 串口连接与数据监听 (主进程中)

```js
const { ipcMain } = require('electron');
const { SerialPort } = require('serialport');

let activePort = null;

// 初始化串口
ipcMain.handle('connect-serial', async (_, { path, baudRate = 9600 }) => {
 activePort = new SerialPort({ path, baudRate });
 
 activePort.on('data', data => {
   const weight = parseScaleData(data);  // 解析称重数据
   mainWindow.webContents.send('serial-data', weight); // 发送到Vue页面
 });
 
 activePort.on('error', err => console.error('串口错误:', err));
});

// 解析电子秤数据示例（根据设备协议调整）
function parseScaleData(buffer) {
 const dataStr = buffer.toString('utf-8').trim();
 // 示例：电子秤数据格式 "205   000   000"（重量在首位）
 return parseFloat(dataStr.split('    ')[0]); 
}
```

### Vue组件中调用硬件 (src/components/Scale.vue)

```vue
<template>
  <div>
    <select @change="connectScale">
      <option v-for="port in ports" :value="port.path">{{ port.path }}</option>
    </select>
    <p>当前重量: {{ currentWeight }} kg</p>
  </div>
</template>
<script setup>
import { ref, onMounted } from 'vue';

const ports = ref([]);
const currentWeight = ref(0);

// 获取可用串口列表
const loadPorts = async () => {
  ports.value = await window.electronAPI.getPorts();
};

// 监听电子秤数据
onMounted(() => {
  window.electronAPI.onSerialData((weight) => {
    currentWeight.value = weight;
  });
});
</script>
```

---

---
url: /Interview/css/pages/page1.md
---
\[\[toc]]

# flex

> `Flex` 是 `Flexible Box` 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 `Flex` 布局。行内元素也可以使用 `Flex` 布局。`display: inline-flex;`

## 容器属性

* `flex-direction：`属性决定主轴的方向（即项目的排列方向）
  ::: tip flex-direction属性的4个值

* row（默认值）：主轴为水平方向，起点在左端。

* row-reverse：主轴为水平方向，起点在右端。

* column：主轴为垂直方向，起点在上沿。

* column-reverse：主轴为垂直方向，起点在下沿。
  :::

* `flex-wrap：`默认情况下，项目都排在一条线（又称"轴线"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行

::: tip flex-wrap属性的3个值

* nowrap （默认值）：不换行。

* wrap：换行，第一行在上方。

* wrap-reverse：换行，第一行在下方。
  :::

* `flex-flow：` `flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`

* `justify-content：`项目在主轴上的对齐方式

* `align-items：`项目在交叉轴上如何对齐

* `align-content：`多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用

## 项目属性

* `order：`项目的排列顺序。数值越小，排列越靠前，默认为0
* `flex-grow：`项目的放大比例，默认为0，即如果存在剩余空间，也不放大
* `flex-shrink：`项目的缩小比例，默认为1，即如果空间不足，该项目将缩小
* `flex-basis：`在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小
* `flex：` `flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为0 1 auto。后两个属性可选
* `align-self：`允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`

---

---
url: /Interview/js/page.md
---
# JavaScript

## 1.js基本数据类型有哪些及它们的区别

::: details {open}

* 基本数据类型：`Undefined、Null、Boolean、Number、String、Symbol、BigInt`

* 引入数据类型：`Object`

* 其中 `Symbol` 和 `BigInt` 是 `ES6` 中新增的数据类型：

  * `Symbol` 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。
  * `BigInt` 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 `BigInt` 可以安全地存储和操作大整数，即使这个数已经超出了 `Number` 能够表示的安全整数范围。
    :::

## 2. 数据类型检测的方式有哪些

::: details {open}

* `typeof`
* `instanceof`
* `Object.prototype.toString.call`
* `Array.isArray`
* `=== null / === undefined`
* `Number.isNaN()`
  :::

## 3. 判断数组的方式有哪些

::: details {open}

* `obj.__proto__ === Array.prototype`
* `Array.isArrray(obj)`
* `Object.prototype.toString.call`
* `obj instanceof Array`
* `Array.prototype.isPrototypeOf`
  :::

## 4.请简述JavaScript中的this

::: details {open}
this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

* 第一种是`函数调用模式`，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
* 第二种是`方法调用模式`，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
* 第三种是`构造器调用模式`，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
* 第四种是 `apply 、 call 和 bind 调用模式`，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。
:::

## 5. let、const、var的区别

::: details {open}

* `块级作用域`： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：
  * 内层变量可能覆盖外层变量
  * 用来计数的循环变量泄露为全局变量
* `变量提升`： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。
* `给全局添加属性`： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。
* `重复声明`： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。
* `暂时性死区`： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。
* `初始值设置`： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
* `指针指向`： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

:::

### 6.原型和原型链

::: details {open}
在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 `prototype` 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 `prototype` 属性对应的值，在 `ES5` 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 `Object.getPrototypeOf()` 方法，可以通过这个方法来获取对象的原型。

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 `Object.prototype` 所以这就是新建的对象为什么能够使用 `toString()` 等方法的原因。
特点： `JavaScript` 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。
:::

## 7. 对闭包的理解

::: details {open}
`闭包是指有权访问另一个函数作用域中变量的函数`，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

**闭包有两个常用的用途**

* 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
* 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

PS: 闭包容易引起内存泄漏，谨慎使用
:::

## 8. 浏览器的垃圾回收机制

::: details {open}
**垃圾回收**：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。

**回收机制**：

* Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。
* JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。
* 不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

#### （2）垃圾回收的方式

浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。

**1）标记清除**

* 标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。
* 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。

**2）引用计数**

* 另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。
* 这种方法会引起**循环引用**的问题：例如：`obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。

:::

## 9. 哪些情况会导致内存泄漏

> 前端内存泄漏指的是 JavaScript 中已分配的内存，由于代码逻辑或引用关系的问题，不再需要却无法被垃圾回收机制回收的情况。随着时间推移，泄漏的内存不断累积，会导致页面性能下降、卡顿、崩溃，甚至影响整个浏览器或设备的稳定性

::: details {open}

* 未清理的定时器 (Timers) 和回调 (Callbacks)
* 未移除的事件监听器 (Event Listeners)
* 闭包 (Closures) 引用
* 游离的 DOM 引用 (Dangling DOM References)
* 全局变量 (Global Variables)
* console.log 持有引用
* 第三方库管理不当，如echarts 提供了销毁方法
* 未关闭的连接和订阅 (WebSockets, Observables, Event Emitters)
* 缓存管理不当
  :::

## 10. ES6有哪些新特性

::: details {open}

* `箭头函数`
* `解构赋值`
* `模板字符串`
* `promise`
* `symbol` Symbol是ES6中引入的一种新的基本数据类型,用于表示一个独一无二的值,不能与其他数据类型进行运算
* 新的变量声明方式-`let`和`const`
* 模块化-es6新增了`模块化`，根据功能封装模块，通过`import导入`，然后通过`export导出`也可以使用`export default导出`
* `for…of` 循环,用于遍历可迭代对象(如数组、Map 和 Set)中的元素
* `扩展运算符`:使用 `...` 可以将数组或对象展开成多个参数,或者将多个参数合并成一个数组
* `展开运算符:`在ES6中用`...`来表示展开运算符,它可以将数组或者对象进行展开
* `Map 和 Set`，引入了两种新的数据结构，分别用于存储键值对和唯一值
* `Proxy`，允许在对象和函数调用等操作前后添加自定义的行为
* 类（`Class`），引入了面向对象编程中类的概念
* `默认参数`（Default Parameter），在定义函数时可以给参数设置默认值
  :::

## 11. 延迟加载js的方法

async 和 defer 属性（推荐）

**async：异步加载，不阻塞渲染，加载完成后立即执行（无序）**

```html
<script src="script.js" async></script>
```

**defer：异步加载，延迟到HTML解析完成后执行（按顺序）**

```html
<script src="script.js" defer></script>
```

|方法	|是否阻塞渲染	|执行顺序	|适用场景|
|:-----------------|:-----------------|:-----------------|:-----------------|
|async	|❌ 非阻塞|	❌ 无序|	独立脚本（如分析代码）|
|defer|	❌ 非阻塞|	✅ 顺序|	依赖 DOM/其他脚本的代码|
|动态注入|	❌ 非阻塞|	可控|	精准控制加载时机|
|IntersectionObserver|	❌ 非阻塞|	可控	图片/组件懒加载|
|import()|	❌ 非阻塞|	✅ 顺序|	现代框架路由懒加载（React/Vue）|

---

---
url: /Interview/vue/pages/page11.md
---
# keep-alive的常用属性有哪些及实现原理

keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载。

常用的两个属性include/exclude，允许组件有条件的进行缓存。

两个生命周期activated/deactivated，用来得知当前组件是否处于活跃状态。

keep-alive的中还运用了LRU(Least Recently Used)算法。

---

---
url: /Interview/vue/pages/page12.md
---
# nextTick 的作用是什么？他的实现原理是什么

在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用

* Promise
* MutationObserver
* setImmediate
* 如果以上都不行则采用setTimeout

定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列

---

---
url: /Interview/pc/page.md
---
# PC端

---

---
url: /Interview/react/page.md
---
# react 高频面试题

---

---
url: /Interview/vue/pages/page24.md
---
# ref 的作用是什么

ref 的作用是被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。其特点是：

如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素
如果用在子组件上，引用就指向组件实例

所以常见的使用场景有：

1.基本用法，本页面获取 DOM 元素
2.获取子组件中的 data
3.调用子组件中的方法

---

---
url: /Interview/css/page.md
---


---

---
url: /Interview/h5/page.md
---


---

---
url: /Interview/html/page.md
---


---

---
url: /about/page.md
---
## 关于我

**技术栈**

|                                |  Stack              |
| ---------------------------------- | :----------------- |
| Language             |                    |
| FrontEnd   |                        |
| CI/CD   |                |

**能做什么？**

|         端                       |  技术栈              |
| ---------------------------------- | :----------------- |
| PC端 | vue2/vue3 |
| H5端 | vue2/vue3 |
| 微信小程序 |uniapp |
| 桌面应用程序 |uniapp |

---

---
url: /note/react.md
---
## React学习笔记

::: tip 提示
这是一个专门写React相关的文档, 可在tip后面加 自定义标题
:::

---

---
url: /site/framework.md
---


---

---
url: /site/html-css.md
---


---

---
url: /site/page.md
---


---

---
url: /Interview/vue/pages/page10.md
---
# v-if 与 v-show 的区别

当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。

---

---
url: /Interview/vue/pages/page6.md
---
# v-model 双向绑定的原理是什么

v-model本质就是一个语法糖，可以看成是value + input方法的语法糖。 可以通过model属性的prop和event属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性 。

---

---
url: /Interview/vue/pages/page16.md
---
# Vue complier 的实现原理是什么样

在使用 vue 的时候，我们有两种方式来创建我们的 HTML 页面，第一种情况，也是大多情况下，我们会使用模板 template 的方式，因为这更易读易懂也是官方推荐的方法；第二种情况是使用 render 函数来生成 HTML，它比 template 更接近最终结果。

complier 的主要作用是解析模板，生成渲染模板的 render， 而 render 的作用主要是为了生成 VNode

complier 主要分为 3 大块：

* parse：接受 template 原始模板，按着模板的节点和数据生成对应的 ast
* optimize：遍历 ast 的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过 diff 减少去对比这部分DOM，提升性能
* generate 把前两步生成完善的 ast，组成 render 字符串，然后将 render 字符串通过 new Function 的方式转换成渲染函数

---

---
url: /Interview/vue/pages/page17.md
---
# Vue 与 React 的区别是什么？

React 和 Vue 有许多相似之处，它们都有：

* 使用 Virtual DOM
* 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。
* 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。

由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要承认 React 比 Vue 更好的地方，比如更丰富的生态系统。

---

---
url: /Interview/vue/pages/page22.md
---
# Vue 中的 Key 的作用是什么

key 的作用主要是为了高效的更新虚拟 DOM 。另外 vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。
其实不只是 vue，react 中在执行列表渲染时也会要求给每个组件添加上 key 这个属性。
要解释 key 的作用，不得不先介绍一下虚拟 DOM 的 Diff 算法了。
我们知道，vue 和 react 都实现了一套虚拟 DOM，使我们可以不直接操作 DOM 元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其高效的 Diff 算法。
vue 和 react 的虚拟 DOM 的 Diff 算法大致相同，其核心有以下两点：

两个相同的组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构。
同一层级的一组节点，他们可以通过唯一的 id 进行区分。

基于以上这两点，使得虚拟 DOM 的 Diff 算法的复杂度从 O(n^3) 降到了 O(n) 。

---

---
url: /Interview/vue/pages/page21.md
---
# vue 中的 spa 应用如何优化首屏加载速度

**优化首屏加载可以从这几个方面开始：**

* 请求优化：CDN 将第三方的类库放到 CDN 上，能够大幅度减少生产环境中的项目体积，另外 CDN 能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
* 缓存：将长时间不会改变的第三方类库或者静态资源设置为强缓存，将 max-age 设置为一个非常长的时间，再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源，好的缓存策略有助于减轻服务器的压力，并且显著的提升用户的体验
* gzip：开启 gzip 压缩，通常开启 gzip 压缩能够有效的缩小传输资源的大小。
* http2：如果系统首屏同一时间需要加载的静态资源非常多，但是浏览器对同域名的 tcp 连接数量是有限制的(chrome 为 6 个)超过规定数量的 tcp 连接，则必须要等到之前的请求收到响应后才能继续发送，而 http2 则可以在多个 tcp 连接中并发多个请求没有限制，在一些网络较差的环境开启 http2 性能提升尤为明显。
* 懒加载：当 url 匹配到相应的路径时，通过 import 动态加载页面组件，这样首屏的代码量会大幅减少，webpack 会把动态加载的页面组件分离成单独的一个 chunk.js 文件
* 预渲染：由于浏览器在渲染出页面之前，需要先加载和解析相应的 html、css 和 js 文件，为此会有一段白屏的时间，可以添加loading，或者骨架屏幕尽可能的减少白屏对用户的影响体积优化
* 合理使用第三方库：对于一些第三方 ui 框架、类库，尽量使用按需加载，减少打包体积
  使用可视化工具分析打包后的模块体积：webpack-bundle- analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，再对其中比较大的模块进行优化
* 提高代码使用率：利用代码分割，将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程
* 封装：构建良好的项目架构，按照项目需求就行全局组件，插件，过滤器，指令，utils 等做一 些公共封装，可以有效减少我们的代码量，而且更容易维护资源优化
* 图片懒加载：使用图片懒加载可以优化同一时间减少 http 请求开销，避免显示图片导致的画面抖动，提高用户体验
  使用 svg 图标：相对于用一张图片来表示图标，svg 拥有更好的图片质量，体积更小，并且不需要开启额外的 http 请求
* 压缩图片：可以使用 image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片

---

---
url: /Interview/vue/pages/page19.md
---
# vue 修饰符

**在 vue 中修饰符可以分为 3 类：**

* 事件修饰符
* 按键修饰符
* 表单修饰符

**事件修饰符**

> 在事件处理程序中调用 event.preventDefault 或 event.stopPropagation 方法是非常常见的需求。尽管可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。
> 为了解决这个问题，vue 为 v-on 提供了事件修饰符。通过由点 . 表示的指令后缀来调用修饰符。

常见的事件修饰符如下：

* .stop：阻止冒泡。
* .prevent：阻止默认事件。
* .capture：使用事件捕获模式。
* .self：只在当前元素本身触发。
* .once：只触发一次。
* .passive：默认行为将会立即触发。

**按键修饰符**

除了事件修饰符以外，在 vue 中还提供了有鼠标修饰符，键值修饰符，系统修饰符等功能。

* .left：左键
* .right：右键
* .middle：滚轮
* .enter：回车
* .tab：制表键
* .delete：捕获 “删除” 和 “退格” 键
* .esc：返回
* .space：空格
* .up：上
* .down：下
* .left：左
* .right：右
* .ctrl：ctrl 键
* .alt：alt 键
* .shift：shift 键
* .meta：meta 键

**表单修饰符**

> vue 同样也为表单控件也提供了修饰符，常见的有 .lazy、 .number 和 .trim。

* .lazy：在文本框失去焦点时才会渲染
* .number：将文本框中所输入的内容转换为number类型
* .trim：可以自动过滤输入首尾的空格

---

---
url: /Interview/vue/pages/page15.md
---
# Vue 的 computed 的实现原理

当组件实例触发生命周期函数 beforeCreate 后，它会做一系列事情，其中就包括对 computed 的处理。

它会遍历 computed 配置中的所有属性，为每一个属性创建一个 Watcher 对象，并传入一个函数，该函数的本质其实就是 computed 配置中的 getter，这样一来，getter 运行过程中就会收集依赖

但是和渲染函数不同，为计算属性创建的 Watcher 不会立即执行，因为要考虑到该计算属性是否会被渲染函数使用，如果没有使用，就不会得到执行。因此，在创建 Watcher 的时候，它使用了 lazy 配置，lazy 配置可以让 Watcher 不会立即执行。

收到 lazy 的影响，Watcher 内部会保存两个关键属性来实现缓存，一个是 value，一个是 dirty

value 属性用于保存 Watcher 运行的结果，受 lazy 的影响，该值在最开始是 undefined

dirty 属性用于指示当前的 value 是否已经过时了，即是否为脏值，受 lazy 的影响，该值在最开始是 true

Watcher 创建好后，vue 会使用代理模式，将计算属性挂载到组件实例中
当读取计算属性时，vue 检查其对应的 Watcher 是否是脏值，如果是，则运行函数，计算依赖，并得到对应的值，保存在 Watcher 的 value 中，然后设置 dirty 为 false，然后返回。

如果 dirty 为 false，则直接返回 watcher 的 value
巧妙的是，在依赖收集时，被依赖的数据不仅会收集到计算属性的 Watcher，还会收集到组件的 Watcher

当计算属性的依赖变化时，会先触发计算属性的 Watcher 执行，此时，它只需设置 dirty 为 true 即可，不做任何处理。

由于依赖同时会收集到组件的 Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为 dirty，因此会重新运行 getter 进行运算

而对于计算属性的 setter，则极其简单，当设置计算属性时，直接运行 setter 即可。

---

---
url: /Interview/vue/pages/page14.md
---
# Vue 组件的 data 为什么必须是函数

一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。

---

---
url: /Interview/vue/page.md
---
# vue 高频面试题

---

---
url: /Interview/vue/pages/page7.md
---
# vue2.x 和 vuex3.x 渲染器的 diff 算法分别说一下

简单来说，diff算法有以下过程

* 同级比较，再比较子节点
* 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
* 比较都有子节点的情况(核心diff)
* 递归比较子节点

正常Diff两个树的时间复杂度是O(n^3)，但实际情况下我们很少会进行跨层级的移动DOM，所以Vue将Diff进行了优化，从O(n^3) -> O(n)，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

Vue3.x借鉴了 ivi算法和 inferno算法
在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)

该算法中还运用了动态规划的思想求解最长递归子序列。

---

---
url: /Interview/vue/pages/page3.md
---
# vue3和vue2的区别

* 双向绑定的方法不一样： Vue3 使用了new Proxy，Vue2 使用了Object.defineProperty

* $set 在Vue3中没有，因为 `new Proxy` 不需要

- Vue2 是选项式 API，Vue3 向下兼容，可以是 选项式 也可以 是组合式，语法糖 setup

- Vue2 v-for 优先级大于 v-if，Vue3 是 v-if 大于 v-for

- 源码组织方式变化：使用 TS 重写

- 支持 Composition API：基于函数的API，更加灵活组织组件逻辑（vue2用的是options api）

- `响应式系统提升`：Vue3中响应式数据原理改成proxy，可监听动态新增删除属性，以及数组变化

- 编译优化：vue2通过标记静态根节点优化diff，Vue3 标记和提升所有静态根节点，diff的时候只需要对比动态节点内容

- 打包体积优化：移除了一些不常用的api（inline-template、filter）

- 生命周期的变化：使用setup代替了之前的beforeCreate和created

- Vue3 的 template 模板支持多个根标签

- Vuex状态管理：创建实例的方式改变,Vue2为new Store , Vue3为createStore

- Route 获取页面实例与路由信息：vue2通过this获取router实例，vue3通过使用 getCurrentInstance/ userRoute和userRouter方法获取当前组件实例

- Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props

- 父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下

---

---
url: /Interview/vue/pages/page2.md
---
# vue响应式原理是什么？vue3的响应式有何不同

Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。

Vue3.x改用Proxy替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。

Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？

判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。

监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？

我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。

---

---
url: /note/vue.md
---
# Vue学习笔记-调试测试

```javascript
const VNode = {
  type: 'div',
  props: {
    class: 'name'
  },
  children: '我是文本'
}

// 创建 render 渲染函数
function render(vnode) {
  // 根据 type 生成 element
  const ele = document.createElement(vnode.type)
  // 把 props 中的 class 赋值给 ele 的 className
  ele.className = vnode.props.class
  // 把 children 赋值给 ele 的 innerText
  ele.innerText = vnode.children
  // 把 ele 作为子节点插入 body 中
  document.body.appendChild(ele)
}

render(VNode)

```

---

---
url: /Interview/vue/pages/page1.md
---
# vue的生命周期有哪些及每个生命周期做了什么

* `beforeCreate`是`new Vue()`之后触发的第一个钩子，在当前阶段`data、methods、computed以及watch`上的数据和方法都不能被访问。

* `created`在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。

* `beforeMount`发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。

* `mounted`在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。

* `beforeUpdate`发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。

* `updated`发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。

* `beforeDestroy`发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。

* `destroyed`发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

---

---
url: /Interview/vue/pages/page9.md
---
# Vue的路由实现, hash路由和history路由实现原理说一下

`location.hash`的值实际就是URL中`#`后面的东西。

history实际采用了HTML5中提供的API来实现，主要有history.pushState()和history.replaceState()。

---

---
url: /Interview/vue/pages/page8.md
---
# vue组件通信方式有哪些及原理

## 父传后代

> 后代拿到了父的数据

* `props`：父传子很方便，父传孙很麻烦（父=>子=>孙），这种方式子不能修改父组件的数据
* `$parent`: 这种方式子能修改父组件的数据
* `provide`&`inject`：依赖注入，优势父组件可以直接向某个后代传值，不用一级一级的传递,官方不推荐使用，但是写组件库时很常用
* `$attrs` &`$listeners`：透传属性/事件
  * `$attrs`：接收父组件非 props 的属性
  * `$listeners`：接收父组件所有事件监听器。
  ```vue
    <!-- 中间组件 -->
    <Grandchild v-bind="$attrs" v-on="$listeners" />
  ```

## 后代传父

> 父拿到了后代的数据

* 子组件传给父组件用 `this.$emit`
* 父组件直接拿子组件数据 `this.$refs.子组件ref`

## 兄弟间传值

* `eventBus`，实际上就是 `new Vue()`

## 其他

**Vuex**

---

---
url: /Interview/vue/pages/page18.md
---
# watch 与 computed 的区别是什么以及他们的使用场景分别是什么

**区别：**

* 都是观察数据变化的（相同）
* 计算属性将会混入到 vue 的实例中，所以需要监听自定义变量；watch 监听 data 、props 里面数据的变化；
* computed 有缓存，它依赖的值变了才会重新计算，watch 没有；
* watch 支持异步，computed 不支持；
* watch 是一对多（监听某一个值变化，执行对应操作）；computed 是多对一（监听属性依赖于其他属性）
* watch 监听函数接收两个参数，第一个是最新值，第二个是输入之前的值；
* computed 属性是函数时，都有 get 和 set 方法，默认走 get 方法，get 必须有返回值（return）

**watch 的 参数：**

* deep：深度监听
* immediate ：组件加载立即触发回调函数执行

**computed 缓存原理：**

conputed本质是一个惰性的观察者；当计算数据存在于 data 或者 props里时会被警告；

vue 初次运行会对 computed 属性做初始化处理（initComputed），初始化的时候会对每一个 computed 属性用 watcher 包装起来 ，这里面会生成一个 dirty 属性值为 true；然后执行 defineComputed 函数来计算，计算之后会将 dirty 值变为 false，这里会根据 dirty 值来判断是否需要重新计算；如果属性依赖的数据发生变化，computed 的 watcher 会把 dirty 变为 true，这样就会重新计算 computed 属性的值。

---

---
url: /Interview/vue/pages/page25.md
---
# 你的接口请求一般放在哪个生命周期中？为什么要这样做？

接口请求可以放在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。

但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

能更快获取到服务端数据，减少页面 loading 时间
SSR 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于代码的一致性

created 是在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。如果在 mounted 钩子函数中请求数据可能导致页面闪屏问题

---

---
url: /note/css/css.md
---
# 列表布局

> 在微信小程序 或是 移动端上，有时候会出现神秘的1px差异，如果你是商品列表 三个 一行，那么第一行的第三个将会挤到第二行去，从而导致样式错乱，以下布局可以解决以上问题

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
*{
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
.product-list {
  display: flex;
  flex-wrap: wrap;
  gap: 8px; /* 商品之间的间距 */
}

.product-item {
  flex: 0 0 calc((100% - 2 * 8px) / 3); /* 计算出正确的宽度，减去左右边距影响 */
  box-sizing: border-box;
  background-color: #f8f8f8;
  padding: 16px;
  text-align: center;
}
@media (max-width: 768px) {
  .product-item {
    flex: 0 0 calc((100% - 1 * 8px) / 2);
  }
}

@media (max-width: 480px) {
  .product-item {
    flex: 0 0 100%;
  }
}  
</style>

<body>
  <div class="product-list">
    <div class="product-item">商品 1</div>
    <div class="product-item">商品 2</div>
    <div class="product-item">商品 3</div>
    <div class="product-item">商品 4</div>
    <div class="product-item">商品 5</div>
    <div class="product-item">商品 6</div>
    <div class="product-item">商品 7</div>
    <div class="product-item">商品 8</div>
    <div class="product-item">商品 9</div>
    <div class="product-item">商品 10</div>
    <div class="product-item">商品 11</div>
    <div class="product-item">商品 12</div>
    <div class="product-item">商品 13</div>
    <div class="product-item">商品 14</div>
    <div class="product-item">商品 15</div>
    <div class="product-item">商品 16</div>
  </div>
</body>
</html>
```

---

---
url: /Interview/js/pages/page1.md
---
# 前端内存泄漏有哪些情况

> 前端内存泄漏指的是 JavaScript 中已分配的内存，由于代码逻辑或引用关系的问题，不再需要却无法被垃圾回收机制回收的情况。随着时间推移，泄漏的内存不断累积，会导致页面性能下降、卡顿、崩溃，甚至影响整个浏览器或设备的稳定性。

**以下是前端开发中常见的内存泄漏原因和场景**

## 未清理的定时器 (Timers) 和回调 (Callbacks)

* setInterval() 或 setTimeout() 被调用后，如果其回调函数引用了外部变量（尤其是 DOM 元素或大型对象），并且没有在适当的时候（如组件卸载、页面离开时）使用 clearInterval() 或 clearTimeout() 清除，那么这些定时器会一直存在，其引用的对象也无法被回收。

* 示例： 在单页应用(SPA)的组件中启动定时器更新状态，但在组件卸载时忘记清除。

## 未移除的事件监听器 (Event Listeners)

* 使用 addEventListener() 给 DOM 元素（特别是 window, document 等全局对象或动态创建的元素）添加了事件监听器，但在元素被移除（removeChild, innerHTML 清空等）或不再需要时（如组件卸载），没有使用 removeEventListener() 移除监听器。

* 示例： 给一个按钮添加点击事件，当这个按钮所在的模态框被关闭并从 DOM 中移除时，如果没有移除监听器，那么监听器函数和它可能引用的外部作用域变量（包括被移除的按钮本身！）都会泄漏。在 SPA 中给全局对象添加监听器，切换路由时忘记移除是常见原因。

## 闭包 (Closures) 引用

* 闭包是 JavaScript 的核心特性，它使得内部函数可以访问外部函数的变量。如果闭包（例如一个事件处理函数、定时器回调、异步操作回调）持有了对外部函数作用域中某个大对象（如 DOM 元素、数组、对象）的引用，并且这个闭包的生命周期很长（比如被挂载到全局变量、DOM 事件上），那么即使外部函数执行完毕，它引用的外部变量也无法被 GC 回收。

* 示例： 一个函数内部定义了一个事件处理函数（闭包），这个处理函数引用了函数内部的一个大数组。将事件处理函数绑定到 DOM 元素上，那么该大数组会一直存在，直到事件被移除且没有其他引用

## 游离的 DOM 引用 (Dangling DOM References)

* 在 JavaScript 中保存了对某个 DOM 元素的引用（例如 let element = document.getElementById('myElement');），即使后来这个元素从实际的 DOM 树中被移除了（element.parentNode.removeChild(element);），只要 JavaScript 变量 element 还存在（例如保存在某个数组、对象或全局变量中），那么这个被移除的 DOM 元素及其关联的事件监听器和子元素占用的内存就不会被释放。

* 示例： 维护一个数组来缓存已创建的列表项 DOM 元素，当从页面删除某些项时，只从 DOM 树中移除了，但没有从缓存数组中删除对应的引用。

## 全局变量 (Global Variables)

* 意外创建的全局变量（如在函数内部忘记写 var, let, const）或故意将大对象赋值给全局变量（window.myHugeData = ...;）。全局变量存在于全局作用域，贯穿整个应用的生命周期，永远不会被 GC 回收。

* 示例： function foo() { bar = 'oops'; } (创建了全局变量 bar)。或者 window.cache = {}; 并且不断往里面塞数据而不清理。

## console.log 持有引用

* 在开发过程中，console.log 打印大型对象、数组或 DOM 元素。浏览器控制台为了便于开发者检查（例如可以展开对象），会保留对这些被打印对象的引用，阻止其被回收。虽然在生产环境 console.log 通常会被移除，但遗漏的 console.log 在生产环境也可能造成泄漏（尤其是在打印大对象时）。

## 第三方库管理不当

* 使用第三方库（如图表库、地图库、富文本编辑器）时，如果库本身存在内存泄漏问题。

* 更常见的是，没有按照库的要求在实例不再需要时调用其销毁/清理方法（如 destroy(), dispose(), unmount()）。库内部可能创建了 DOM、事件监听器、Web Workers、WebSockets 等资源，如果不主动销毁，这些资源及其关联的 JS 对象就会泄漏。

## 未关闭的连接和订阅 (WebSockets, Observables, Event Emitters)

* 创建了 WebSocket 连接、订阅了 RxJS Observable、或者使用了 EventEmitter 模式，但在不再需要时（组件卸载、页面离开）没有关闭连接（websocket.close()）或取消订阅（subscription.unsubscribe()）。这些连接或订阅的回调函数可能持有对组件或其他对象的引用，导致泄漏。

## 缓存管理不当

* 实现自定义缓存机制时，如果没有设置合理的过期策略或大小限制，缓存的数据会无限增长，占用越来越多的内存

## 如何排查和避免内存泄漏

使用浏览器开发者工具 (Chrome DevTools):

Performance Monitor: 实时监控 JS Heap Size、DOM Nodes 等指标，观察是否有持续增长的趋势。

Memory Profiler:

Heap Snapshots: 在不同操作（如打开/关闭组件）前后拍摄堆快照，对比查找持续增长或未被释放的对象及其引用链。

Allocation instrumentation on timeline: 实时跟踪内存分配，定位频繁分配且未被回收的对象。

Performance Recordings: 记录性能时间线，观察内存使用趋势，并与用户操作关联。

良好的编码习惯：

及时清理： 对定时器、事件监听器、第三方库实例、订阅、WebSocket 连接等，在它们不再需要时（componentWillUnmount / useEffect cleanup / beforeDestroy / onPageHide 等生命周期或事件中）主动清除、移除、销毁、取消订阅、关闭。

谨慎使用闭包： 注意闭包引用了哪些外部变量，评估其生命周期。必要时可以手动解除引用（如将引用置为 null）。

管理 DOM 引用： 当 DOM 元素被移除后，确保删除所有指向它的 JavaScript 引用（将其置为 null 或从数组中移除）。

避免全局变量： 尽量使用模块作用域、函数作用域或块级作用域变量 (let, const)。必须使用全局状态时，考虑使用状态管理库（如 Redux, Vuex）并注意清理。

清理 console.log: 在提交代码前移除或注释掉不必要的 console.log，尤其是打印大型对象时。

遵循第三方库规范： 仔细阅读库的文档，了解其资源管理要求，务必在适当时机调用清理方法。

使用 WeakMap / WeakSet： 当需要存储对对象的弱引用（即引用不阻止 GC）时，可以使用 WeakMap 和 WeakSet。这常用于存储与对象关联的元数据，而不会阻止对象被回收。

代码审查： 在团队协作中，代码审查是发现潜在内存泄漏模式（如忘记清理监听器、定时器）的好方法。

自动化测试 (可选但推荐)： 使用类似 Puppeteer 或 Playwright 的工具编写 E2E 测试，结合 DevTools 的 Memory API 或 Performance Monitor，在关键用户流（如多次打开/关闭模态框、导航页面）后检查内存是否稳定。

总结： 前端内存泄漏的核心在于 “不需要的对象因为意外的引用而无法被回收”。解决的关键在于意识（了解常见泄漏点）、习惯（及时清理资源、谨慎管理引用）和工具（善用 DevTools 进行检测和分析）。尤其是在构建复杂的单页应用时，内存管理至关重要。

---

---
url: /guide/start.md
---
# 前端前沿

---

---
url: /Interview/vue/pages/page5.md
---
# 在 Vue2.x 中如何检测数组的变化

使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

---

---
url: /Interview/pc/pages/page1.md
---
# 大屏自适应

---

---
url: /Interview/vue/pages/page20.md
---
# 如何实现 vue 项目中的性能优化

**编码阶段**

* 尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher
* v-if 和 v-for 不能连用
* 如果需要使用 v-for 给每项元素绑定事件时使用事件代理
* SPA 页面采用 keep-alive 缓存组件
* 在更多的情况下，使用 v-if 替代 v-show
* key 保证唯一
* 使用路由懒加载、异步组件
* 防抖、节流
* 第三方模块按需导入
* 长列表滚动到可视区域动态加载
* 图片懒加载

**SEO 优化**

* 预渲染
* 服务端渲染 SSR

**打包优化**

* 压缩代码
* Tree Shaking/Scope Hoisting
* 使用 cdn 加载第三方模块
* 多线程打包 happypack
* splitChunks 抽离公共文件
* sourceMap 优化

**用户体验**

* 骨架屏
* PWA

---

---
url: /frontend/library.md
---
# 工具库 rutilsjs

## rutilsjs 简介

> `rutilsjs` 是一个前端原生`JavaScript`库，提供了大量工具函数给前端开发人员使用，以提供开发效率

## 如何使用

```bash
npm i rutilsjs
```

---

---
url: /Interview/js/pages/page2.md
---
# 延迟加载js的方法

## async 和 defer 属性（推荐）

**async：异步加载，不阻塞渲染，加载完成后立即执行（无序）**

```html
<script src="script.js" async></script>
```

**defer：异步加载，延迟到HTML解析完成后执行（按顺序）**

```html
<script src="script.js" defer></script>
```

## 动态脚本注入

**通过JavaScript动态创建标签script**

```js
function loadScript(src) {
  const script = document.createElement('script');
  script.src = src;
  document.body.appendChild(script); // 添加到DOM后开始加载
}
// 按需调用
loadScript('path/to/script.js');
```

## 事件触发加载

**在特定用户行为（如点击、滚动）后加载：**

|方法	|是否阻塞渲染	|执行顺序	|适用场景|
|:-----------------|:-----------------|:-----------------|:-----------------|
|async	|❌ 非阻塞|	❌ 无序|	独立脚本（如分析代码）|
|defer|	❌ 非阻塞|	✅ 顺序|	依赖 DOM/其他脚本的代码|
|动态注入|	❌ 非阻塞|	可控|	精准控制加载时机|
|IntersectionObserver|	❌ 非阻塞|	可控	图片/组件懒加载|
|import()|	❌ 非阻塞|	✅ 顺序|	现代框架路由懒加载（React/Vue）|

---

---
url: /openSource/open-source.md
---
# 我的开源项目

> 我热爱开源与技术钻研，追求技术深度的同时，也致力于个人成长。

**技术社区**

[我的掘金](https://juejin.cn/user/4212984287071710)

## 热区图片插件

```bash
npm i img-hotspot
```

[去看示例](https://codesandbox.io/p/sandbox/image-hotspot-tu-pian-re-qu-lkczjc) [去看文档](https://www.npmjs.com/package/img-hotspot)

**是否有重构计划：**❌

## 常用工具库

```bash
npm i rutilsjs
```

[去看文档](https://shufei021.github.io/rutils/)

**是否有重构计划：** ✅

## 日期工具库

```bash
npm i rdatejs
```

[去看文档](https://shufei021.github.io/rdate/)

**是否有重构计划：** ❌  建议项目使用dayjs替换

## 移动端无限弹出层插件

> 这是基于Vue2.0的物理返回组件。在移动终端上编写H5页面时，您通常只想在当前页面上打开一个弹出层。如果不想操作，请单击左上角的物理返回按钮返回当前页面。始终在当前页面上，这样做的好处是保持数据状态不变

```bash
npm i vue-popup-layer
```

[去看文档](https://www.npmjs.com/package/vue-popup-layer) [去看示例](https://codesandbox.io/p/sandbox/blissful-microservice-0q3mo)

**是否有重构计划：**✅

---

---
url: /frontend/plugin.md
---
# 插件库

---

---
url: /learn/math/skill.md
---
# 数学

```mermaid
gantt
    title 项目计划
    dateFormat  YYYY-MM-DD
    section 阶段一
    需求分析       :done,    des1, 2023-01-01, 7d
    设计           :active,  des2, 2023-01-08, 5d
    section 阶段二
    开发           :         des3, 2023-01-15, 10d
    测试           :         des4, 2023-01-25, 5d
```

---

---
url: /Interview/vue/pages/page23.md
---
# 组件中写 name 选项有哪些好处

* 可以通过名字找到对应的组件（ 递归组件：组件自身调用自身 ）
* 可以通过 name 属性实现缓存功能（keep-alive）
* 可以通过 name 来识别组件（跨级组件通信时非常重要）
* 使用 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的

---

---
url: /learn/chinese/skill.md
---
# 语文

---

---
url: /Interview/vue/pages/page13.md
---
# 说一下 Vue SSR 的实现原理

SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。

SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。

---

---
url: /Interview/vue/pages/page4.md
---
# 谈一谈对 MVVM 的理解？

MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。
